Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    COMMENT
    TVOID
    VOID

Grammar

Rule 0     S' -> definition_sequence
Rule 1     definition_sequence -> definition definition_sequence
Rule 2     definition_sequence -> definition
Rule 3     definition -> function_declaration
Rule 4     definition -> variable_declaration
Rule 5     variable_declaration -> identifier COLON type SEMICOLON
Rule 6     variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON
Rule 7     function_declaration -> function_heading body
Rule 8     function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
Rule 9     function_heading -> identifier COLON type LPAREN parameter_list RPAREN
Rule 10    parameter_list -> parameter COMMA parameter_list
Rule 11    parameter_list -> parameter
Rule 12    parameter_list -> <empty>
Rule 13    parameter -> identifier COLON type
Rule 14    statement_part -> LBRACKET statement_sequence RBRACKET
Rule 15    statement_sequence -> statement statement_sequence
Rule 16    statement_sequence -> statement
Rule 17    statement -> statement_part
Rule 18    statement -> local_variable_declaration
Rule 19    statement -> assignment_statement
Rule 20    statement -> array_def
Rule 21    statement -> if_statement
Rule 22    statement -> while_statement
Rule 23    statement -> return_statement
Rule 24    statement -> expression SEMICOLON
Rule 25    statement -> <empty>
Rule 26    body -> statement
Rule 27    param_list -> param COMMA param_list
Rule 28    param_list -> param
Rule 29    param_list -> <empty>
Rule 30    param -> expression
Rule 31    local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON
Rule 32    assignment_statement -> identifier ASSIGNMENT expression SEMICOLON
Rule 33    assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
Rule 34    array_def -> identifier COLON type SEMICOLON
Rule 35    if_statement -> IF expression body ELSE body
Rule 36    if_statement -> IF expression body
Rule 37    while_statement -> WHILE expression body
Rule 38    return_statement -> RETURN expression SEMICOLON
Rule 39    expression -> expression_m
Rule 40    expression -> expression and_or expression_m
Rule 41    expression_m -> expression_e
Rule 42    expression_m -> expression_m sign expression_e
Rule 43    and_or -> AND
Rule 44    and_or -> OR
Rule 45    sign -> TIMES
Rule 46    sign -> DIV
Rule 47    sign -> PLUS
Rule 48    sign -> MINUS
Rule 49    sign -> MOD
Rule 50    sign -> EQUAL
Rule 51    sign -> NEQUAL
Rule 52    sign -> LT
Rule 53    sign -> LTE
Rule 54    sign -> GT
Rule 55    sign -> GTE
Rule 56    expression_e -> identifier
Rule 57    expression_e -> integer
Rule 58    expression_e -> float
Rule 59    expression_e -> string
Rule 60    expression_e -> bool
Rule 61    expression_e -> array
Rule 62    expression_e -> LPAREN expression RPAREN
Rule 63    expression_e -> NOT expression
Rule 64    expression_e -> function_call
Rule 65    expression_e -> array_call
Rule 66    function_call -> identifier LPAREN param_list RPAREN
Rule 67    array_call -> identifier LBRACKET_S expression RBRACKET_S
Rule 68    identifier -> IDENTIFIER
Rule 69    integer -> INTEGER
Rule 70    float -> FLOAT
Rule 71    string -> STRING
Rule 72    bool -> BOOL
Rule 73    array -> LBRACKET_S expression RBRACKET_S
Rule 74    type -> TINTEGER
Rule 75    type -> TFLOAT
Rule 76    type -> TSTRING
Rule 77    type -> TBOOL
Rule 78    type -> LBRACKET_S type RBRACKET_S

Terminals, with rules where they appear

AND                  : 43
ARRAY                : 
ASSIGNMENT           : 6 31 32 33
BOOL                 : 72
COLON                : 5 6 8 9 13 31 34
COMMA                : 10 27
COMMENT              : 
DIV                  : 46
ELSE                 : 35
EQUAL                : 50
FLOAT                : 70
GT                   : 54
GTE                  : 55
IDENTIFIER           : 68
IF                   : 35 36
INTEGER              : 69
LBRACKET             : 14
LBRACKET_S           : 33 67 73 78
LPAREN               : 8 9 62 66
LT                   : 52
LTE                  : 53
MINUS                : 48
MOD                  : 49
NEQUAL               : 51
NOT                  : 63
OR                   : 44
PLUS                 : 47
RBRACKET             : 14
RBRACKET_S           : 33 67 73 78
RETURN               : 38
RPAREN               : 8 9 62 66
SEMICOLON            : 5 6 8 24 31 32 33 34 38
STRING               : 71
TBOOL                : 77
TFLOAT               : 75
TIMES                : 45
TINTEGER             : 74
TSTRING              : 76
TVOID                : 
VOID                 : 
WHILE                : 37
error                : 

Nonterminals, with rules where they appear

and_or               : 40
array                : 61
array_call           : 65
array_def            : 20
assignment_statement : 19
body                 : 7 35 35 36 37
bool                 : 60
definition           : 1 2
definition_sequence  : 1 0
expression           : 6 24 30 31 32 33 33 35 36 37 38 40 62 63 67 73
expression_e         : 41 42
expression_m         : 39 40 42
float                : 58
function_call        : 64
function_declaration : 3
function_heading     : 7
identifier           : 5 6 8 9 13 31 32 33 34 56 66 67
if_statement         : 21
integer              : 57
local_variable_declaration : 18
param                : 27 28
param_list           : 27 66
parameter            : 10 11
parameter_list       : 8 9 10
return_statement     : 23
sign                 : 42
statement            : 15 16 26
statement_part       : 17
statement_sequence   : 14 15
string               : 59
type                 : 5 6 8 9 13 31 34 78
variable_declaration : 4
while_statement      : 22

Parsing method: LALR

state 0

    (0) S' -> . definition_sequence
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (68) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 7

    definition_sequence            shift and go to state 1
    definition                     shift and go to state 2
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 1

    (0) S' -> definition_sequence .



state 2

    (1) definition_sequence -> definition . definition_sequence
    (2) definition_sequence -> definition .
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (68) identifier -> . IDENTIFIER

    $end            reduce using rule 2 (definition_sequence -> definition .)
    IDENTIFIER      shift and go to state 7

    definition                     shift and go to state 2
    definition_sequence            shift and go to state 8
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 3

    (3) definition -> function_declaration .

    IDENTIFIER      reduce using rule 3 (definition -> function_declaration .)
    $end            reduce using rule 3 (definition -> function_declaration .)


state 4

    (4) definition -> variable_declaration .

    IDENTIFIER      reduce using rule 4 (definition -> variable_declaration .)
    $end            reduce using rule 4 (definition -> variable_declaration .)


state 5

    (7) function_declaration -> function_heading . body
    (26) body -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON type SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (68) identifier -> . IDENTIFIER
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    $end            reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]

    body                           shift and go to state 9
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    expression                     shift and go to state 18
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 6

    (8) function_declaration -> identifier . COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier . COLON type SEMICOLON
    (6) variable_declaration -> identifier . COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier . COLON type LPAREN parameter_list RPAREN

    COLON           shift and go to state 40


state 7

    (68) identifier -> IDENTIFIER .

    COLON           reduce using rule 68 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 68 (identifier -> IDENTIFIER .)
    LBRACKET_S      reduce using rule 68 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 68 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 68 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 68 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 68 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 68 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 68 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 68 (identifier -> IDENTIFIER .)
    NEQUAL          reduce using rule 68 (identifier -> IDENTIFIER .)
    LT              reduce using rule 68 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 68 (identifier -> IDENTIFIER .)
    GT              reduce using rule 68 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 68 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 68 (identifier -> IDENTIFIER .)
    AND             reduce using rule 68 (identifier -> IDENTIFIER .)
    OR              reduce using rule 68 (identifier -> IDENTIFIER .)
    RBRACKET_S      reduce using rule 68 (identifier -> IDENTIFIER .)
    LBRACKET        reduce using rule 68 (identifier -> IDENTIFIER .)
    IF              reduce using rule 68 (identifier -> IDENTIFIER .)
    WHILE           reduce using rule 68 (identifier -> IDENTIFIER .)
    RETURN          reduce using rule 68 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 68 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 68 (identifier -> IDENTIFIER .)
    INTEGER         reduce using rule 68 (identifier -> IDENTIFIER .)
    FLOAT           reduce using rule 68 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 68 (identifier -> IDENTIFIER .)
    BOOL            reduce using rule 68 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 68 (identifier -> IDENTIFIER .)
    $end            reduce using rule 68 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 68 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 68 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 68 (identifier -> IDENTIFIER .)


state 8

    (1) definition_sequence -> definition definition_sequence .

    $end            reduce using rule 1 (definition_sequence -> definition definition_sequence .)


state 9

    (7) function_declaration -> function_heading body .

    IDENTIFIER      reduce using rule 7 (function_declaration -> function_heading body .)
    $end            reduce using rule 7 (function_declaration -> function_heading body .)


state 10

    (26) body -> statement .

    IDENTIFIER      reduce using rule 26 (body -> statement .)
    $end            reduce using rule 26 (body -> statement .)
    ELSE            reduce using rule 26 (body -> statement .)
    LBRACKET        reduce using rule 26 (body -> statement .)
    IF              reduce using rule 26 (body -> statement .)
    WHILE           reduce using rule 26 (body -> statement .)
    RETURN          reduce using rule 26 (body -> statement .)
    LPAREN          reduce using rule 26 (body -> statement .)
    NOT             reduce using rule 26 (body -> statement .)
    INTEGER         reduce using rule 26 (body -> statement .)
    FLOAT           reduce using rule 26 (body -> statement .)
    STRING          reduce using rule 26 (body -> statement .)
    BOOL            reduce using rule 26 (body -> statement .)
    LBRACKET_S      reduce using rule 26 (body -> statement .)
    RBRACKET        reduce using rule 26 (body -> statement .)


state 11

    (17) statement -> statement_part .

    IDENTIFIER      reduce using rule 17 (statement -> statement_part .)
    $end            reduce using rule 17 (statement -> statement_part .)
    LBRACKET        reduce using rule 17 (statement -> statement_part .)
    IF              reduce using rule 17 (statement -> statement_part .)
    WHILE           reduce using rule 17 (statement -> statement_part .)
    RETURN          reduce using rule 17 (statement -> statement_part .)
    LPAREN          reduce using rule 17 (statement -> statement_part .)
    NOT             reduce using rule 17 (statement -> statement_part .)
    INTEGER         reduce using rule 17 (statement -> statement_part .)
    FLOAT           reduce using rule 17 (statement -> statement_part .)
    STRING          reduce using rule 17 (statement -> statement_part .)
    BOOL            reduce using rule 17 (statement -> statement_part .)
    LBRACKET_S      reduce using rule 17 (statement -> statement_part .)
    RBRACKET        reduce using rule 17 (statement -> statement_part .)
    ELSE            reduce using rule 17 (statement -> statement_part .)


state 12

    (18) statement -> local_variable_declaration .

    IDENTIFIER      reduce using rule 18 (statement -> local_variable_declaration .)
    $end            reduce using rule 18 (statement -> local_variable_declaration .)
    LBRACKET        reduce using rule 18 (statement -> local_variable_declaration .)
    IF              reduce using rule 18 (statement -> local_variable_declaration .)
    WHILE           reduce using rule 18 (statement -> local_variable_declaration .)
    RETURN          reduce using rule 18 (statement -> local_variable_declaration .)
    LPAREN          reduce using rule 18 (statement -> local_variable_declaration .)
    NOT             reduce using rule 18 (statement -> local_variable_declaration .)
    INTEGER         reduce using rule 18 (statement -> local_variable_declaration .)
    FLOAT           reduce using rule 18 (statement -> local_variable_declaration .)
    STRING          reduce using rule 18 (statement -> local_variable_declaration .)
    BOOL            reduce using rule 18 (statement -> local_variable_declaration .)
    LBRACKET_S      reduce using rule 18 (statement -> local_variable_declaration .)
    RBRACKET        reduce using rule 18 (statement -> local_variable_declaration .)
    ELSE            reduce using rule 18 (statement -> local_variable_declaration .)


state 13

    (19) statement -> assignment_statement .

    IDENTIFIER      reduce using rule 19 (statement -> assignment_statement .)
    $end            reduce using rule 19 (statement -> assignment_statement .)
    LBRACKET        reduce using rule 19 (statement -> assignment_statement .)
    IF              reduce using rule 19 (statement -> assignment_statement .)
    WHILE           reduce using rule 19 (statement -> assignment_statement .)
    RETURN          reduce using rule 19 (statement -> assignment_statement .)
    LPAREN          reduce using rule 19 (statement -> assignment_statement .)
    NOT             reduce using rule 19 (statement -> assignment_statement .)
    INTEGER         reduce using rule 19 (statement -> assignment_statement .)
    FLOAT           reduce using rule 19 (statement -> assignment_statement .)
    STRING          reduce using rule 19 (statement -> assignment_statement .)
    BOOL            reduce using rule 19 (statement -> assignment_statement .)
    LBRACKET_S      reduce using rule 19 (statement -> assignment_statement .)
    RBRACKET        reduce using rule 19 (statement -> assignment_statement .)
    ELSE            reduce using rule 19 (statement -> assignment_statement .)


state 14

    (20) statement -> array_def .

    IDENTIFIER      reduce using rule 20 (statement -> array_def .)
    $end            reduce using rule 20 (statement -> array_def .)
    LBRACKET        reduce using rule 20 (statement -> array_def .)
    IF              reduce using rule 20 (statement -> array_def .)
    WHILE           reduce using rule 20 (statement -> array_def .)
    RETURN          reduce using rule 20 (statement -> array_def .)
    LPAREN          reduce using rule 20 (statement -> array_def .)
    NOT             reduce using rule 20 (statement -> array_def .)
    INTEGER         reduce using rule 20 (statement -> array_def .)
    FLOAT           reduce using rule 20 (statement -> array_def .)
    STRING          reduce using rule 20 (statement -> array_def .)
    BOOL            reduce using rule 20 (statement -> array_def .)
    LBRACKET_S      reduce using rule 20 (statement -> array_def .)
    RBRACKET        reduce using rule 20 (statement -> array_def .)
    ELSE            reduce using rule 20 (statement -> array_def .)


state 15

    (21) statement -> if_statement .

    IDENTIFIER      reduce using rule 21 (statement -> if_statement .)
    $end            reduce using rule 21 (statement -> if_statement .)
    LBRACKET        reduce using rule 21 (statement -> if_statement .)
    IF              reduce using rule 21 (statement -> if_statement .)
    WHILE           reduce using rule 21 (statement -> if_statement .)
    RETURN          reduce using rule 21 (statement -> if_statement .)
    LPAREN          reduce using rule 21 (statement -> if_statement .)
    NOT             reduce using rule 21 (statement -> if_statement .)
    INTEGER         reduce using rule 21 (statement -> if_statement .)
    FLOAT           reduce using rule 21 (statement -> if_statement .)
    STRING          reduce using rule 21 (statement -> if_statement .)
    BOOL            reduce using rule 21 (statement -> if_statement .)
    LBRACKET_S      reduce using rule 21 (statement -> if_statement .)
    RBRACKET        reduce using rule 21 (statement -> if_statement .)
    ELSE            reduce using rule 21 (statement -> if_statement .)


state 16

    (22) statement -> while_statement .

    IDENTIFIER      reduce using rule 22 (statement -> while_statement .)
    $end            reduce using rule 22 (statement -> while_statement .)
    LBRACKET        reduce using rule 22 (statement -> while_statement .)
    IF              reduce using rule 22 (statement -> while_statement .)
    WHILE           reduce using rule 22 (statement -> while_statement .)
    RETURN          reduce using rule 22 (statement -> while_statement .)
    LPAREN          reduce using rule 22 (statement -> while_statement .)
    NOT             reduce using rule 22 (statement -> while_statement .)
    INTEGER         reduce using rule 22 (statement -> while_statement .)
    FLOAT           reduce using rule 22 (statement -> while_statement .)
    STRING          reduce using rule 22 (statement -> while_statement .)
    BOOL            reduce using rule 22 (statement -> while_statement .)
    LBRACKET_S      reduce using rule 22 (statement -> while_statement .)
    RBRACKET        reduce using rule 22 (statement -> while_statement .)
    ELSE            reduce using rule 22 (statement -> while_statement .)


state 17

    (23) statement -> return_statement .

    IDENTIFIER      reduce using rule 23 (statement -> return_statement .)
    $end            reduce using rule 23 (statement -> return_statement .)
    LBRACKET        reduce using rule 23 (statement -> return_statement .)
    IF              reduce using rule 23 (statement -> return_statement .)
    WHILE           reduce using rule 23 (statement -> return_statement .)
    RETURN          reduce using rule 23 (statement -> return_statement .)
    LPAREN          reduce using rule 23 (statement -> return_statement .)
    NOT             reduce using rule 23 (statement -> return_statement .)
    INTEGER         reduce using rule 23 (statement -> return_statement .)
    FLOAT           reduce using rule 23 (statement -> return_statement .)
    STRING          reduce using rule 23 (statement -> return_statement .)
    BOOL            reduce using rule 23 (statement -> return_statement .)
    LBRACKET_S      reduce using rule 23 (statement -> return_statement .)
    RBRACKET        reduce using rule 23 (statement -> return_statement .)
    ELSE            reduce using rule 23 (statement -> return_statement .)


state 18

    (24) statement -> expression . SEMICOLON
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    SEMICOLON       shift and go to state 41
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 19

    (14) statement_part -> LBRACKET . statement_sequence RBRACKET
    (15) statement_sequence -> . statement statement_sequence
    (16) statement_sequence -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON type SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (68) identifier -> . IDENTIFIER
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    statement_sequence             shift and go to state 45
    statement                      shift and go to state 46
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    expression                     shift and go to state 18
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 20

    (31) local_variable_declaration -> identifier . COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> identifier . ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> identifier . LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> identifier . COLON type SEMICOLON
    (56) expression_e -> identifier .
    (66) function_call -> identifier . LPAREN param_list RPAREN
    (67) array_call -> identifier . LBRACKET_S expression RBRACKET_S

    COLON           shift and go to state 47
    ASSIGNMENT      shift and go to state 48
    LBRACKET_S      shift and go to state 49
    TIMES           reduce using rule 56 (expression_e -> identifier .)
    DIV             reduce using rule 56 (expression_e -> identifier .)
    PLUS            reduce using rule 56 (expression_e -> identifier .)
    MINUS           reduce using rule 56 (expression_e -> identifier .)
    MOD             reduce using rule 56 (expression_e -> identifier .)
    EQUAL           reduce using rule 56 (expression_e -> identifier .)
    NEQUAL          reduce using rule 56 (expression_e -> identifier .)
    LT              reduce using rule 56 (expression_e -> identifier .)
    LTE             reduce using rule 56 (expression_e -> identifier .)
    GT              reduce using rule 56 (expression_e -> identifier .)
    GTE             reduce using rule 56 (expression_e -> identifier .)
    SEMICOLON       reduce using rule 56 (expression_e -> identifier .)
    AND             reduce using rule 56 (expression_e -> identifier .)
    OR              reduce using rule 56 (expression_e -> identifier .)
    LPAREN          shift and go to state 50


state 21

    (73) array -> LBRACKET_S . expression RBRACKET_S
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 51
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 22

    (35) if_statement -> IF . expression body ELSE body
    (36) if_statement -> IF . expression body
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 53
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 23

    (37) while_statement -> WHILE . expression body
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 54
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 24

    (38) return_statement -> RETURN . expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 55
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 25

    (39) expression -> expression_m .
    (42) expression_m -> expression_m . sign expression_e
    (45) sign -> . TIMES
    (46) sign -> . DIV
    (47) sign -> . PLUS
    (48) sign -> . MINUS
    (49) sign -> . MOD
    (50) sign -> . EQUAL
    (51) sign -> . NEQUAL
    (52) sign -> . LT
    (53) sign -> . LTE
    (54) sign -> . GT
    (55) sign -> . GTE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
    SEMICOLON       reduce using rule 39 (expression -> expression_m .)
    AND             reduce using rule 39 (expression -> expression_m .)
    OR              reduce using rule 39 (expression -> expression_m .)
    RBRACKET_S      reduce using rule 39 (expression -> expression_m .)
    LBRACKET        reduce using rule 39 (expression -> expression_m .)
    IF              reduce using rule 39 (expression -> expression_m .)
    WHILE           reduce using rule 39 (expression -> expression_m .)
    RETURN          reduce using rule 39 (expression -> expression_m .)
    IDENTIFIER      reduce using rule 39 (expression -> expression_m .)
    LPAREN          reduce using rule 39 (expression -> expression_m .)
    NOT             reduce using rule 39 (expression -> expression_m .)
    INTEGER         reduce using rule 39 (expression -> expression_m .)
    FLOAT           reduce using rule 39 (expression -> expression_m .)
    STRING          reduce using rule 39 (expression -> expression_m .)
    BOOL            reduce using rule 39 (expression -> expression_m .)
    LBRACKET_S      reduce using rule 39 (expression -> expression_m .)
    ELSE            reduce using rule 39 (expression -> expression_m .)
    $end            reduce using rule 39 (expression -> expression_m .)
    RBRACKET        reduce using rule 39 (expression -> expression_m .)
    RPAREN          reduce using rule 39 (expression -> expression_m .)
    COMMA           reduce using rule 39 (expression -> expression_m .)
    TIMES           shift and go to state 57
    DIV             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    MOD             shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    LT              shift and go to state 64
    LTE             shift and go to state 65
    GT              shift and go to state 66
    GTE             shift and go to state 67

  ! TIMES           [ reduce using rule 39 (expression -> expression_m .) ]
  ! DIV             [ reduce using rule 39 (expression -> expression_m .) ]
  ! PLUS            [ reduce using rule 39 (expression -> expression_m .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression_m .) ]
  ! MOD             [ reduce using rule 39 (expression -> expression_m .) ]
  ! EQUAL           [ reduce using rule 39 (expression -> expression_m .) ]
  ! NEQUAL          [ reduce using rule 39 (expression -> expression_m .) ]
  ! LT              [ reduce using rule 39 (expression -> expression_m .) ]
  ! LTE             [ reduce using rule 39 (expression -> expression_m .) ]
  ! GT              [ reduce using rule 39 (expression -> expression_m .) ]
  ! GTE             [ reduce using rule 39 (expression -> expression_m .) ]

    sign                           shift and go to state 56

state 26

    (41) expression_m -> expression_e .

    TIMES           reduce using rule 41 (expression_m -> expression_e .)
    DIV             reduce using rule 41 (expression_m -> expression_e .)
    PLUS            reduce using rule 41 (expression_m -> expression_e .)
    MINUS           reduce using rule 41 (expression_m -> expression_e .)
    MOD             reduce using rule 41 (expression_m -> expression_e .)
    EQUAL           reduce using rule 41 (expression_m -> expression_e .)
    NEQUAL          reduce using rule 41 (expression_m -> expression_e .)
    LT              reduce using rule 41 (expression_m -> expression_e .)
    LTE             reduce using rule 41 (expression_m -> expression_e .)
    GT              reduce using rule 41 (expression_m -> expression_e .)
    GTE             reduce using rule 41 (expression_m -> expression_e .)
    SEMICOLON       reduce using rule 41 (expression_m -> expression_e .)
    AND             reduce using rule 41 (expression_m -> expression_e .)
    OR              reduce using rule 41 (expression_m -> expression_e .)
    RBRACKET_S      reduce using rule 41 (expression_m -> expression_e .)
    LBRACKET        reduce using rule 41 (expression_m -> expression_e .)
    IF              reduce using rule 41 (expression_m -> expression_e .)
    WHILE           reduce using rule 41 (expression_m -> expression_e .)
    RETURN          reduce using rule 41 (expression_m -> expression_e .)
    IDENTIFIER      reduce using rule 41 (expression_m -> expression_e .)
    LPAREN          reduce using rule 41 (expression_m -> expression_e .)
    NOT             reduce using rule 41 (expression_m -> expression_e .)
    INTEGER         reduce using rule 41 (expression_m -> expression_e .)
    FLOAT           reduce using rule 41 (expression_m -> expression_e .)
    STRING          reduce using rule 41 (expression_m -> expression_e .)
    BOOL            reduce using rule 41 (expression_m -> expression_e .)
    LBRACKET_S      reduce using rule 41 (expression_m -> expression_e .)
    ELSE            reduce using rule 41 (expression_m -> expression_e .)
    $end            reduce using rule 41 (expression_m -> expression_e .)
    RBRACKET        reduce using rule 41 (expression_m -> expression_e .)
    RPAREN          reduce using rule 41 (expression_m -> expression_e .)
    COMMA           reduce using rule 41 (expression_m -> expression_e .)


state 27

    (57) expression_e -> integer .

    TIMES           reduce using rule 57 (expression_e -> integer .)
    DIV             reduce using rule 57 (expression_e -> integer .)
    PLUS            reduce using rule 57 (expression_e -> integer .)
    MINUS           reduce using rule 57 (expression_e -> integer .)
    MOD             reduce using rule 57 (expression_e -> integer .)
    EQUAL           reduce using rule 57 (expression_e -> integer .)
    NEQUAL          reduce using rule 57 (expression_e -> integer .)
    LT              reduce using rule 57 (expression_e -> integer .)
    LTE             reduce using rule 57 (expression_e -> integer .)
    GT              reduce using rule 57 (expression_e -> integer .)
    GTE             reduce using rule 57 (expression_e -> integer .)
    SEMICOLON       reduce using rule 57 (expression_e -> integer .)
    AND             reduce using rule 57 (expression_e -> integer .)
    OR              reduce using rule 57 (expression_e -> integer .)
    RBRACKET_S      reduce using rule 57 (expression_e -> integer .)
    LBRACKET        reduce using rule 57 (expression_e -> integer .)
    IF              reduce using rule 57 (expression_e -> integer .)
    WHILE           reduce using rule 57 (expression_e -> integer .)
    RETURN          reduce using rule 57 (expression_e -> integer .)
    IDENTIFIER      reduce using rule 57 (expression_e -> integer .)
    LPAREN          reduce using rule 57 (expression_e -> integer .)
    NOT             reduce using rule 57 (expression_e -> integer .)
    INTEGER         reduce using rule 57 (expression_e -> integer .)
    FLOAT           reduce using rule 57 (expression_e -> integer .)
    STRING          reduce using rule 57 (expression_e -> integer .)
    BOOL            reduce using rule 57 (expression_e -> integer .)
    LBRACKET_S      reduce using rule 57 (expression_e -> integer .)
    ELSE            reduce using rule 57 (expression_e -> integer .)
    $end            reduce using rule 57 (expression_e -> integer .)
    RBRACKET        reduce using rule 57 (expression_e -> integer .)
    RPAREN          reduce using rule 57 (expression_e -> integer .)
    COMMA           reduce using rule 57 (expression_e -> integer .)


state 28

    (58) expression_e -> float .

    TIMES           reduce using rule 58 (expression_e -> float .)
    DIV             reduce using rule 58 (expression_e -> float .)
    PLUS            reduce using rule 58 (expression_e -> float .)
    MINUS           reduce using rule 58 (expression_e -> float .)
    MOD             reduce using rule 58 (expression_e -> float .)
    EQUAL           reduce using rule 58 (expression_e -> float .)
    NEQUAL          reduce using rule 58 (expression_e -> float .)
    LT              reduce using rule 58 (expression_e -> float .)
    LTE             reduce using rule 58 (expression_e -> float .)
    GT              reduce using rule 58 (expression_e -> float .)
    GTE             reduce using rule 58 (expression_e -> float .)
    SEMICOLON       reduce using rule 58 (expression_e -> float .)
    AND             reduce using rule 58 (expression_e -> float .)
    OR              reduce using rule 58 (expression_e -> float .)
    RBRACKET_S      reduce using rule 58 (expression_e -> float .)
    LBRACKET        reduce using rule 58 (expression_e -> float .)
    IF              reduce using rule 58 (expression_e -> float .)
    WHILE           reduce using rule 58 (expression_e -> float .)
    RETURN          reduce using rule 58 (expression_e -> float .)
    IDENTIFIER      reduce using rule 58 (expression_e -> float .)
    LPAREN          reduce using rule 58 (expression_e -> float .)
    NOT             reduce using rule 58 (expression_e -> float .)
    INTEGER         reduce using rule 58 (expression_e -> float .)
    FLOAT           reduce using rule 58 (expression_e -> float .)
    STRING          reduce using rule 58 (expression_e -> float .)
    BOOL            reduce using rule 58 (expression_e -> float .)
    LBRACKET_S      reduce using rule 58 (expression_e -> float .)
    ELSE            reduce using rule 58 (expression_e -> float .)
    $end            reduce using rule 58 (expression_e -> float .)
    RBRACKET        reduce using rule 58 (expression_e -> float .)
    RPAREN          reduce using rule 58 (expression_e -> float .)
    COMMA           reduce using rule 58 (expression_e -> float .)


state 29

    (59) expression_e -> string .

    TIMES           reduce using rule 59 (expression_e -> string .)
    DIV             reduce using rule 59 (expression_e -> string .)
    PLUS            reduce using rule 59 (expression_e -> string .)
    MINUS           reduce using rule 59 (expression_e -> string .)
    MOD             reduce using rule 59 (expression_e -> string .)
    EQUAL           reduce using rule 59 (expression_e -> string .)
    NEQUAL          reduce using rule 59 (expression_e -> string .)
    LT              reduce using rule 59 (expression_e -> string .)
    LTE             reduce using rule 59 (expression_e -> string .)
    GT              reduce using rule 59 (expression_e -> string .)
    GTE             reduce using rule 59 (expression_e -> string .)
    SEMICOLON       reduce using rule 59 (expression_e -> string .)
    AND             reduce using rule 59 (expression_e -> string .)
    OR              reduce using rule 59 (expression_e -> string .)
    RBRACKET_S      reduce using rule 59 (expression_e -> string .)
    LBRACKET        reduce using rule 59 (expression_e -> string .)
    IF              reduce using rule 59 (expression_e -> string .)
    WHILE           reduce using rule 59 (expression_e -> string .)
    RETURN          reduce using rule 59 (expression_e -> string .)
    IDENTIFIER      reduce using rule 59 (expression_e -> string .)
    LPAREN          reduce using rule 59 (expression_e -> string .)
    NOT             reduce using rule 59 (expression_e -> string .)
    INTEGER         reduce using rule 59 (expression_e -> string .)
    FLOAT           reduce using rule 59 (expression_e -> string .)
    STRING          reduce using rule 59 (expression_e -> string .)
    BOOL            reduce using rule 59 (expression_e -> string .)
    LBRACKET_S      reduce using rule 59 (expression_e -> string .)
    ELSE            reduce using rule 59 (expression_e -> string .)
    $end            reduce using rule 59 (expression_e -> string .)
    RBRACKET        reduce using rule 59 (expression_e -> string .)
    RPAREN          reduce using rule 59 (expression_e -> string .)
    COMMA           reduce using rule 59 (expression_e -> string .)


state 30

    (60) expression_e -> bool .

    TIMES           reduce using rule 60 (expression_e -> bool .)
    DIV             reduce using rule 60 (expression_e -> bool .)
    PLUS            reduce using rule 60 (expression_e -> bool .)
    MINUS           reduce using rule 60 (expression_e -> bool .)
    MOD             reduce using rule 60 (expression_e -> bool .)
    EQUAL           reduce using rule 60 (expression_e -> bool .)
    NEQUAL          reduce using rule 60 (expression_e -> bool .)
    LT              reduce using rule 60 (expression_e -> bool .)
    LTE             reduce using rule 60 (expression_e -> bool .)
    GT              reduce using rule 60 (expression_e -> bool .)
    GTE             reduce using rule 60 (expression_e -> bool .)
    SEMICOLON       reduce using rule 60 (expression_e -> bool .)
    AND             reduce using rule 60 (expression_e -> bool .)
    OR              reduce using rule 60 (expression_e -> bool .)
    RBRACKET_S      reduce using rule 60 (expression_e -> bool .)
    LBRACKET        reduce using rule 60 (expression_e -> bool .)
    IF              reduce using rule 60 (expression_e -> bool .)
    WHILE           reduce using rule 60 (expression_e -> bool .)
    RETURN          reduce using rule 60 (expression_e -> bool .)
    IDENTIFIER      reduce using rule 60 (expression_e -> bool .)
    LPAREN          reduce using rule 60 (expression_e -> bool .)
    NOT             reduce using rule 60 (expression_e -> bool .)
    INTEGER         reduce using rule 60 (expression_e -> bool .)
    FLOAT           reduce using rule 60 (expression_e -> bool .)
    STRING          reduce using rule 60 (expression_e -> bool .)
    BOOL            reduce using rule 60 (expression_e -> bool .)
    LBRACKET_S      reduce using rule 60 (expression_e -> bool .)
    ELSE            reduce using rule 60 (expression_e -> bool .)
    $end            reduce using rule 60 (expression_e -> bool .)
    RBRACKET        reduce using rule 60 (expression_e -> bool .)
    RPAREN          reduce using rule 60 (expression_e -> bool .)
    COMMA           reduce using rule 60 (expression_e -> bool .)


state 31

    (61) expression_e -> array .

    TIMES           reduce using rule 61 (expression_e -> array .)
    DIV             reduce using rule 61 (expression_e -> array .)
    PLUS            reduce using rule 61 (expression_e -> array .)
    MINUS           reduce using rule 61 (expression_e -> array .)
    MOD             reduce using rule 61 (expression_e -> array .)
    EQUAL           reduce using rule 61 (expression_e -> array .)
    NEQUAL          reduce using rule 61 (expression_e -> array .)
    LT              reduce using rule 61 (expression_e -> array .)
    LTE             reduce using rule 61 (expression_e -> array .)
    GT              reduce using rule 61 (expression_e -> array .)
    GTE             reduce using rule 61 (expression_e -> array .)
    SEMICOLON       reduce using rule 61 (expression_e -> array .)
    AND             reduce using rule 61 (expression_e -> array .)
    OR              reduce using rule 61 (expression_e -> array .)
    RBRACKET_S      reduce using rule 61 (expression_e -> array .)
    LBRACKET        reduce using rule 61 (expression_e -> array .)
    IF              reduce using rule 61 (expression_e -> array .)
    WHILE           reduce using rule 61 (expression_e -> array .)
    RETURN          reduce using rule 61 (expression_e -> array .)
    IDENTIFIER      reduce using rule 61 (expression_e -> array .)
    LPAREN          reduce using rule 61 (expression_e -> array .)
    NOT             reduce using rule 61 (expression_e -> array .)
    INTEGER         reduce using rule 61 (expression_e -> array .)
    FLOAT           reduce using rule 61 (expression_e -> array .)
    STRING          reduce using rule 61 (expression_e -> array .)
    BOOL            reduce using rule 61 (expression_e -> array .)
    LBRACKET_S      reduce using rule 61 (expression_e -> array .)
    ELSE            reduce using rule 61 (expression_e -> array .)
    $end            reduce using rule 61 (expression_e -> array .)
    RBRACKET        reduce using rule 61 (expression_e -> array .)
    RPAREN          reduce using rule 61 (expression_e -> array .)
    COMMA           reduce using rule 61 (expression_e -> array .)


state 32

    (62) expression_e -> LPAREN . expression RPAREN
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 68
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 33

    (63) expression_e -> NOT . expression
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 69
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 34

    (64) expression_e -> function_call .

    TIMES           reduce using rule 64 (expression_e -> function_call .)
    DIV             reduce using rule 64 (expression_e -> function_call .)
    PLUS            reduce using rule 64 (expression_e -> function_call .)
    MINUS           reduce using rule 64 (expression_e -> function_call .)
    MOD             reduce using rule 64 (expression_e -> function_call .)
    EQUAL           reduce using rule 64 (expression_e -> function_call .)
    NEQUAL          reduce using rule 64 (expression_e -> function_call .)
    LT              reduce using rule 64 (expression_e -> function_call .)
    LTE             reduce using rule 64 (expression_e -> function_call .)
    GT              reduce using rule 64 (expression_e -> function_call .)
    GTE             reduce using rule 64 (expression_e -> function_call .)
    SEMICOLON       reduce using rule 64 (expression_e -> function_call .)
    AND             reduce using rule 64 (expression_e -> function_call .)
    OR              reduce using rule 64 (expression_e -> function_call .)
    RBRACKET_S      reduce using rule 64 (expression_e -> function_call .)
    LBRACKET        reduce using rule 64 (expression_e -> function_call .)
    IF              reduce using rule 64 (expression_e -> function_call .)
    WHILE           reduce using rule 64 (expression_e -> function_call .)
    RETURN          reduce using rule 64 (expression_e -> function_call .)
    IDENTIFIER      reduce using rule 64 (expression_e -> function_call .)
    LPAREN          reduce using rule 64 (expression_e -> function_call .)
    NOT             reduce using rule 64 (expression_e -> function_call .)
    INTEGER         reduce using rule 64 (expression_e -> function_call .)
    FLOAT           reduce using rule 64 (expression_e -> function_call .)
    STRING          reduce using rule 64 (expression_e -> function_call .)
    BOOL            reduce using rule 64 (expression_e -> function_call .)
    LBRACKET_S      reduce using rule 64 (expression_e -> function_call .)
    ELSE            reduce using rule 64 (expression_e -> function_call .)
    $end            reduce using rule 64 (expression_e -> function_call .)
    RBRACKET        reduce using rule 64 (expression_e -> function_call .)
    RPAREN          reduce using rule 64 (expression_e -> function_call .)
    COMMA           reduce using rule 64 (expression_e -> function_call .)


state 35

    (65) expression_e -> array_call .

    TIMES           reduce using rule 65 (expression_e -> array_call .)
    DIV             reduce using rule 65 (expression_e -> array_call .)
    PLUS            reduce using rule 65 (expression_e -> array_call .)
    MINUS           reduce using rule 65 (expression_e -> array_call .)
    MOD             reduce using rule 65 (expression_e -> array_call .)
    EQUAL           reduce using rule 65 (expression_e -> array_call .)
    NEQUAL          reduce using rule 65 (expression_e -> array_call .)
    LT              reduce using rule 65 (expression_e -> array_call .)
    LTE             reduce using rule 65 (expression_e -> array_call .)
    GT              reduce using rule 65 (expression_e -> array_call .)
    GTE             reduce using rule 65 (expression_e -> array_call .)
    SEMICOLON       reduce using rule 65 (expression_e -> array_call .)
    AND             reduce using rule 65 (expression_e -> array_call .)
    OR              reduce using rule 65 (expression_e -> array_call .)
    RBRACKET_S      reduce using rule 65 (expression_e -> array_call .)
    LBRACKET        reduce using rule 65 (expression_e -> array_call .)
    IF              reduce using rule 65 (expression_e -> array_call .)
    WHILE           reduce using rule 65 (expression_e -> array_call .)
    RETURN          reduce using rule 65 (expression_e -> array_call .)
    IDENTIFIER      reduce using rule 65 (expression_e -> array_call .)
    LPAREN          reduce using rule 65 (expression_e -> array_call .)
    NOT             reduce using rule 65 (expression_e -> array_call .)
    INTEGER         reduce using rule 65 (expression_e -> array_call .)
    FLOAT           reduce using rule 65 (expression_e -> array_call .)
    STRING          reduce using rule 65 (expression_e -> array_call .)
    BOOL            reduce using rule 65 (expression_e -> array_call .)
    LBRACKET_S      reduce using rule 65 (expression_e -> array_call .)
    ELSE            reduce using rule 65 (expression_e -> array_call .)
    $end            reduce using rule 65 (expression_e -> array_call .)
    RBRACKET        reduce using rule 65 (expression_e -> array_call .)
    RPAREN          reduce using rule 65 (expression_e -> array_call .)
    COMMA           reduce using rule 65 (expression_e -> array_call .)


state 36

    (69) integer -> INTEGER .

    TIMES           reduce using rule 69 (integer -> INTEGER .)
    DIV             reduce using rule 69 (integer -> INTEGER .)
    PLUS            reduce using rule 69 (integer -> INTEGER .)
    MINUS           reduce using rule 69 (integer -> INTEGER .)
    MOD             reduce using rule 69 (integer -> INTEGER .)
    EQUAL           reduce using rule 69 (integer -> INTEGER .)
    NEQUAL          reduce using rule 69 (integer -> INTEGER .)
    LT              reduce using rule 69 (integer -> INTEGER .)
    LTE             reduce using rule 69 (integer -> INTEGER .)
    GT              reduce using rule 69 (integer -> INTEGER .)
    GTE             reduce using rule 69 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 69 (integer -> INTEGER .)
    AND             reduce using rule 69 (integer -> INTEGER .)
    OR              reduce using rule 69 (integer -> INTEGER .)
    RBRACKET_S      reduce using rule 69 (integer -> INTEGER .)
    LBRACKET        reduce using rule 69 (integer -> INTEGER .)
    IF              reduce using rule 69 (integer -> INTEGER .)
    WHILE           reduce using rule 69 (integer -> INTEGER .)
    RETURN          reduce using rule 69 (integer -> INTEGER .)
    IDENTIFIER      reduce using rule 69 (integer -> INTEGER .)
    LPAREN          reduce using rule 69 (integer -> INTEGER .)
    NOT             reduce using rule 69 (integer -> INTEGER .)
    INTEGER         reduce using rule 69 (integer -> INTEGER .)
    FLOAT           reduce using rule 69 (integer -> INTEGER .)
    STRING          reduce using rule 69 (integer -> INTEGER .)
    BOOL            reduce using rule 69 (integer -> INTEGER .)
    LBRACKET_S      reduce using rule 69 (integer -> INTEGER .)
    ELSE            reduce using rule 69 (integer -> INTEGER .)
    $end            reduce using rule 69 (integer -> INTEGER .)
    RBRACKET        reduce using rule 69 (integer -> INTEGER .)
    RPAREN          reduce using rule 69 (integer -> INTEGER .)
    COMMA           reduce using rule 69 (integer -> INTEGER .)


state 37

    (70) float -> FLOAT .

    TIMES           reduce using rule 70 (float -> FLOAT .)
    DIV             reduce using rule 70 (float -> FLOAT .)
    PLUS            reduce using rule 70 (float -> FLOAT .)
    MINUS           reduce using rule 70 (float -> FLOAT .)
    MOD             reduce using rule 70 (float -> FLOAT .)
    EQUAL           reduce using rule 70 (float -> FLOAT .)
    NEQUAL          reduce using rule 70 (float -> FLOAT .)
    LT              reduce using rule 70 (float -> FLOAT .)
    LTE             reduce using rule 70 (float -> FLOAT .)
    GT              reduce using rule 70 (float -> FLOAT .)
    GTE             reduce using rule 70 (float -> FLOAT .)
    SEMICOLON       reduce using rule 70 (float -> FLOAT .)
    AND             reduce using rule 70 (float -> FLOAT .)
    OR              reduce using rule 70 (float -> FLOAT .)
    RBRACKET_S      reduce using rule 70 (float -> FLOAT .)
    LBRACKET        reduce using rule 70 (float -> FLOAT .)
    IF              reduce using rule 70 (float -> FLOAT .)
    WHILE           reduce using rule 70 (float -> FLOAT .)
    RETURN          reduce using rule 70 (float -> FLOAT .)
    IDENTIFIER      reduce using rule 70 (float -> FLOAT .)
    LPAREN          reduce using rule 70 (float -> FLOAT .)
    NOT             reduce using rule 70 (float -> FLOAT .)
    INTEGER         reduce using rule 70 (float -> FLOAT .)
    FLOAT           reduce using rule 70 (float -> FLOAT .)
    STRING          reduce using rule 70 (float -> FLOAT .)
    BOOL            reduce using rule 70 (float -> FLOAT .)
    LBRACKET_S      reduce using rule 70 (float -> FLOAT .)
    ELSE            reduce using rule 70 (float -> FLOAT .)
    $end            reduce using rule 70 (float -> FLOAT .)
    RBRACKET        reduce using rule 70 (float -> FLOAT .)
    RPAREN          reduce using rule 70 (float -> FLOAT .)
    COMMA           reduce using rule 70 (float -> FLOAT .)


state 38

    (71) string -> STRING .

    TIMES           reduce using rule 71 (string -> STRING .)
    DIV             reduce using rule 71 (string -> STRING .)
    PLUS            reduce using rule 71 (string -> STRING .)
    MINUS           reduce using rule 71 (string -> STRING .)
    MOD             reduce using rule 71 (string -> STRING .)
    EQUAL           reduce using rule 71 (string -> STRING .)
    NEQUAL          reduce using rule 71 (string -> STRING .)
    LT              reduce using rule 71 (string -> STRING .)
    LTE             reduce using rule 71 (string -> STRING .)
    GT              reduce using rule 71 (string -> STRING .)
    GTE             reduce using rule 71 (string -> STRING .)
    SEMICOLON       reduce using rule 71 (string -> STRING .)
    AND             reduce using rule 71 (string -> STRING .)
    OR              reduce using rule 71 (string -> STRING .)
    RBRACKET_S      reduce using rule 71 (string -> STRING .)
    LBRACKET        reduce using rule 71 (string -> STRING .)
    IF              reduce using rule 71 (string -> STRING .)
    WHILE           reduce using rule 71 (string -> STRING .)
    RETURN          reduce using rule 71 (string -> STRING .)
    IDENTIFIER      reduce using rule 71 (string -> STRING .)
    LPAREN          reduce using rule 71 (string -> STRING .)
    NOT             reduce using rule 71 (string -> STRING .)
    INTEGER         reduce using rule 71 (string -> STRING .)
    FLOAT           reduce using rule 71 (string -> STRING .)
    STRING          reduce using rule 71 (string -> STRING .)
    BOOL            reduce using rule 71 (string -> STRING .)
    LBRACKET_S      reduce using rule 71 (string -> STRING .)
    ELSE            reduce using rule 71 (string -> STRING .)
    $end            reduce using rule 71 (string -> STRING .)
    RBRACKET        reduce using rule 71 (string -> STRING .)
    RPAREN          reduce using rule 71 (string -> STRING .)
    COMMA           reduce using rule 71 (string -> STRING .)


state 39

    (72) bool -> BOOL .

    TIMES           reduce using rule 72 (bool -> BOOL .)
    DIV             reduce using rule 72 (bool -> BOOL .)
    PLUS            reduce using rule 72 (bool -> BOOL .)
    MINUS           reduce using rule 72 (bool -> BOOL .)
    MOD             reduce using rule 72 (bool -> BOOL .)
    EQUAL           reduce using rule 72 (bool -> BOOL .)
    NEQUAL          reduce using rule 72 (bool -> BOOL .)
    LT              reduce using rule 72 (bool -> BOOL .)
    LTE             reduce using rule 72 (bool -> BOOL .)
    GT              reduce using rule 72 (bool -> BOOL .)
    GTE             reduce using rule 72 (bool -> BOOL .)
    SEMICOLON       reduce using rule 72 (bool -> BOOL .)
    AND             reduce using rule 72 (bool -> BOOL .)
    OR              reduce using rule 72 (bool -> BOOL .)
    RBRACKET_S      reduce using rule 72 (bool -> BOOL .)
    LBRACKET        reduce using rule 72 (bool -> BOOL .)
    IF              reduce using rule 72 (bool -> BOOL .)
    WHILE           reduce using rule 72 (bool -> BOOL .)
    RETURN          reduce using rule 72 (bool -> BOOL .)
    IDENTIFIER      reduce using rule 72 (bool -> BOOL .)
    LPAREN          reduce using rule 72 (bool -> BOOL .)
    NOT             reduce using rule 72 (bool -> BOOL .)
    INTEGER         reduce using rule 72 (bool -> BOOL .)
    FLOAT           reduce using rule 72 (bool -> BOOL .)
    STRING          reduce using rule 72 (bool -> BOOL .)
    BOOL            reduce using rule 72 (bool -> BOOL .)
    LBRACKET_S      reduce using rule 72 (bool -> BOOL .)
    ELSE            reduce using rule 72 (bool -> BOOL .)
    $end            reduce using rule 72 (bool -> BOOL .)
    RBRACKET        reduce using rule 72 (bool -> BOOL .)
    RPAREN          reduce using rule 72 (bool -> BOOL .)
    COMMA           reduce using rule 72 (bool -> BOOL .)


state 40

    (8) function_declaration -> identifier COLON . type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON . type SEMICOLON
    (6) variable_declaration -> identifier COLON . type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier COLON . type LPAREN parameter_list RPAREN
    (74) type -> . TINTEGER
    (75) type -> . TFLOAT
    (76) type -> . TSTRING
    (77) type -> . TBOOL
    (78) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 70

state 41

    (24) statement -> expression SEMICOLON .

    IDENTIFIER      reduce using rule 24 (statement -> expression SEMICOLON .)
    $end            reduce using rule 24 (statement -> expression SEMICOLON .)
    LBRACKET        reduce using rule 24 (statement -> expression SEMICOLON .)
    IF              reduce using rule 24 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 24 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 24 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 24 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 24 (statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 24 (statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 24 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 24 (statement -> expression SEMICOLON .)
    BOOL            reduce using rule 24 (statement -> expression SEMICOLON .)
    LBRACKET_S      reduce using rule 24 (statement -> expression SEMICOLON .)
    RBRACKET        reduce using rule 24 (statement -> expression SEMICOLON .)
    ELSE            reduce using rule 24 (statement -> expression SEMICOLON .)


state 42

    (40) expression -> expression and_or . expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression_m                   shift and go to state 76
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 43

    (43) and_or -> AND .

    LPAREN          reduce using rule 43 (and_or -> AND .)
    NOT             reduce using rule 43 (and_or -> AND .)
    IDENTIFIER      reduce using rule 43 (and_or -> AND .)
    INTEGER         reduce using rule 43 (and_or -> AND .)
    FLOAT           reduce using rule 43 (and_or -> AND .)
    STRING          reduce using rule 43 (and_or -> AND .)
    BOOL            reduce using rule 43 (and_or -> AND .)
    LBRACKET_S      reduce using rule 43 (and_or -> AND .)


state 44

    (44) and_or -> OR .

    LPAREN          reduce using rule 44 (and_or -> OR .)
    NOT             reduce using rule 44 (and_or -> OR .)
    IDENTIFIER      reduce using rule 44 (and_or -> OR .)
    INTEGER         reduce using rule 44 (and_or -> OR .)
    FLOAT           reduce using rule 44 (and_or -> OR .)
    STRING          reduce using rule 44 (and_or -> OR .)
    BOOL            reduce using rule 44 (and_or -> OR .)
    LBRACKET_S      reduce using rule 44 (and_or -> OR .)


state 45

    (14) statement_part -> LBRACKET statement_sequence . RBRACKET

    RBRACKET        shift and go to state 77


state 46

    (15) statement_sequence -> statement . statement_sequence
    (16) statement_sequence -> statement .
    (15) statement_sequence -> . statement statement_sequence
    (16) statement_sequence -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON type SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (68) identifier -> . IDENTIFIER
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! reduce/reduce conflict for RBRACKET resolved using rule 16 (statement_sequence -> statement .)
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    RBRACKET        reduce using rule 16 (statement_sequence -> statement .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]
  ! RBRACKET        [ reduce using rule 25 (statement -> .) ]

    statement                      shift and go to state 46
    statement_sequence             shift and go to state 78
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    expression                     shift and go to state 18
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 47

    (31) local_variable_declaration -> identifier COLON . type ASSIGNMENT expression SEMICOLON
    (34) array_def -> identifier COLON . type SEMICOLON
    (74) type -> . TINTEGER
    (75) type -> . TFLOAT
    (76) type -> . TSTRING
    (77) type -> . TBOOL
    (78) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 79

state 48

    (32) assignment_statement -> identifier ASSIGNMENT . expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 80
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 49

    (33) assignment_statement -> identifier LBRACKET_S . expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (67) array_call -> identifier LBRACKET_S . expression RBRACKET_S
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 81
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 50

    (66) function_call -> identifier LPAREN . param_list RPAREN
    (27) param_list -> . param COMMA param_list
    (28) param_list -> . param
    (29) param_list -> .
    (30) param -> . expression
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    RPAREN          reduce using rule 29 (param_list -> .)
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    param_list                     shift and go to state 82
    param                          shift and go to state 83
    expression                     shift and go to state 84
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 51

    (73) array -> LBRACKET_S expression . RBRACKET_S
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    RBRACKET_S      shift and go to state 85
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 52

    (56) expression_e -> identifier .
    (66) function_call -> identifier . LPAREN param_list RPAREN
    (67) array_call -> identifier . LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    TIMES           reduce using rule 56 (expression_e -> identifier .)
    DIV             reduce using rule 56 (expression_e -> identifier .)
    PLUS            reduce using rule 56 (expression_e -> identifier .)
    MINUS           reduce using rule 56 (expression_e -> identifier .)
    MOD             reduce using rule 56 (expression_e -> identifier .)
    EQUAL           reduce using rule 56 (expression_e -> identifier .)
    NEQUAL          reduce using rule 56 (expression_e -> identifier .)
    LT              reduce using rule 56 (expression_e -> identifier .)
    LTE             reduce using rule 56 (expression_e -> identifier .)
    GT              reduce using rule 56 (expression_e -> identifier .)
    GTE             reduce using rule 56 (expression_e -> identifier .)
    RBRACKET_S      reduce using rule 56 (expression_e -> identifier .)
    AND             reduce using rule 56 (expression_e -> identifier .)
    OR              reduce using rule 56 (expression_e -> identifier .)
    LBRACKET        reduce using rule 56 (expression_e -> identifier .)
    IF              reduce using rule 56 (expression_e -> identifier .)
    WHILE           reduce using rule 56 (expression_e -> identifier .)
    RETURN          reduce using rule 56 (expression_e -> identifier .)
    IDENTIFIER      reduce using rule 56 (expression_e -> identifier .)
    NOT             reduce using rule 56 (expression_e -> identifier .)
    INTEGER         reduce using rule 56 (expression_e -> identifier .)
    FLOAT           reduce using rule 56 (expression_e -> identifier .)
    STRING          reduce using rule 56 (expression_e -> identifier .)
    BOOL            reduce using rule 56 (expression_e -> identifier .)
    ELSE            reduce using rule 56 (expression_e -> identifier .)
    $end            reduce using rule 56 (expression_e -> identifier .)
    RBRACKET        reduce using rule 56 (expression_e -> identifier .)
    SEMICOLON       reduce using rule 56 (expression_e -> identifier .)
    RPAREN          reduce using rule 56 (expression_e -> identifier .)
    COMMA           reduce using rule 56 (expression_e -> identifier .)
    LPAREN          shift and go to state 50
    LBRACKET_S      shift and go to state 86

  ! LPAREN          [ reduce using rule 56 (expression_e -> identifier .) ]
  ! LBRACKET_S      [ reduce using rule 56 (expression_e -> identifier .) ]


state 53

    (35) if_statement -> IF expression . body ELSE body
    (36) if_statement -> IF expression . body
    (40) expression -> expression . and_or expression_m
    (26) body -> . statement
    (43) and_or -> . AND
    (44) and_or -> . OR
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON type SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (68) identifier -> . IDENTIFIER
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    AND             shift and go to state 43
    OR              shift and go to state 44
    ELSE            reduce using rule 25 (statement -> .)
    $end            reduce using rule 25 (statement -> .)
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    expression                     shift and go to state 18
    body                           shift and go to state 87
    and_or                         shift and go to state 42
    expression_m                   shift and go to state 25
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    identifier                     shift and go to state 20
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 54

    (37) while_statement -> WHILE expression . body
    (40) expression -> expression . and_or expression_m
    (26) body -> . statement
    (43) and_or -> . AND
    (44) and_or -> . OR
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON type SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (68) identifier -> . IDENTIFIER
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    AND             shift and go to state 43
    OR              shift and go to state 44
    ELSE            reduce using rule 25 (statement -> .)
    $end            reduce using rule 25 (statement -> .)
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    expression                     shift and go to state 18
    body                           shift and go to state 88
    and_or                         shift and go to state 42
    expression_m                   shift and go to state 25
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    identifier                     shift and go to state 20
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 55

    (38) return_statement -> RETURN expression . SEMICOLON
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    SEMICOLON       shift and go to state 89
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 56

    (42) expression_m -> expression_m sign . expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression_e                   shift and go to state 90
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 57

    (45) sign -> TIMES .

    LPAREN          reduce using rule 45 (sign -> TIMES .)
    NOT             reduce using rule 45 (sign -> TIMES .)
    IDENTIFIER      reduce using rule 45 (sign -> TIMES .)
    INTEGER         reduce using rule 45 (sign -> TIMES .)
    FLOAT           reduce using rule 45 (sign -> TIMES .)
    STRING          reduce using rule 45 (sign -> TIMES .)
    BOOL            reduce using rule 45 (sign -> TIMES .)
    LBRACKET_S      reduce using rule 45 (sign -> TIMES .)


state 58

    (46) sign -> DIV .

    LPAREN          reduce using rule 46 (sign -> DIV .)
    NOT             reduce using rule 46 (sign -> DIV .)
    IDENTIFIER      reduce using rule 46 (sign -> DIV .)
    INTEGER         reduce using rule 46 (sign -> DIV .)
    FLOAT           reduce using rule 46 (sign -> DIV .)
    STRING          reduce using rule 46 (sign -> DIV .)
    BOOL            reduce using rule 46 (sign -> DIV .)
    LBRACKET_S      reduce using rule 46 (sign -> DIV .)


state 59

    (47) sign -> PLUS .

    LPAREN          reduce using rule 47 (sign -> PLUS .)
    NOT             reduce using rule 47 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 47 (sign -> PLUS .)
    INTEGER         reduce using rule 47 (sign -> PLUS .)
    FLOAT           reduce using rule 47 (sign -> PLUS .)
    STRING          reduce using rule 47 (sign -> PLUS .)
    BOOL            reduce using rule 47 (sign -> PLUS .)
    LBRACKET_S      reduce using rule 47 (sign -> PLUS .)


state 60

    (48) sign -> MINUS .

    LPAREN          reduce using rule 48 (sign -> MINUS .)
    NOT             reduce using rule 48 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 48 (sign -> MINUS .)
    INTEGER         reduce using rule 48 (sign -> MINUS .)
    FLOAT           reduce using rule 48 (sign -> MINUS .)
    STRING          reduce using rule 48 (sign -> MINUS .)
    BOOL            reduce using rule 48 (sign -> MINUS .)
    LBRACKET_S      reduce using rule 48 (sign -> MINUS .)


state 61

    (49) sign -> MOD .

    LPAREN          reduce using rule 49 (sign -> MOD .)
    NOT             reduce using rule 49 (sign -> MOD .)
    IDENTIFIER      reduce using rule 49 (sign -> MOD .)
    INTEGER         reduce using rule 49 (sign -> MOD .)
    FLOAT           reduce using rule 49 (sign -> MOD .)
    STRING          reduce using rule 49 (sign -> MOD .)
    BOOL            reduce using rule 49 (sign -> MOD .)
    LBRACKET_S      reduce using rule 49 (sign -> MOD .)


state 62

    (50) sign -> EQUAL .

    LPAREN          reduce using rule 50 (sign -> EQUAL .)
    NOT             reduce using rule 50 (sign -> EQUAL .)
    IDENTIFIER      reduce using rule 50 (sign -> EQUAL .)
    INTEGER         reduce using rule 50 (sign -> EQUAL .)
    FLOAT           reduce using rule 50 (sign -> EQUAL .)
    STRING          reduce using rule 50 (sign -> EQUAL .)
    BOOL            reduce using rule 50 (sign -> EQUAL .)
    LBRACKET_S      reduce using rule 50 (sign -> EQUAL .)


state 63

    (51) sign -> NEQUAL .

    LPAREN          reduce using rule 51 (sign -> NEQUAL .)
    NOT             reduce using rule 51 (sign -> NEQUAL .)
    IDENTIFIER      reduce using rule 51 (sign -> NEQUAL .)
    INTEGER         reduce using rule 51 (sign -> NEQUAL .)
    FLOAT           reduce using rule 51 (sign -> NEQUAL .)
    STRING          reduce using rule 51 (sign -> NEQUAL .)
    BOOL            reduce using rule 51 (sign -> NEQUAL .)
    LBRACKET_S      reduce using rule 51 (sign -> NEQUAL .)


state 64

    (52) sign -> LT .

    LPAREN          reduce using rule 52 (sign -> LT .)
    NOT             reduce using rule 52 (sign -> LT .)
    IDENTIFIER      reduce using rule 52 (sign -> LT .)
    INTEGER         reduce using rule 52 (sign -> LT .)
    FLOAT           reduce using rule 52 (sign -> LT .)
    STRING          reduce using rule 52 (sign -> LT .)
    BOOL            reduce using rule 52 (sign -> LT .)
    LBRACKET_S      reduce using rule 52 (sign -> LT .)


state 65

    (53) sign -> LTE .

    LPAREN          reduce using rule 53 (sign -> LTE .)
    NOT             reduce using rule 53 (sign -> LTE .)
    IDENTIFIER      reduce using rule 53 (sign -> LTE .)
    INTEGER         reduce using rule 53 (sign -> LTE .)
    FLOAT           reduce using rule 53 (sign -> LTE .)
    STRING          reduce using rule 53 (sign -> LTE .)
    BOOL            reduce using rule 53 (sign -> LTE .)
    LBRACKET_S      reduce using rule 53 (sign -> LTE .)


state 66

    (54) sign -> GT .

    LPAREN          reduce using rule 54 (sign -> GT .)
    NOT             reduce using rule 54 (sign -> GT .)
    IDENTIFIER      reduce using rule 54 (sign -> GT .)
    INTEGER         reduce using rule 54 (sign -> GT .)
    FLOAT           reduce using rule 54 (sign -> GT .)
    STRING          reduce using rule 54 (sign -> GT .)
    BOOL            reduce using rule 54 (sign -> GT .)
    LBRACKET_S      reduce using rule 54 (sign -> GT .)


state 67

    (55) sign -> GTE .

    LPAREN          reduce using rule 55 (sign -> GTE .)
    NOT             reduce using rule 55 (sign -> GTE .)
    IDENTIFIER      reduce using rule 55 (sign -> GTE .)
    INTEGER         reduce using rule 55 (sign -> GTE .)
    FLOAT           reduce using rule 55 (sign -> GTE .)
    STRING          reduce using rule 55 (sign -> GTE .)
    BOOL            reduce using rule 55 (sign -> GTE .)
    LBRACKET_S      reduce using rule 55 (sign -> GTE .)


state 68

    (62) expression_e -> LPAREN expression . RPAREN
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    RPAREN          shift and go to state 91
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 69

    (63) expression_e -> NOT expression .
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    TIMES           reduce using rule 63 (expression_e -> NOT expression .)
    DIV             reduce using rule 63 (expression_e -> NOT expression .)
    PLUS            reduce using rule 63 (expression_e -> NOT expression .)
    MINUS           reduce using rule 63 (expression_e -> NOT expression .)
    MOD             reduce using rule 63 (expression_e -> NOT expression .)
    EQUAL           reduce using rule 63 (expression_e -> NOT expression .)
    NEQUAL          reduce using rule 63 (expression_e -> NOT expression .)
    LT              reduce using rule 63 (expression_e -> NOT expression .)
    LTE             reduce using rule 63 (expression_e -> NOT expression .)
    GT              reduce using rule 63 (expression_e -> NOT expression .)
    GTE             reduce using rule 63 (expression_e -> NOT expression .)
    SEMICOLON       reduce using rule 63 (expression_e -> NOT expression .)
    RBRACKET_S      reduce using rule 63 (expression_e -> NOT expression .)
    LBRACKET        reduce using rule 63 (expression_e -> NOT expression .)
    IF              reduce using rule 63 (expression_e -> NOT expression .)
    WHILE           reduce using rule 63 (expression_e -> NOT expression .)
    RETURN          reduce using rule 63 (expression_e -> NOT expression .)
    IDENTIFIER      reduce using rule 63 (expression_e -> NOT expression .)
    LPAREN          reduce using rule 63 (expression_e -> NOT expression .)
    NOT             reduce using rule 63 (expression_e -> NOT expression .)
    INTEGER         reduce using rule 63 (expression_e -> NOT expression .)
    FLOAT           reduce using rule 63 (expression_e -> NOT expression .)
    STRING          reduce using rule 63 (expression_e -> NOT expression .)
    BOOL            reduce using rule 63 (expression_e -> NOT expression .)
    LBRACKET_S      reduce using rule 63 (expression_e -> NOT expression .)
    ELSE            reduce using rule 63 (expression_e -> NOT expression .)
    $end            reduce using rule 63 (expression_e -> NOT expression .)
    RBRACKET        reduce using rule 63 (expression_e -> NOT expression .)
    RPAREN          reduce using rule 63 (expression_e -> NOT expression .)
    COMMA           reduce using rule 63 (expression_e -> NOT expression .)
    AND             shift and go to state 43
    OR              shift and go to state 44

  ! AND             [ reduce using rule 63 (expression_e -> NOT expression .) ]
  ! OR              [ reduce using rule 63 (expression_e -> NOT expression .) ]

    and_or                         shift and go to state 42

state 70

    (8) function_declaration -> identifier COLON type . LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON type . SEMICOLON
    (6) variable_declaration -> identifier COLON type . ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier COLON type . LPAREN parameter_list RPAREN

    LPAREN          shift and go to state 92
    SEMICOLON       shift and go to state 93
    ASSIGNMENT      shift and go to state 94


state 71

    (74) type -> TINTEGER .

    LPAREN          reduce using rule 74 (type -> TINTEGER .)
    SEMICOLON       reduce using rule 74 (type -> TINTEGER .)
    ASSIGNMENT      reduce using rule 74 (type -> TINTEGER .)
    RBRACKET_S      reduce using rule 74 (type -> TINTEGER .)
    COMMA           reduce using rule 74 (type -> TINTEGER .)
    RPAREN          reduce using rule 74 (type -> TINTEGER .)


state 72

    (75) type -> TFLOAT .

    LPAREN          reduce using rule 75 (type -> TFLOAT .)
    SEMICOLON       reduce using rule 75 (type -> TFLOAT .)
    ASSIGNMENT      reduce using rule 75 (type -> TFLOAT .)
    RBRACKET_S      reduce using rule 75 (type -> TFLOAT .)
    COMMA           reduce using rule 75 (type -> TFLOAT .)
    RPAREN          reduce using rule 75 (type -> TFLOAT .)


state 73

    (76) type -> TSTRING .

    LPAREN          reduce using rule 76 (type -> TSTRING .)
    SEMICOLON       reduce using rule 76 (type -> TSTRING .)
    ASSIGNMENT      reduce using rule 76 (type -> TSTRING .)
    RBRACKET_S      reduce using rule 76 (type -> TSTRING .)
    COMMA           reduce using rule 76 (type -> TSTRING .)
    RPAREN          reduce using rule 76 (type -> TSTRING .)


state 74

    (77) type -> TBOOL .

    LPAREN          reduce using rule 77 (type -> TBOOL .)
    SEMICOLON       reduce using rule 77 (type -> TBOOL .)
    ASSIGNMENT      reduce using rule 77 (type -> TBOOL .)
    RBRACKET_S      reduce using rule 77 (type -> TBOOL .)
    COMMA           reduce using rule 77 (type -> TBOOL .)
    RPAREN          reduce using rule 77 (type -> TBOOL .)


state 75

    (78) type -> LBRACKET_S . type RBRACKET_S
    (74) type -> . TINTEGER
    (75) type -> . TFLOAT
    (76) type -> . TSTRING
    (77) type -> . TBOOL
    (78) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 95

state 76

    (40) expression -> expression and_or expression_m .
    (42) expression_m -> expression_m . sign expression_e
    (45) sign -> . TIMES
    (46) sign -> . DIV
    (47) sign -> . PLUS
    (48) sign -> . MINUS
    (49) sign -> . MOD
    (50) sign -> . EQUAL
    (51) sign -> . NEQUAL
    (52) sign -> . LT
    (53) sign -> . LTE
    (54) sign -> . GT
    (55) sign -> . GTE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
    SEMICOLON       reduce using rule 40 (expression -> expression and_or expression_m .)
    AND             reduce using rule 40 (expression -> expression and_or expression_m .)
    OR              reduce using rule 40 (expression -> expression and_or expression_m .)
    RBRACKET_S      reduce using rule 40 (expression -> expression and_or expression_m .)
    LBRACKET        reduce using rule 40 (expression -> expression and_or expression_m .)
    IF              reduce using rule 40 (expression -> expression and_or expression_m .)
    WHILE           reduce using rule 40 (expression -> expression and_or expression_m .)
    RETURN          reduce using rule 40 (expression -> expression and_or expression_m .)
    IDENTIFIER      reduce using rule 40 (expression -> expression and_or expression_m .)
    LPAREN          reduce using rule 40 (expression -> expression and_or expression_m .)
    NOT             reduce using rule 40 (expression -> expression and_or expression_m .)
    INTEGER         reduce using rule 40 (expression -> expression and_or expression_m .)
    FLOAT           reduce using rule 40 (expression -> expression and_or expression_m .)
    STRING          reduce using rule 40 (expression -> expression and_or expression_m .)
    BOOL            reduce using rule 40 (expression -> expression and_or expression_m .)
    LBRACKET_S      reduce using rule 40 (expression -> expression and_or expression_m .)
    ELSE            reduce using rule 40 (expression -> expression and_or expression_m .)
    $end            reduce using rule 40 (expression -> expression and_or expression_m .)
    RBRACKET        reduce using rule 40 (expression -> expression and_or expression_m .)
    RPAREN          reduce using rule 40 (expression -> expression and_or expression_m .)
    COMMA           reduce using rule 40 (expression -> expression and_or expression_m .)
    TIMES           shift and go to state 57
    DIV             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    MOD             shift and go to state 61
    EQUAL           shift and go to state 62
    NEQUAL          shift and go to state 63
    LT              shift and go to state 64
    LTE             shift and go to state 65
    GT              shift and go to state 66
    GTE             shift and go to state 67

  ! TIMES           [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! DIV             [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! PLUS            [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! MOD             [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! EQUAL           [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! NEQUAL          [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! LT              [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! LTE             [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! GT              [ reduce using rule 40 (expression -> expression and_or expression_m .) ]
  ! GTE             [ reduce using rule 40 (expression -> expression and_or expression_m .) ]

    sign                           shift and go to state 56

state 77

    (14) statement_part -> LBRACKET statement_sequence RBRACKET .

    IDENTIFIER      reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    $end            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LBRACKET        reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    IF              reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    WHILE           reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RETURN          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LPAREN          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    NOT             reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    INTEGER         reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    FLOAT           reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    STRING          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    BOOL            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LBRACKET_S      reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RBRACKET        reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    ELSE            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)


state 78

    (15) statement_sequence -> statement statement_sequence .

    RBRACKET        reduce using rule 15 (statement_sequence -> statement statement_sequence .)


state 79

    (31) local_variable_declaration -> identifier COLON type . ASSIGNMENT expression SEMICOLON
    (34) array_def -> identifier COLON type . SEMICOLON

    ASSIGNMENT      shift and go to state 96
    SEMICOLON       shift and go to state 97


state 80

    (32) assignment_statement -> identifier ASSIGNMENT expression . SEMICOLON
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    SEMICOLON       shift and go to state 98
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 81

    (33) assignment_statement -> identifier LBRACKET_S expression . RBRACKET_S ASSIGNMENT expression SEMICOLON
    (67) array_call -> identifier LBRACKET_S expression . RBRACKET_S
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    RBRACKET_S      shift and go to state 99
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 82

    (66) function_call -> identifier LPAREN param_list . RPAREN

    RPAREN          shift and go to state 100


state 83

    (27) param_list -> param . COMMA param_list
    (28) param_list -> param .

    COMMA           shift and go to state 101
    RPAREN          reduce using rule 28 (param_list -> param .)


state 84

    (30) param -> expression .
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    COMMA           reduce using rule 30 (param -> expression .)
    RPAREN          reduce using rule 30 (param -> expression .)
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 85

    (73) array -> LBRACKET_S expression RBRACKET_S .

    TIMES           reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    RBRACKET_S      reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    LBRACKET        reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    IF              reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    WHILE           reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    RETURN          reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    IDENTIFIER      reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    LPAREN          reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    NOT             reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    INTEGER         reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    FLOAT           reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    STRING          reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    BOOL            reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    LBRACKET_S      reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    ELSE            reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    $end            reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    RBRACKET        reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    RPAREN          reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)
    COMMA           reduce using rule 73 (array -> LBRACKET_S expression RBRACKET_S .)


state 86

    (67) array_call -> identifier LBRACKET_S . expression RBRACKET_S
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 102
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 87

    (35) if_statement -> IF expression body . ELSE body
    (36) if_statement -> IF expression body .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 103
    IDENTIFIER      reduce using rule 36 (if_statement -> IF expression body .)
    $end            reduce using rule 36 (if_statement -> IF expression body .)
    LBRACKET        reduce using rule 36 (if_statement -> IF expression body .)
    IF              reduce using rule 36 (if_statement -> IF expression body .)
    WHILE           reduce using rule 36 (if_statement -> IF expression body .)
    RETURN          reduce using rule 36 (if_statement -> IF expression body .)
    LPAREN          reduce using rule 36 (if_statement -> IF expression body .)
    NOT             reduce using rule 36 (if_statement -> IF expression body .)
    INTEGER         reduce using rule 36 (if_statement -> IF expression body .)
    FLOAT           reduce using rule 36 (if_statement -> IF expression body .)
    STRING          reduce using rule 36 (if_statement -> IF expression body .)
    BOOL            reduce using rule 36 (if_statement -> IF expression body .)
    LBRACKET_S      reduce using rule 36 (if_statement -> IF expression body .)
    RBRACKET        reduce using rule 36 (if_statement -> IF expression body .)

  ! ELSE            [ reduce using rule 36 (if_statement -> IF expression body .) ]


state 88

    (37) while_statement -> WHILE expression body .

    IDENTIFIER      reduce using rule 37 (while_statement -> WHILE expression body .)
    $end            reduce using rule 37 (while_statement -> WHILE expression body .)
    LBRACKET        reduce using rule 37 (while_statement -> WHILE expression body .)
    IF              reduce using rule 37 (while_statement -> WHILE expression body .)
    WHILE           reduce using rule 37 (while_statement -> WHILE expression body .)
    RETURN          reduce using rule 37 (while_statement -> WHILE expression body .)
    LPAREN          reduce using rule 37 (while_statement -> WHILE expression body .)
    NOT             reduce using rule 37 (while_statement -> WHILE expression body .)
    INTEGER         reduce using rule 37 (while_statement -> WHILE expression body .)
    FLOAT           reduce using rule 37 (while_statement -> WHILE expression body .)
    STRING          reduce using rule 37 (while_statement -> WHILE expression body .)
    BOOL            reduce using rule 37 (while_statement -> WHILE expression body .)
    LBRACKET_S      reduce using rule 37 (while_statement -> WHILE expression body .)
    RBRACKET        reduce using rule 37 (while_statement -> WHILE expression body .)
    ELSE            reduce using rule 37 (while_statement -> WHILE expression body .)


state 89

    (38) return_statement -> RETURN expression SEMICOLON .

    IDENTIFIER      reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    LBRACKET        reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    BOOL            reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    LBRACKET_S      reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    RBRACKET        reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)


state 90

    (42) expression_m -> expression_m sign expression_e .

    TIMES           reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    DIV             reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    PLUS            reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    MINUS           reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    MOD             reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    EQUAL           reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    NEQUAL          reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    LT              reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    LTE             reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    GT              reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    GTE             reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    SEMICOLON       reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    AND             reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    OR              reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    RBRACKET_S      reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    LBRACKET        reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    IF              reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    WHILE           reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    RETURN          reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    IDENTIFIER      reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    LPAREN          reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    NOT             reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    INTEGER         reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    FLOAT           reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    STRING          reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    BOOL            reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    LBRACKET_S      reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    ELSE            reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    $end            reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    RBRACKET        reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    RPAREN          reduce using rule 42 (expression_m -> expression_m sign expression_e .)
    COMMA           reduce using rule 42 (expression_m -> expression_m sign expression_e .)


state 91

    (62) expression_e -> LPAREN expression RPAREN .

    TIMES           reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    DIV             reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    MOD             reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    NEQUAL          reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    LT              reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    LTE             reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    GT              reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    GTE             reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    AND             reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    OR              reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    RBRACKET_S      reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    IF              reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    NOT             reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    STRING          reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    BOOL            reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    LBRACKET_S      reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    $end            reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 62 (expression_e -> LPAREN expression RPAREN .)


state 92

    (8) function_declaration -> identifier COLON type LPAREN . parameter_list RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN . parameter_list RPAREN
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter_list -> .
    (13) parameter -> . identifier COLON type
    (68) identifier -> . IDENTIFIER

    RPAREN          reduce using rule 12 (parameter_list -> .)
    IDENTIFIER      shift and go to state 7

    identifier                     shift and go to state 104
    parameter_list                 shift and go to state 105
    parameter                      shift and go to state 106

state 93

    (5) variable_declaration -> identifier COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)
    $end            reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)


state 94

    (6) variable_declaration -> identifier COLON type ASSIGNMENT . expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 107
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 95

    (78) type -> LBRACKET_S type . RBRACKET_S

    RBRACKET_S      shift and go to state 108


state 96

    (31) local_variable_declaration -> identifier COLON type ASSIGNMENT . expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 109
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 97

    (34) array_def -> identifier COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    $end            reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    LBRACKET        reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    IF              reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    WHILE           reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    RETURN          reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    LPAREN          reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    NOT             reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    INTEGER         reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    FLOAT           reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    STRING          reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    BOOL            reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    LBRACKET_S      reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    RBRACKET        reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)
    ELSE            reduce using rule 34 (array_def -> identifier COLON type SEMICOLON .)


state 98

    (32) assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)


state 99

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S . ASSIGNMENT expression SEMICOLON
    (67) array_call -> identifier LBRACKET_S expression RBRACKET_S .

    ASSIGNMENT      shift and go to state 110
    TIMES           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)


state 100

    (66) function_call -> identifier LPAREN param_list RPAREN .

    TIMES           reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    DIV             reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    PLUS            reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    MINUS           reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    MOD             reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    EQUAL           reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    NEQUAL          reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    LT              reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    LTE             reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    GT              reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    GTE             reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    SEMICOLON       reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    AND             reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    OR              reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    RBRACKET_S      reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    LBRACKET        reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    IF              reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    WHILE           reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    RETURN          reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    IDENTIFIER      reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    LPAREN          reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    NOT             reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    INTEGER         reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    FLOAT           reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    STRING          reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    BOOL            reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    LBRACKET_S      reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    ELSE            reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    $end            reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    RBRACKET        reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    RPAREN          reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)
    COMMA           reduce using rule 66 (function_call -> identifier LPAREN param_list RPAREN .)


state 101

    (27) param_list -> param COMMA . param_list
    (27) param_list -> . param COMMA param_list
    (28) param_list -> . param
    (29) param_list -> .
    (30) param -> . expression
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    RPAREN          reduce using rule 29 (param_list -> .)
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    param                          shift and go to state 83
    param_list                     shift and go to state 111
    expression                     shift and go to state 84
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 102

    (67) array_call -> identifier LBRACKET_S expression . RBRACKET_S
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    RBRACKET_S      shift and go to state 112
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 103

    (35) if_statement -> IF expression body ELSE . body
    (26) body -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON type SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (68) identifier -> . IDENTIFIER
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    ELSE            reduce using rule 25 (statement -> .)
    $end            reduce using rule 25 (statement -> .)
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    expression                     shift and go to state 18
    body                           shift and go to state 113
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 104

    (13) parameter -> identifier . COLON type

    COLON           shift and go to state 114


state 105

    (8) function_declaration -> identifier COLON type LPAREN parameter_list . RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list . RPAREN

    RPAREN          shift and go to state 115


state 106

    (10) parameter_list -> parameter . COMMA parameter_list
    (11) parameter_list -> parameter .

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 11 (parameter_list -> parameter .)


state 107

    (6) variable_declaration -> identifier COLON type ASSIGNMENT expression . SEMICOLON
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    SEMICOLON       shift and go to state 117
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 108

    (78) type -> LBRACKET_S type RBRACKET_S .

    LPAREN          reduce using rule 78 (type -> LBRACKET_S type RBRACKET_S .)
    SEMICOLON       reduce using rule 78 (type -> LBRACKET_S type RBRACKET_S .)
    ASSIGNMENT      reduce using rule 78 (type -> LBRACKET_S type RBRACKET_S .)
    RBRACKET_S      reduce using rule 78 (type -> LBRACKET_S type RBRACKET_S .)
    COMMA           reduce using rule 78 (type -> LBRACKET_S type RBRACKET_S .)
    RPAREN          reduce using rule 78 (type -> LBRACKET_S type RBRACKET_S .)


state 109

    (31) local_variable_declaration -> identifier COLON type ASSIGNMENT expression . SEMICOLON
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    SEMICOLON       shift and go to state 118
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 110

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT . expression SEMICOLON
    (39) expression -> . expression_m
    (40) expression -> . expression and_or expression_m
    (41) expression_m -> . expression_e
    (42) expression_m -> . expression_m sign expression_e
    (56) expression_e -> . identifier
    (57) expression_e -> . integer
    (58) expression_e -> . float
    (59) expression_e -> . string
    (60) expression_e -> . bool
    (61) expression_e -> . array
    (62) expression_e -> . LPAREN expression RPAREN
    (63) expression_e -> . NOT expression
    (64) expression_e -> . function_call
    (65) expression_e -> . array_call
    (68) identifier -> . IDENTIFIER
    (69) integer -> . INTEGER
    (70) float -> . FLOAT
    (71) string -> . STRING
    (72) bool -> . BOOL
    (73) array -> . LBRACKET_S expression RBRACKET_S
    (66) function_call -> . identifier LPAREN param_list RPAREN
    (67) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 119
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 111

    (27) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 27 (param_list -> param COMMA param_list .)


state 112

    (67) array_call -> identifier LBRACKET_S expression RBRACKET_S .

    TIMES           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RBRACKET_S      reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LBRACKET        reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    IF              reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    WHILE           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RETURN          reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    IDENTIFIER      reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LPAREN          reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    NOT             reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    INTEGER         reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    FLOAT           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    STRING          reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    BOOL            reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LBRACKET_S      reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    ELSE            reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    $end            reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RBRACKET        reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RPAREN          reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    COMMA           reduce using rule 67 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)


state 113

    (35) if_statement -> IF expression body ELSE body .

    IDENTIFIER      reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    $end            reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    LBRACKET        reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    IF              reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    WHILE           reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    RETURN          reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    LPAREN          reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    NOT             reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    INTEGER         reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    FLOAT           reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    STRING          reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    BOOL            reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    LBRACKET_S      reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    RBRACKET        reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    ELSE            reduce using rule 35 (if_statement -> IF expression body ELSE body .)


state 114

    (13) parameter -> identifier COLON . type
    (74) type -> . TINTEGER
    (75) type -> . TFLOAT
    (76) type -> . TSTRING
    (77) type -> . TBOOL
    (78) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 120

state 115

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN . SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list RPAREN .

    SEMICOLON       shift and go to state 121
    LBRACKET        reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IF              reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    RETURN          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IDENTIFIER      reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    LPAREN          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    NOT             reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    INTEGER         reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    FLOAT           reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    STRING          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    BOOL            reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    LBRACKET_S      reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    $end            reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)


state 116

    (10) parameter_list -> parameter COMMA . parameter_list
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter_list -> .
    (13) parameter -> . identifier COLON type
    (68) identifier -> . IDENTIFIER

    RPAREN          reduce using rule 12 (parameter_list -> .)
    IDENTIFIER      shift and go to state 7

    parameter                      shift and go to state 106
    parameter_list                 shift and go to state 122
    identifier                     shift and go to state 104

state 117

    (6) variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)


state 118

    (31) local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)


state 119

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression . SEMICOLON
    (40) expression -> expression . and_or expression_m
    (43) and_or -> . AND
    (44) and_or -> . OR

    SEMICOLON       shift and go to state 123
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 120

    (13) parameter -> identifier COLON type .

    COMMA           reduce using rule 13 (parameter -> identifier COLON type .)
    RPAREN          reduce using rule 13 (parameter -> identifier COLON type .)


state 121

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)
    $end            reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)


state 122

    (10) parameter_list -> parameter COMMA parameter_list .

    RPAREN          reduce using rule 10 (parameter_list -> parameter COMMA parameter_list .)


state 123

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 5 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 19 resolved as shift
WARNING: shift/reduce conflict for IF in state 19 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 19 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 19 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 19 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 19 resolved as shift
WARNING: shift/reduce conflict for NOT in state 19 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 19 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 19 resolved as shift
WARNING: shift/reduce conflict for STRING in state 19 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 19 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 19 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 25 resolved as shift
WARNING: shift/reduce conflict for DIV in state 25 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 25 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 25 resolved as shift
WARNING: shift/reduce conflict for MOD in state 25 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 25 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 25 resolved as shift
WARNING: shift/reduce conflict for LT in state 25 resolved as shift
WARNING: shift/reduce conflict for LTE in state 25 resolved as shift
WARNING: shift/reduce conflict for GT in state 25 resolved as shift
WARNING: shift/reduce conflict for GTE in state 25 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 46 resolved as shift
WARNING: shift/reduce conflict for IF in state 46 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 46 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 46 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 46 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 46 resolved as shift
WARNING: shift/reduce conflict for NOT in state 46 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 46 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 46 resolved as shift
WARNING: shift/reduce conflict for STRING in state 46 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 46 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 46 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 52 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 52 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 53 resolved as shift
WARNING: shift/reduce conflict for IF in state 53 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 53 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 53 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 53 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 53 resolved as shift
WARNING: shift/reduce conflict for NOT in state 53 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 53 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 53 resolved as shift
WARNING: shift/reduce conflict for STRING in state 53 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 54 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 54 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 54 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 54 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 54 resolved as shift
WARNING: shift/reduce conflict for NOT in state 54 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 54 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 54 resolved as shift
WARNING: shift/reduce conflict for STRING in state 54 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 54 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 54 resolved as shift
WARNING: shift/reduce conflict for AND in state 69 resolved as shift
WARNING: shift/reduce conflict for OR in state 69 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 76 resolved as shift
WARNING: shift/reduce conflict for DIV in state 76 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MOD in state 76 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for LT in state 76 resolved as shift
WARNING: shift/reduce conflict for LTE in state 76 resolved as shift
WARNING: shift/reduce conflict for GT in state 76 resolved as shift
WARNING: shift/reduce conflict for GTE in state 76 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 87 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 103 resolved as shift
WARNING: shift/reduce conflict for IF in state 103 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 103 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 103 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 103 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 103 resolved as shift
WARNING: shift/reduce conflict for NOT in state 103 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 103 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 103 resolved as shift
WARNING: shift/reduce conflict for STRING in state 103 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 103 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 103 resolved as shift
WARNING: reduce/reduce conflict in state 46 resolved using rule (statement_sequence -> statement)
WARNING: rejected rule (statement -> <empty>) in state 46
