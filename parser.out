Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    COMMENT
    VOID

Grammar

Rule 0     S' -> definition_sequence
Rule 1     definition_sequence -> definition definition_sequence
Rule 2     definition_sequence -> definition
Rule 3     definition -> function_declaration
Rule 4     definition -> variable_declaration
Rule 5     variable_declaration -> identifier COLON type SEMICOLON
Rule 6     variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON
Rule 7     function_declaration -> function_heading body
Rule 8     function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
Rule 9     function_heading -> identifier COLON type LPAREN parameter_list RPAREN
Rule 10    parameter_list -> parameter COMMA parameter_list
Rule 11    parameter_list -> parameter
Rule 12    parameter_list -> <empty>
Rule 13    parameter -> identifier COLON type
Rule 14    statement_part -> LBRACKET statement_sequence RBRACKET
Rule 15    statement_sequence -> statement statement_sequence
Rule 16    statement_sequence -> statement
Rule 17    statement -> statement_part
Rule 18    statement -> local_variable_declaration
Rule 19    statement -> assignment_statement
Rule 20    statement -> array_def
Rule 21    statement -> if_statement
Rule 22    statement -> while_statement
Rule 23    statement -> return_statement
Rule 24    statement -> expression SEMICOLON
Rule 25    statement -> <empty>
Rule 26    body -> statement
Rule 27    param_list -> param COMMA param_list
Rule 28    param_list -> param
Rule 29    param_list -> <empty>
Rule 30    param -> expression
Rule 31    local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON
Rule 32    assignment_statement -> identifier ASSIGNMENT expression SEMICOLON
Rule 33    assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
Rule 34    array_def -> identifier COLON array_access SEMICOLON
Rule 35    if_statement -> IF expression body ELSE body
Rule 36    if_statement -> IF expression body
Rule 37    while_statement -> WHILE expression body
Rule 38    return_statement -> RETURN expression SEMICOLON
Rule 39    return_statement -> RETURN SEMICOLON
Rule 40    expression -> expression_m
Rule 41    expression -> expression and_or expression_m
Rule 42    expression_m -> expression_e
Rule 43    expression_m -> expression_m sign expression_e
Rule 44    and_or -> AND
Rule 45    and_or -> OR
Rule 46    sign -> TIMES
Rule 47    sign -> DIV
Rule 48    sign -> PLUS
Rule 49    sign -> MINUS
Rule 50    sign -> MOD
Rule 51    sign -> EQUAL
Rule 52    sign -> NEQUAL
Rule 53    sign -> LT
Rule 54    sign -> LTE
Rule 55    sign -> GT
Rule 56    sign -> GTE
Rule 57    expression_e -> identifier
Rule 58    expression_e -> integer
Rule 59    expression_e -> float
Rule 60    expression_e -> string
Rule 61    expression_e -> bool
Rule 62    expression_e -> array
Rule 63    expression_e -> LPAREN expression RPAREN
Rule 64    expression_e -> NOT expression
Rule 65    expression_e -> function_call
Rule 66    expression_e -> array_call
Rule 67    function_call -> identifier LPAREN param_list RPAREN
Rule 68    array_call -> identifier LBRACKET_S expression RBRACKET_S
Rule 69    identifier -> IDENTIFIER
Rule 70    integer -> INTEGER
Rule 71    float -> FLOAT
Rule 72    string -> STRING
Rule 73    bool -> BOOL
Rule 74    array -> LBRACKET_S expression RBRACKET_S
Rule 75    type -> TINTEGER
Rule 76    type -> TFLOAT
Rule 77    type -> TSTRING
Rule 78    type -> TBOOL
Rule 79    type -> TVOID
Rule 80    type -> LBRACKET_S type RBRACKET_S
Rule 81    array_access -> LBRACKET_S type RBRACKET_S

Terminals, with rules where they appear

AND                  : 44
ARRAY                : 
ASSIGNMENT           : 6 31 32 33
BOOL                 : 73
COLON                : 5 6 8 9 13 31 34
COMMA                : 10 27
COMMENT              : 
DIV                  : 47
ELSE                 : 35
EQUAL                : 51
FLOAT                : 71
GT                   : 55
GTE                  : 56
IDENTIFIER           : 69
IF                   : 35 36
INTEGER              : 70
LBRACKET             : 14
LBRACKET_S           : 33 68 74 80 81
LPAREN               : 8 9 63 67
LT                   : 53
LTE                  : 54
MINUS                : 49
MOD                  : 50
NEQUAL               : 52
NOT                  : 64
OR                   : 45
PLUS                 : 48
RBRACKET             : 14
RBRACKET_S           : 33 68 74 80 81
RETURN               : 38 39
RPAREN               : 8 9 63 67
SEMICOLON            : 5 6 8 24 31 32 33 34 38 39
STRING               : 72
TBOOL                : 78
TFLOAT               : 76
TIMES                : 46
TINTEGER             : 75
TSTRING              : 77
TVOID                : 79
VOID                 : 
WHILE                : 37
error                : 

Nonterminals, with rules where they appear

and_or               : 41
array                : 62
array_access         : 34
array_call           : 66
array_def            : 20
assignment_statement : 19
body                 : 7 35 35 36 37
bool                 : 61
definition           : 1 2
definition_sequence  : 1 0
expression           : 6 24 30 31 32 33 33 35 36 37 38 41 63 64 68 74
expression_e         : 42 43
expression_m         : 40 41 43
float                : 59
function_call        : 65
function_declaration : 3
function_heading     : 7
identifier           : 5 6 8 9 13 31 32 33 34 57 67 68
if_statement         : 21
integer              : 58
local_variable_declaration : 18
param                : 27 28
param_list           : 27 67
parameter            : 10 11
parameter_list       : 8 9 10
return_statement     : 23
sign                 : 43
statement            : 15 16 26
statement_part       : 17
statement_sequence   : 14 15
string               : 60
type                 : 5 6 8 9 13 31 80 81
variable_declaration : 4
while_statement      : 22

Parsing method: LALR

state 0

    (0) S' -> . definition_sequence
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (69) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 7

    definition_sequence            shift and go to state 1
    definition                     shift and go to state 2
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 1

    (0) S' -> definition_sequence .



state 2

    (1) definition_sequence -> definition . definition_sequence
    (2) definition_sequence -> definition .
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (69) identifier -> . IDENTIFIER

    $end            reduce using rule 2 (definition_sequence -> definition .)
    IDENTIFIER      shift and go to state 7

    definition                     shift and go to state 2
    definition_sequence            shift and go to state 8
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 3

    (3) definition -> function_declaration .

    IDENTIFIER      reduce using rule 3 (definition -> function_declaration .)
    $end            reduce using rule 3 (definition -> function_declaration .)


state 4

    (4) definition -> variable_declaration .

    IDENTIFIER      reduce using rule 4 (definition -> variable_declaration .)
    $end            reduce using rule 4 (definition -> variable_declaration .)


state 5

    (7) function_declaration -> function_heading . body
    (26) body -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON array_access SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) return_statement -> . RETURN SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (69) identifier -> . IDENTIFIER
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    $end            reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]

    body                           shift and go to state 9
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    expression                     shift and go to state 18
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 6

    (8) function_declaration -> identifier . COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier . COLON type SEMICOLON
    (6) variable_declaration -> identifier . COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier . COLON type LPAREN parameter_list RPAREN

    COLON           shift and go to state 40


state 7

    (69) identifier -> IDENTIFIER .

    COLON           reduce using rule 69 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 69 (identifier -> IDENTIFIER .)
    LBRACKET_S      reduce using rule 69 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 69 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 69 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 69 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 69 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 69 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 69 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 69 (identifier -> IDENTIFIER .)
    NEQUAL          reduce using rule 69 (identifier -> IDENTIFIER .)
    LT              reduce using rule 69 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 69 (identifier -> IDENTIFIER .)
    GT              reduce using rule 69 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 69 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 69 (identifier -> IDENTIFIER .)
    AND             reduce using rule 69 (identifier -> IDENTIFIER .)
    OR              reduce using rule 69 (identifier -> IDENTIFIER .)
    RBRACKET_S      reduce using rule 69 (identifier -> IDENTIFIER .)
    LBRACKET        reduce using rule 69 (identifier -> IDENTIFIER .)
    IF              reduce using rule 69 (identifier -> IDENTIFIER .)
    WHILE           reduce using rule 69 (identifier -> IDENTIFIER .)
    RETURN          reduce using rule 69 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 69 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 69 (identifier -> IDENTIFIER .)
    INTEGER         reduce using rule 69 (identifier -> IDENTIFIER .)
    FLOAT           reduce using rule 69 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 69 (identifier -> IDENTIFIER .)
    BOOL            reduce using rule 69 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 69 (identifier -> IDENTIFIER .)
    $end            reduce using rule 69 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 69 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 69 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 69 (identifier -> IDENTIFIER .)


state 8

    (1) definition_sequence -> definition definition_sequence .

    $end            reduce using rule 1 (definition_sequence -> definition definition_sequence .)


state 9

    (7) function_declaration -> function_heading body .

    IDENTIFIER      reduce using rule 7 (function_declaration -> function_heading body .)
    $end            reduce using rule 7 (function_declaration -> function_heading body .)


state 10

    (26) body -> statement .

    IDENTIFIER      reduce using rule 26 (body -> statement .)
    $end            reduce using rule 26 (body -> statement .)
    ELSE            reduce using rule 26 (body -> statement .)
    LBRACKET        reduce using rule 26 (body -> statement .)
    IF              reduce using rule 26 (body -> statement .)
    WHILE           reduce using rule 26 (body -> statement .)
    RETURN          reduce using rule 26 (body -> statement .)
    LPAREN          reduce using rule 26 (body -> statement .)
    NOT             reduce using rule 26 (body -> statement .)
    INTEGER         reduce using rule 26 (body -> statement .)
    FLOAT           reduce using rule 26 (body -> statement .)
    STRING          reduce using rule 26 (body -> statement .)
    BOOL            reduce using rule 26 (body -> statement .)
    LBRACKET_S      reduce using rule 26 (body -> statement .)
    RBRACKET        reduce using rule 26 (body -> statement .)


state 11

    (17) statement -> statement_part .

    IDENTIFIER      reduce using rule 17 (statement -> statement_part .)
    $end            reduce using rule 17 (statement -> statement_part .)
    LBRACKET        reduce using rule 17 (statement -> statement_part .)
    IF              reduce using rule 17 (statement -> statement_part .)
    WHILE           reduce using rule 17 (statement -> statement_part .)
    RETURN          reduce using rule 17 (statement -> statement_part .)
    LPAREN          reduce using rule 17 (statement -> statement_part .)
    NOT             reduce using rule 17 (statement -> statement_part .)
    INTEGER         reduce using rule 17 (statement -> statement_part .)
    FLOAT           reduce using rule 17 (statement -> statement_part .)
    STRING          reduce using rule 17 (statement -> statement_part .)
    BOOL            reduce using rule 17 (statement -> statement_part .)
    LBRACKET_S      reduce using rule 17 (statement -> statement_part .)
    RBRACKET        reduce using rule 17 (statement -> statement_part .)
    ELSE            reduce using rule 17 (statement -> statement_part .)


state 12

    (18) statement -> local_variable_declaration .

    IDENTIFIER      reduce using rule 18 (statement -> local_variable_declaration .)
    $end            reduce using rule 18 (statement -> local_variable_declaration .)
    LBRACKET        reduce using rule 18 (statement -> local_variable_declaration .)
    IF              reduce using rule 18 (statement -> local_variable_declaration .)
    WHILE           reduce using rule 18 (statement -> local_variable_declaration .)
    RETURN          reduce using rule 18 (statement -> local_variable_declaration .)
    LPAREN          reduce using rule 18 (statement -> local_variable_declaration .)
    NOT             reduce using rule 18 (statement -> local_variable_declaration .)
    INTEGER         reduce using rule 18 (statement -> local_variable_declaration .)
    FLOAT           reduce using rule 18 (statement -> local_variable_declaration .)
    STRING          reduce using rule 18 (statement -> local_variable_declaration .)
    BOOL            reduce using rule 18 (statement -> local_variable_declaration .)
    LBRACKET_S      reduce using rule 18 (statement -> local_variable_declaration .)
    RBRACKET        reduce using rule 18 (statement -> local_variable_declaration .)
    ELSE            reduce using rule 18 (statement -> local_variable_declaration .)


state 13

    (19) statement -> assignment_statement .

    IDENTIFIER      reduce using rule 19 (statement -> assignment_statement .)
    $end            reduce using rule 19 (statement -> assignment_statement .)
    LBRACKET        reduce using rule 19 (statement -> assignment_statement .)
    IF              reduce using rule 19 (statement -> assignment_statement .)
    WHILE           reduce using rule 19 (statement -> assignment_statement .)
    RETURN          reduce using rule 19 (statement -> assignment_statement .)
    LPAREN          reduce using rule 19 (statement -> assignment_statement .)
    NOT             reduce using rule 19 (statement -> assignment_statement .)
    INTEGER         reduce using rule 19 (statement -> assignment_statement .)
    FLOAT           reduce using rule 19 (statement -> assignment_statement .)
    STRING          reduce using rule 19 (statement -> assignment_statement .)
    BOOL            reduce using rule 19 (statement -> assignment_statement .)
    LBRACKET_S      reduce using rule 19 (statement -> assignment_statement .)
    RBRACKET        reduce using rule 19 (statement -> assignment_statement .)
    ELSE            reduce using rule 19 (statement -> assignment_statement .)


state 14

    (20) statement -> array_def .

    IDENTIFIER      reduce using rule 20 (statement -> array_def .)
    $end            reduce using rule 20 (statement -> array_def .)
    LBRACKET        reduce using rule 20 (statement -> array_def .)
    IF              reduce using rule 20 (statement -> array_def .)
    WHILE           reduce using rule 20 (statement -> array_def .)
    RETURN          reduce using rule 20 (statement -> array_def .)
    LPAREN          reduce using rule 20 (statement -> array_def .)
    NOT             reduce using rule 20 (statement -> array_def .)
    INTEGER         reduce using rule 20 (statement -> array_def .)
    FLOAT           reduce using rule 20 (statement -> array_def .)
    STRING          reduce using rule 20 (statement -> array_def .)
    BOOL            reduce using rule 20 (statement -> array_def .)
    LBRACKET_S      reduce using rule 20 (statement -> array_def .)
    RBRACKET        reduce using rule 20 (statement -> array_def .)
    ELSE            reduce using rule 20 (statement -> array_def .)


state 15

    (21) statement -> if_statement .

    IDENTIFIER      reduce using rule 21 (statement -> if_statement .)
    $end            reduce using rule 21 (statement -> if_statement .)
    LBRACKET        reduce using rule 21 (statement -> if_statement .)
    IF              reduce using rule 21 (statement -> if_statement .)
    WHILE           reduce using rule 21 (statement -> if_statement .)
    RETURN          reduce using rule 21 (statement -> if_statement .)
    LPAREN          reduce using rule 21 (statement -> if_statement .)
    NOT             reduce using rule 21 (statement -> if_statement .)
    INTEGER         reduce using rule 21 (statement -> if_statement .)
    FLOAT           reduce using rule 21 (statement -> if_statement .)
    STRING          reduce using rule 21 (statement -> if_statement .)
    BOOL            reduce using rule 21 (statement -> if_statement .)
    LBRACKET_S      reduce using rule 21 (statement -> if_statement .)
    RBRACKET        reduce using rule 21 (statement -> if_statement .)
    ELSE            reduce using rule 21 (statement -> if_statement .)


state 16

    (22) statement -> while_statement .

    IDENTIFIER      reduce using rule 22 (statement -> while_statement .)
    $end            reduce using rule 22 (statement -> while_statement .)
    LBRACKET        reduce using rule 22 (statement -> while_statement .)
    IF              reduce using rule 22 (statement -> while_statement .)
    WHILE           reduce using rule 22 (statement -> while_statement .)
    RETURN          reduce using rule 22 (statement -> while_statement .)
    LPAREN          reduce using rule 22 (statement -> while_statement .)
    NOT             reduce using rule 22 (statement -> while_statement .)
    INTEGER         reduce using rule 22 (statement -> while_statement .)
    FLOAT           reduce using rule 22 (statement -> while_statement .)
    STRING          reduce using rule 22 (statement -> while_statement .)
    BOOL            reduce using rule 22 (statement -> while_statement .)
    LBRACKET_S      reduce using rule 22 (statement -> while_statement .)
    RBRACKET        reduce using rule 22 (statement -> while_statement .)
    ELSE            reduce using rule 22 (statement -> while_statement .)


state 17

    (23) statement -> return_statement .

    IDENTIFIER      reduce using rule 23 (statement -> return_statement .)
    $end            reduce using rule 23 (statement -> return_statement .)
    LBRACKET        reduce using rule 23 (statement -> return_statement .)
    IF              reduce using rule 23 (statement -> return_statement .)
    WHILE           reduce using rule 23 (statement -> return_statement .)
    RETURN          reduce using rule 23 (statement -> return_statement .)
    LPAREN          reduce using rule 23 (statement -> return_statement .)
    NOT             reduce using rule 23 (statement -> return_statement .)
    INTEGER         reduce using rule 23 (statement -> return_statement .)
    FLOAT           reduce using rule 23 (statement -> return_statement .)
    STRING          reduce using rule 23 (statement -> return_statement .)
    BOOL            reduce using rule 23 (statement -> return_statement .)
    LBRACKET_S      reduce using rule 23 (statement -> return_statement .)
    RBRACKET        reduce using rule 23 (statement -> return_statement .)
    ELSE            reduce using rule 23 (statement -> return_statement .)


state 18

    (24) statement -> expression . SEMICOLON
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    SEMICOLON       shift and go to state 41
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 19

    (14) statement_part -> LBRACKET . statement_sequence RBRACKET
    (15) statement_sequence -> . statement statement_sequence
    (16) statement_sequence -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON array_access SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) return_statement -> . RETURN SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (69) identifier -> . IDENTIFIER
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    statement_sequence             shift and go to state 45
    statement                      shift and go to state 46
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    expression                     shift and go to state 18
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 20

    (31) local_variable_declaration -> identifier . COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> identifier . ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> identifier . LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> identifier . COLON array_access SEMICOLON
    (57) expression_e -> identifier .
    (67) function_call -> identifier . LPAREN param_list RPAREN
    (68) array_call -> identifier . LBRACKET_S expression RBRACKET_S

    COLON           shift and go to state 47
    ASSIGNMENT      shift and go to state 48
    LBRACKET_S      shift and go to state 49
    TIMES           reduce using rule 57 (expression_e -> identifier .)
    DIV             reduce using rule 57 (expression_e -> identifier .)
    PLUS            reduce using rule 57 (expression_e -> identifier .)
    MINUS           reduce using rule 57 (expression_e -> identifier .)
    MOD             reduce using rule 57 (expression_e -> identifier .)
    EQUAL           reduce using rule 57 (expression_e -> identifier .)
    NEQUAL          reduce using rule 57 (expression_e -> identifier .)
    LT              reduce using rule 57 (expression_e -> identifier .)
    LTE             reduce using rule 57 (expression_e -> identifier .)
    GT              reduce using rule 57 (expression_e -> identifier .)
    GTE             reduce using rule 57 (expression_e -> identifier .)
    SEMICOLON       reduce using rule 57 (expression_e -> identifier .)
    AND             reduce using rule 57 (expression_e -> identifier .)
    OR              reduce using rule 57 (expression_e -> identifier .)
    LPAREN          shift and go to state 50


state 21

    (74) array -> LBRACKET_S . expression RBRACKET_S
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 51
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 22

    (35) if_statement -> IF . expression body ELSE body
    (36) if_statement -> IF . expression body
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 53
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 23

    (37) while_statement -> WHILE . expression body
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 54
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 24

    (38) return_statement -> RETURN . expression SEMICOLON
    (39) return_statement -> RETURN . SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    SEMICOLON       shift and go to state 56
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 55
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 25

    (40) expression -> expression_m .
    (43) expression_m -> expression_m . sign expression_e
    (46) sign -> . TIMES
    (47) sign -> . DIV
    (48) sign -> . PLUS
    (49) sign -> . MINUS
    (50) sign -> . MOD
    (51) sign -> . EQUAL
    (52) sign -> . NEQUAL
    (53) sign -> . LT
    (54) sign -> . LTE
    (55) sign -> . GT
    (56) sign -> . GTE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
    SEMICOLON       reduce using rule 40 (expression -> expression_m .)
    AND             reduce using rule 40 (expression -> expression_m .)
    OR              reduce using rule 40 (expression -> expression_m .)
    RBRACKET_S      reduce using rule 40 (expression -> expression_m .)
    LBRACKET        reduce using rule 40 (expression -> expression_m .)
    IF              reduce using rule 40 (expression -> expression_m .)
    WHILE           reduce using rule 40 (expression -> expression_m .)
    RETURN          reduce using rule 40 (expression -> expression_m .)
    IDENTIFIER      reduce using rule 40 (expression -> expression_m .)
    LPAREN          reduce using rule 40 (expression -> expression_m .)
    NOT             reduce using rule 40 (expression -> expression_m .)
    INTEGER         reduce using rule 40 (expression -> expression_m .)
    FLOAT           reduce using rule 40 (expression -> expression_m .)
    STRING          reduce using rule 40 (expression -> expression_m .)
    BOOL            reduce using rule 40 (expression -> expression_m .)
    LBRACKET_S      reduce using rule 40 (expression -> expression_m .)
    ELSE            reduce using rule 40 (expression -> expression_m .)
    $end            reduce using rule 40 (expression -> expression_m .)
    RBRACKET        reduce using rule 40 (expression -> expression_m .)
    RPAREN          reduce using rule 40 (expression -> expression_m .)
    COMMA           reduce using rule 40 (expression -> expression_m .)
    TIMES           shift and go to state 58
    DIV             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    MOD             shift and go to state 62
    EQUAL           shift and go to state 63
    NEQUAL          shift and go to state 64
    LT              shift and go to state 65
    LTE             shift and go to state 66
    GT              shift and go to state 67
    GTE             shift and go to state 68

  ! TIMES           [ reduce using rule 40 (expression -> expression_m .) ]
  ! DIV             [ reduce using rule 40 (expression -> expression_m .) ]
  ! PLUS            [ reduce using rule 40 (expression -> expression_m .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression_m .) ]
  ! MOD             [ reduce using rule 40 (expression -> expression_m .) ]
  ! EQUAL           [ reduce using rule 40 (expression -> expression_m .) ]
  ! NEQUAL          [ reduce using rule 40 (expression -> expression_m .) ]
  ! LT              [ reduce using rule 40 (expression -> expression_m .) ]
  ! LTE             [ reduce using rule 40 (expression -> expression_m .) ]
  ! GT              [ reduce using rule 40 (expression -> expression_m .) ]
  ! GTE             [ reduce using rule 40 (expression -> expression_m .) ]

    sign                           shift and go to state 57

state 26

    (42) expression_m -> expression_e .

    TIMES           reduce using rule 42 (expression_m -> expression_e .)
    DIV             reduce using rule 42 (expression_m -> expression_e .)
    PLUS            reduce using rule 42 (expression_m -> expression_e .)
    MINUS           reduce using rule 42 (expression_m -> expression_e .)
    MOD             reduce using rule 42 (expression_m -> expression_e .)
    EQUAL           reduce using rule 42 (expression_m -> expression_e .)
    NEQUAL          reduce using rule 42 (expression_m -> expression_e .)
    LT              reduce using rule 42 (expression_m -> expression_e .)
    LTE             reduce using rule 42 (expression_m -> expression_e .)
    GT              reduce using rule 42 (expression_m -> expression_e .)
    GTE             reduce using rule 42 (expression_m -> expression_e .)
    SEMICOLON       reduce using rule 42 (expression_m -> expression_e .)
    AND             reduce using rule 42 (expression_m -> expression_e .)
    OR              reduce using rule 42 (expression_m -> expression_e .)
    RBRACKET_S      reduce using rule 42 (expression_m -> expression_e .)
    LBRACKET        reduce using rule 42 (expression_m -> expression_e .)
    IF              reduce using rule 42 (expression_m -> expression_e .)
    WHILE           reduce using rule 42 (expression_m -> expression_e .)
    RETURN          reduce using rule 42 (expression_m -> expression_e .)
    IDENTIFIER      reduce using rule 42 (expression_m -> expression_e .)
    LPAREN          reduce using rule 42 (expression_m -> expression_e .)
    NOT             reduce using rule 42 (expression_m -> expression_e .)
    INTEGER         reduce using rule 42 (expression_m -> expression_e .)
    FLOAT           reduce using rule 42 (expression_m -> expression_e .)
    STRING          reduce using rule 42 (expression_m -> expression_e .)
    BOOL            reduce using rule 42 (expression_m -> expression_e .)
    LBRACKET_S      reduce using rule 42 (expression_m -> expression_e .)
    ELSE            reduce using rule 42 (expression_m -> expression_e .)
    $end            reduce using rule 42 (expression_m -> expression_e .)
    RBRACKET        reduce using rule 42 (expression_m -> expression_e .)
    RPAREN          reduce using rule 42 (expression_m -> expression_e .)
    COMMA           reduce using rule 42 (expression_m -> expression_e .)


state 27

    (58) expression_e -> integer .

    TIMES           reduce using rule 58 (expression_e -> integer .)
    DIV             reduce using rule 58 (expression_e -> integer .)
    PLUS            reduce using rule 58 (expression_e -> integer .)
    MINUS           reduce using rule 58 (expression_e -> integer .)
    MOD             reduce using rule 58 (expression_e -> integer .)
    EQUAL           reduce using rule 58 (expression_e -> integer .)
    NEQUAL          reduce using rule 58 (expression_e -> integer .)
    LT              reduce using rule 58 (expression_e -> integer .)
    LTE             reduce using rule 58 (expression_e -> integer .)
    GT              reduce using rule 58 (expression_e -> integer .)
    GTE             reduce using rule 58 (expression_e -> integer .)
    SEMICOLON       reduce using rule 58 (expression_e -> integer .)
    AND             reduce using rule 58 (expression_e -> integer .)
    OR              reduce using rule 58 (expression_e -> integer .)
    RBRACKET_S      reduce using rule 58 (expression_e -> integer .)
    LBRACKET        reduce using rule 58 (expression_e -> integer .)
    IF              reduce using rule 58 (expression_e -> integer .)
    WHILE           reduce using rule 58 (expression_e -> integer .)
    RETURN          reduce using rule 58 (expression_e -> integer .)
    IDENTIFIER      reduce using rule 58 (expression_e -> integer .)
    LPAREN          reduce using rule 58 (expression_e -> integer .)
    NOT             reduce using rule 58 (expression_e -> integer .)
    INTEGER         reduce using rule 58 (expression_e -> integer .)
    FLOAT           reduce using rule 58 (expression_e -> integer .)
    STRING          reduce using rule 58 (expression_e -> integer .)
    BOOL            reduce using rule 58 (expression_e -> integer .)
    LBRACKET_S      reduce using rule 58 (expression_e -> integer .)
    ELSE            reduce using rule 58 (expression_e -> integer .)
    $end            reduce using rule 58 (expression_e -> integer .)
    RBRACKET        reduce using rule 58 (expression_e -> integer .)
    RPAREN          reduce using rule 58 (expression_e -> integer .)
    COMMA           reduce using rule 58 (expression_e -> integer .)


state 28

    (59) expression_e -> float .

    TIMES           reduce using rule 59 (expression_e -> float .)
    DIV             reduce using rule 59 (expression_e -> float .)
    PLUS            reduce using rule 59 (expression_e -> float .)
    MINUS           reduce using rule 59 (expression_e -> float .)
    MOD             reduce using rule 59 (expression_e -> float .)
    EQUAL           reduce using rule 59 (expression_e -> float .)
    NEQUAL          reduce using rule 59 (expression_e -> float .)
    LT              reduce using rule 59 (expression_e -> float .)
    LTE             reduce using rule 59 (expression_e -> float .)
    GT              reduce using rule 59 (expression_e -> float .)
    GTE             reduce using rule 59 (expression_e -> float .)
    SEMICOLON       reduce using rule 59 (expression_e -> float .)
    AND             reduce using rule 59 (expression_e -> float .)
    OR              reduce using rule 59 (expression_e -> float .)
    RBRACKET_S      reduce using rule 59 (expression_e -> float .)
    LBRACKET        reduce using rule 59 (expression_e -> float .)
    IF              reduce using rule 59 (expression_e -> float .)
    WHILE           reduce using rule 59 (expression_e -> float .)
    RETURN          reduce using rule 59 (expression_e -> float .)
    IDENTIFIER      reduce using rule 59 (expression_e -> float .)
    LPAREN          reduce using rule 59 (expression_e -> float .)
    NOT             reduce using rule 59 (expression_e -> float .)
    INTEGER         reduce using rule 59 (expression_e -> float .)
    FLOAT           reduce using rule 59 (expression_e -> float .)
    STRING          reduce using rule 59 (expression_e -> float .)
    BOOL            reduce using rule 59 (expression_e -> float .)
    LBRACKET_S      reduce using rule 59 (expression_e -> float .)
    ELSE            reduce using rule 59 (expression_e -> float .)
    $end            reduce using rule 59 (expression_e -> float .)
    RBRACKET        reduce using rule 59 (expression_e -> float .)
    RPAREN          reduce using rule 59 (expression_e -> float .)
    COMMA           reduce using rule 59 (expression_e -> float .)


state 29

    (60) expression_e -> string .

    TIMES           reduce using rule 60 (expression_e -> string .)
    DIV             reduce using rule 60 (expression_e -> string .)
    PLUS            reduce using rule 60 (expression_e -> string .)
    MINUS           reduce using rule 60 (expression_e -> string .)
    MOD             reduce using rule 60 (expression_e -> string .)
    EQUAL           reduce using rule 60 (expression_e -> string .)
    NEQUAL          reduce using rule 60 (expression_e -> string .)
    LT              reduce using rule 60 (expression_e -> string .)
    LTE             reduce using rule 60 (expression_e -> string .)
    GT              reduce using rule 60 (expression_e -> string .)
    GTE             reduce using rule 60 (expression_e -> string .)
    SEMICOLON       reduce using rule 60 (expression_e -> string .)
    AND             reduce using rule 60 (expression_e -> string .)
    OR              reduce using rule 60 (expression_e -> string .)
    RBRACKET_S      reduce using rule 60 (expression_e -> string .)
    LBRACKET        reduce using rule 60 (expression_e -> string .)
    IF              reduce using rule 60 (expression_e -> string .)
    WHILE           reduce using rule 60 (expression_e -> string .)
    RETURN          reduce using rule 60 (expression_e -> string .)
    IDENTIFIER      reduce using rule 60 (expression_e -> string .)
    LPAREN          reduce using rule 60 (expression_e -> string .)
    NOT             reduce using rule 60 (expression_e -> string .)
    INTEGER         reduce using rule 60 (expression_e -> string .)
    FLOAT           reduce using rule 60 (expression_e -> string .)
    STRING          reduce using rule 60 (expression_e -> string .)
    BOOL            reduce using rule 60 (expression_e -> string .)
    LBRACKET_S      reduce using rule 60 (expression_e -> string .)
    ELSE            reduce using rule 60 (expression_e -> string .)
    $end            reduce using rule 60 (expression_e -> string .)
    RBRACKET        reduce using rule 60 (expression_e -> string .)
    RPAREN          reduce using rule 60 (expression_e -> string .)
    COMMA           reduce using rule 60 (expression_e -> string .)


state 30

    (61) expression_e -> bool .

    TIMES           reduce using rule 61 (expression_e -> bool .)
    DIV             reduce using rule 61 (expression_e -> bool .)
    PLUS            reduce using rule 61 (expression_e -> bool .)
    MINUS           reduce using rule 61 (expression_e -> bool .)
    MOD             reduce using rule 61 (expression_e -> bool .)
    EQUAL           reduce using rule 61 (expression_e -> bool .)
    NEQUAL          reduce using rule 61 (expression_e -> bool .)
    LT              reduce using rule 61 (expression_e -> bool .)
    LTE             reduce using rule 61 (expression_e -> bool .)
    GT              reduce using rule 61 (expression_e -> bool .)
    GTE             reduce using rule 61 (expression_e -> bool .)
    SEMICOLON       reduce using rule 61 (expression_e -> bool .)
    AND             reduce using rule 61 (expression_e -> bool .)
    OR              reduce using rule 61 (expression_e -> bool .)
    RBRACKET_S      reduce using rule 61 (expression_e -> bool .)
    LBRACKET        reduce using rule 61 (expression_e -> bool .)
    IF              reduce using rule 61 (expression_e -> bool .)
    WHILE           reduce using rule 61 (expression_e -> bool .)
    RETURN          reduce using rule 61 (expression_e -> bool .)
    IDENTIFIER      reduce using rule 61 (expression_e -> bool .)
    LPAREN          reduce using rule 61 (expression_e -> bool .)
    NOT             reduce using rule 61 (expression_e -> bool .)
    INTEGER         reduce using rule 61 (expression_e -> bool .)
    FLOAT           reduce using rule 61 (expression_e -> bool .)
    STRING          reduce using rule 61 (expression_e -> bool .)
    BOOL            reduce using rule 61 (expression_e -> bool .)
    LBRACKET_S      reduce using rule 61 (expression_e -> bool .)
    ELSE            reduce using rule 61 (expression_e -> bool .)
    $end            reduce using rule 61 (expression_e -> bool .)
    RBRACKET        reduce using rule 61 (expression_e -> bool .)
    RPAREN          reduce using rule 61 (expression_e -> bool .)
    COMMA           reduce using rule 61 (expression_e -> bool .)


state 31

    (62) expression_e -> array .

    TIMES           reduce using rule 62 (expression_e -> array .)
    DIV             reduce using rule 62 (expression_e -> array .)
    PLUS            reduce using rule 62 (expression_e -> array .)
    MINUS           reduce using rule 62 (expression_e -> array .)
    MOD             reduce using rule 62 (expression_e -> array .)
    EQUAL           reduce using rule 62 (expression_e -> array .)
    NEQUAL          reduce using rule 62 (expression_e -> array .)
    LT              reduce using rule 62 (expression_e -> array .)
    LTE             reduce using rule 62 (expression_e -> array .)
    GT              reduce using rule 62 (expression_e -> array .)
    GTE             reduce using rule 62 (expression_e -> array .)
    SEMICOLON       reduce using rule 62 (expression_e -> array .)
    AND             reduce using rule 62 (expression_e -> array .)
    OR              reduce using rule 62 (expression_e -> array .)
    RBRACKET_S      reduce using rule 62 (expression_e -> array .)
    LBRACKET        reduce using rule 62 (expression_e -> array .)
    IF              reduce using rule 62 (expression_e -> array .)
    WHILE           reduce using rule 62 (expression_e -> array .)
    RETURN          reduce using rule 62 (expression_e -> array .)
    IDENTIFIER      reduce using rule 62 (expression_e -> array .)
    LPAREN          reduce using rule 62 (expression_e -> array .)
    NOT             reduce using rule 62 (expression_e -> array .)
    INTEGER         reduce using rule 62 (expression_e -> array .)
    FLOAT           reduce using rule 62 (expression_e -> array .)
    STRING          reduce using rule 62 (expression_e -> array .)
    BOOL            reduce using rule 62 (expression_e -> array .)
    LBRACKET_S      reduce using rule 62 (expression_e -> array .)
    ELSE            reduce using rule 62 (expression_e -> array .)
    $end            reduce using rule 62 (expression_e -> array .)
    RBRACKET        reduce using rule 62 (expression_e -> array .)
    RPAREN          reduce using rule 62 (expression_e -> array .)
    COMMA           reduce using rule 62 (expression_e -> array .)


state 32

    (63) expression_e -> LPAREN . expression RPAREN
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 69
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 33

    (64) expression_e -> NOT . expression
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression                     shift and go to state 70
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 34

    (65) expression_e -> function_call .

    TIMES           reduce using rule 65 (expression_e -> function_call .)
    DIV             reduce using rule 65 (expression_e -> function_call .)
    PLUS            reduce using rule 65 (expression_e -> function_call .)
    MINUS           reduce using rule 65 (expression_e -> function_call .)
    MOD             reduce using rule 65 (expression_e -> function_call .)
    EQUAL           reduce using rule 65 (expression_e -> function_call .)
    NEQUAL          reduce using rule 65 (expression_e -> function_call .)
    LT              reduce using rule 65 (expression_e -> function_call .)
    LTE             reduce using rule 65 (expression_e -> function_call .)
    GT              reduce using rule 65 (expression_e -> function_call .)
    GTE             reduce using rule 65 (expression_e -> function_call .)
    SEMICOLON       reduce using rule 65 (expression_e -> function_call .)
    AND             reduce using rule 65 (expression_e -> function_call .)
    OR              reduce using rule 65 (expression_e -> function_call .)
    RBRACKET_S      reduce using rule 65 (expression_e -> function_call .)
    LBRACKET        reduce using rule 65 (expression_e -> function_call .)
    IF              reduce using rule 65 (expression_e -> function_call .)
    WHILE           reduce using rule 65 (expression_e -> function_call .)
    RETURN          reduce using rule 65 (expression_e -> function_call .)
    IDENTIFIER      reduce using rule 65 (expression_e -> function_call .)
    LPAREN          reduce using rule 65 (expression_e -> function_call .)
    NOT             reduce using rule 65 (expression_e -> function_call .)
    INTEGER         reduce using rule 65 (expression_e -> function_call .)
    FLOAT           reduce using rule 65 (expression_e -> function_call .)
    STRING          reduce using rule 65 (expression_e -> function_call .)
    BOOL            reduce using rule 65 (expression_e -> function_call .)
    LBRACKET_S      reduce using rule 65 (expression_e -> function_call .)
    ELSE            reduce using rule 65 (expression_e -> function_call .)
    $end            reduce using rule 65 (expression_e -> function_call .)
    RBRACKET        reduce using rule 65 (expression_e -> function_call .)
    RPAREN          reduce using rule 65 (expression_e -> function_call .)
    COMMA           reduce using rule 65 (expression_e -> function_call .)


state 35

    (66) expression_e -> array_call .

    TIMES           reduce using rule 66 (expression_e -> array_call .)
    DIV             reduce using rule 66 (expression_e -> array_call .)
    PLUS            reduce using rule 66 (expression_e -> array_call .)
    MINUS           reduce using rule 66 (expression_e -> array_call .)
    MOD             reduce using rule 66 (expression_e -> array_call .)
    EQUAL           reduce using rule 66 (expression_e -> array_call .)
    NEQUAL          reduce using rule 66 (expression_e -> array_call .)
    LT              reduce using rule 66 (expression_e -> array_call .)
    LTE             reduce using rule 66 (expression_e -> array_call .)
    GT              reduce using rule 66 (expression_e -> array_call .)
    GTE             reduce using rule 66 (expression_e -> array_call .)
    SEMICOLON       reduce using rule 66 (expression_e -> array_call .)
    AND             reduce using rule 66 (expression_e -> array_call .)
    OR              reduce using rule 66 (expression_e -> array_call .)
    RBRACKET_S      reduce using rule 66 (expression_e -> array_call .)
    LBRACKET        reduce using rule 66 (expression_e -> array_call .)
    IF              reduce using rule 66 (expression_e -> array_call .)
    WHILE           reduce using rule 66 (expression_e -> array_call .)
    RETURN          reduce using rule 66 (expression_e -> array_call .)
    IDENTIFIER      reduce using rule 66 (expression_e -> array_call .)
    LPAREN          reduce using rule 66 (expression_e -> array_call .)
    NOT             reduce using rule 66 (expression_e -> array_call .)
    INTEGER         reduce using rule 66 (expression_e -> array_call .)
    FLOAT           reduce using rule 66 (expression_e -> array_call .)
    STRING          reduce using rule 66 (expression_e -> array_call .)
    BOOL            reduce using rule 66 (expression_e -> array_call .)
    LBRACKET_S      reduce using rule 66 (expression_e -> array_call .)
    ELSE            reduce using rule 66 (expression_e -> array_call .)
    $end            reduce using rule 66 (expression_e -> array_call .)
    RBRACKET        reduce using rule 66 (expression_e -> array_call .)
    RPAREN          reduce using rule 66 (expression_e -> array_call .)
    COMMA           reduce using rule 66 (expression_e -> array_call .)


state 36

    (70) integer -> INTEGER .

    TIMES           reduce using rule 70 (integer -> INTEGER .)
    DIV             reduce using rule 70 (integer -> INTEGER .)
    PLUS            reduce using rule 70 (integer -> INTEGER .)
    MINUS           reduce using rule 70 (integer -> INTEGER .)
    MOD             reduce using rule 70 (integer -> INTEGER .)
    EQUAL           reduce using rule 70 (integer -> INTEGER .)
    NEQUAL          reduce using rule 70 (integer -> INTEGER .)
    LT              reduce using rule 70 (integer -> INTEGER .)
    LTE             reduce using rule 70 (integer -> INTEGER .)
    GT              reduce using rule 70 (integer -> INTEGER .)
    GTE             reduce using rule 70 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 70 (integer -> INTEGER .)
    AND             reduce using rule 70 (integer -> INTEGER .)
    OR              reduce using rule 70 (integer -> INTEGER .)
    RBRACKET_S      reduce using rule 70 (integer -> INTEGER .)
    LBRACKET        reduce using rule 70 (integer -> INTEGER .)
    IF              reduce using rule 70 (integer -> INTEGER .)
    WHILE           reduce using rule 70 (integer -> INTEGER .)
    RETURN          reduce using rule 70 (integer -> INTEGER .)
    IDENTIFIER      reduce using rule 70 (integer -> INTEGER .)
    LPAREN          reduce using rule 70 (integer -> INTEGER .)
    NOT             reduce using rule 70 (integer -> INTEGER .)
    INTEGER         reduce using rule 70 (integer -> INTEGER .)
    FLOAT           reduce using rule 70 (integer -> INTEGER .)
    STRING          reduce using rule 70 (integer -> INTEGER .)
    BOOL            reduce using rule 70 (integer -> INTEGER .)
    LBRACKET_S      reduce using rule 70 (integer -> INTEGER .)
    ELSE            reduce using rule 70 (integer -> INTEGER .)
    $end            reduce using rule 70 (integer -> INTEGER .)
    RBRACKET        reduce using rule 70 (integer -> INTEGER .)
    RPAREN          reduce using rule 70 (integer -> INTEGER .)
    COMMA           reduce using rule 70 (integer -> INTEGER .)


state 37

    (71) float -> FLOAT .

    TIMES           reduce using rule 71 (float -> FLOAT .)
    DIV             reduce using rule 71 (float -> FLOAT .)
    PLUS            reduce using rule 71 (float -> FLOAT .)
    MINUS           reduce using rule 71 (float -> FLOAT .)
    MOD             reduce using rule 71 (float -> FLOAT .)
    EQUAL           reduce using rule 71 (float -> FLOAT .)
    NEQUAL          reduce using rule 71 (float -> FLOAT .)
    LT              reduce using rule 71 (float -> FLOAT .)
    LTE             reduce using rule 71 (float -> FLOAT .)
    GT              reduce using rule 71 (float -> FLOAT .)
    GTE             reduce using rule 71 (float -> FLOAT .)
    SEMICOLON       reduce using rule 71 (float -> FLOAT .)
    AND             reduce using rule 71 (float -> FLOAT .)
    OR              reduce using rule 71 (float -> FLOAT .)
    RBRACKET_S      reduce using rule 71 (float -> FLOAT .)
    LBRACKET        reduce using rule 71 (float -> FLOAT .)
    IF              reduce using rule 71 (float -> FLOAT .)
    WHILE           reduce using rule 71 (float -> FLOAT .)
    RETURN          reduce using rule 71 (float -> FLOAT .)
    IDENTIFIER      reduce using rule 71 (float -> FLOAT .)
    LPAREN          reduce using rule 71 (float -> FLOAT .)
    NOT             reduce using rule 71 (float -> FLOAT .)
    INTEGER         reduce using rule 71 (float -> FLOAT .)
    FLOAT           reduce using rule 71 (float -> FLOAT .)
    STRING          reduce using rule 71 (float -> FLOAT .)
    BOOL            reduce using rule 71 (float -> FLOAT .)
    LBRACKET_S      reduce using rule 71 (float -> FLOAT .)
    ELSE            reduce using rule 71 (float -> FLOAT .)
    $end            reduce using rule 71 (float -> FLOAT .)
    RBRACKET        reduce using rule 71 (float -> FLOAT .)
    RPAREN          reduce using rule 71 (float -> FLOAT .)
    COMMA           reduce using rule 71 (float -> FLOAT .)


state 38

    (72) string -> STRING .

    TIMES           reduce using rule 72 (string -> STRING .)
    DIV             reduce using rule 72 (string -> STRING .)
    PLUS            reduce using rule 72 (string -> STRING .)
    MINUS           reduce using rule 72 (string -> STRING .)
    MOD             reduce using rule 72 (string -> STRING .)
    EQUAL           reduce using rule 72 (string -> STRING .)
    NEQUAL          reduce using rule 72 (string -> STRING .)
    LT              reduce using rule 72 (string -> STRING .)
    LTE             reduce using rule 72 (string -> STRING .)
    GT              reduce using rule 72 (string -> STRING .)
    GTE             reduce using rule 72 (string -> STRING .)
    SEMICOLON       reduce using rule 72 (string -> STRING .)
    AND             reduce using rule 72 (string -> STRING .)
    OR              reduce using rule 72 (string -> STRING .)
    RBRACKET_S      reduce using rule 72 (string -> STRING .)
    LBRACKET        reduce using rule 72 (string -> STRING .)
    IF              reduce using rule 72 (string -> STRING .)
    WHILE           reduce using rule 72 (string -> STRING .)
    RETURN          reduce using rule 72 (string -> STRING .)
    IDENTIFIER      reduce using rule 72 (string -> STRING .)
    LPAREN          reduce using rule 72 (string -> STRING .)
    NOT             reduce using rule 72 (string -> STRING .)
    INTEGER         reduce using rule 72 (string -> STRING .)
    FLOAT           reduce using rule 72 (string -> STRING .)
    STRING          reduce using rule 72 (string -> STRING .)
    BOOL            reduce using rule 72 (string -> STRING .)
    LBRACKET_S      reduce using rule 72 (string -> STRING .)
    ELSE            reduce using rule 72 (string -> STRING .)
    $end            reduce using rule 72 (string -> STRING .)
    RBRACKET        reduce using rule 72 (string -> STRING .)
    RPAREN          reduce using rule 72 (string -> STRING .)
    COMMA           reduce using rule 72 (string -> STRING .)


state 39

    (73) bool -> BOOL .

    TIMES           reduce using rule 73 (bool -> BOOL .)
    DIV             reduce using rule 73 (bool -> BOOL .)
    PLUS            reduce using rule 73 (bool -> BOOL .)
    MINUS           reduce using rule 73 (bool -> BOOL .)
    MOD             reduce using rule 73 (bool -> BOOL .)
    EQUAL           reduce using rule 73 (bool -> BOOL .)
    NEQUAL          reduce using rule 73 (bool -> BOOL .)
    LT              reduce using rule 73 (bool -> BOOL .)
    LTE             reduce using rule 73 (bool -> BOOL .)
    GT              reduce using rule 73 (bool -> BOOL .)
    GTE             reduce using rule 73 (bool -> BOOL .)
    SEMICOLON       reduce using rule 73 (bool -> BOOL .)
    AND             reduce using rule 73 (bool -> BOOL .)
    OR              reduce using rule 73 (bool -> BOOL .)
    RBRACKET_S      reduce using rule 73 (bool -> BOOL .)
    LBRACKET        reduce using rule 73 (bool -> BOOL .)
    IF              reduce using rule 73 (bool -> BOOL .)
    WHILE           reduce using rule 73 (bool -> BOOL .)
    RETURN          reduce using rule 73 (bool -> BOOL .)
    IDENTIFIER      reduce using rule 73 (bool -> BOOL .)
    LPAREN          reduce using rule 73 (bool -> BOOL .)
    NOT             reduce using rule 73 (bool -> BOOL .)
    INTEGER         reduce using rule 73 (bool -> BOOL .)
    FLOAT           reduce using rule 73 (bool -> BOOL .)
    STRING          reduce using rule 73 (bool -> BOOL .)
    BOOL            reduce using rule 73 (bool -> BOOL .)
    LBRACKET_S      reduce using rule 73 (bool -> BOOL .)
    ELSE            reduce using rule 73 (bool -> BOOL .)
    $end            reduce using rule 73 (bool -> BOOL .)
    RBRACKET        reduce using rule 73 (bool -> BOOL .)
    RPAREN          reduce using rule 73 (bool -> BOOL .)
    COMMA           reduce using rule 73 (bool -> BOOL .)


state 40

    (8) function_declaration -> identifier COLON . type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON . type SEMICOLON
    (6) variable_declaration -> identifier COLON . type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier COLON . type LPAREN parameter_list RPAREN
    (75) type -> . TINTEGER
    (76) type -> . TFLOAT
    (77) type -> . TSTRING
    (78) type -> . TBOOL
    (79) type -> . TVOID
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 72
    TFLOAT          shift and go to state 73
    TSTRING         shift and go to state 74
    TBOOL           shift and go to state 75
    TVOID           shift and go to state 76
    LBRACKET_S      shift and go to state 77

    type                           shift and go to state 71

state 41

    (24) statement -> expression SEMICOLON .

    IDENTIFIER      reduce using rule 24 (statement -> expression SEMICOLON .)
    $end            reduce using rule 24 (statement -> expression SEMICOLON .)
    LBRACKET        reduce using rule 24 (statement -> expression SEMICOLON .)
    IF              reduce using rule 24 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 24 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 24 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 24 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 24 (statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 24 (statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 24 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 24 (statement -> expression SEMICOLON .)
    BOOL            reduce using rule 24 (statement -> expression SEMICOLON .)
    LBRACKET_S      reduce using rule 24 (statement -> expression SEMICOLON .)
    RBRACKET        reduce using rule 24 (statement -> expression SEMICOLON .)
    ELSE            reduce using rule 24 (statement -> expression SEMICOLON .)


state 42

    (41) expression -> expression and_or . expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression_m                   shift and go to state 78
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 43

    (44) and_or -> AND .

    LPAREN          reduce using rule 44 (and_or -> AND .)
    NOT             reduce using rule 44 (and_or -> AND .)
    IDENTIFIER      reduce using rule 44 (and_or -> AND .)
    INTEGER         reduce using rule 44 (and_or -> AND .)
    FLOAT           reduce using rule 44 (and_or -> AND .)
    STRING          reduce using rule 44 (and_or -> AND .)
    BOOL            reduce using rule 44 (and_or -> AND .)
    LBRACKET_S      reduce using rule 44 (and_or -> AND .)


state 44

    (45) and_or -> OR .

    LPAREN          reduce using rule 45 (and_or -> OR .)
    NOT             reduce using rule 45 (and_or -> OR .)
    IDENTIFIER      reduce using rule 45 (and_or -> OR .)
    INTEGER         reduce using rule 45 (and_or -> OR .)
    FLOAT           reduce using rule 45 (and_or -> OR .)
    STRING          reduce using rule 45 (and_or -> OR .)
    BOOL            reduce using rule 45 (and_or -> OR .)
    LBRACKET_S      reduce using rule 45 (and_or -> OR .)


state 45

    (14) statement_part -> LBRACKET statement_sequence . RBRACKET

    RBRACKET        shift and go to state 79


state 46

    (15) statement_sequence -> statement . statement_sequence
    (16) statement_sequence -> statement .
    (15) statement_sequence -> . statement statement_sequence
    (16) statement_sequence -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON array_access SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) return_statement -> . RETURN SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (69) identifier -> . IDENTIFIER
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! reduce/reduce conflict for RBRACKET resolved using rule 16 (statement_sequence -> statement .)
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    RBRACKET        reduce using rule 16 (statement_sequence -> statement .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]
  ! RBRACKET        [ reduce using rule 25 (statement -> .) ]

    statement                      shift and go to state 46
    statement_sequence             shift and go to state 80
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    expression                     shift and go to state 18
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 47

    (31) local_variable_declaration -> identifier COLON . type ASSIGNMENT expression SEMICOLON
    (34) array_def -> identifier COLON . array_access SEMICOLON
    (75) type -> . TINTEGER
    (76) type -> . TFLOAT
    (77) type -> . TSTRING
    (78) type -> . TBOOL
    (79) type -> . TVOID
    (80) type -> . LBRACKET_S type RBRACKET_S
    (81) array_access -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 72
    TFLOAT          shift and go to state 73
    TSTRING         shift and go to state 74
    TBOOL           shift and go to state 75
    TVOID           shift and go to state 76
    LBRACKET_S      shift and go to state 83

    type                           shift and go to state 81
    array_access                   shift and go to state 82

state 48

    (32) assignment_statement -> identifier ASSIGNMENT . expression SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 84
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 49

    (33) assignment_statement -> identifier LBRACKET_S . expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (68) array_call -> identifier LBRACKET_S . expression RBRACKET_S
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 85
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 50

    (67) function_call -> identifier LPAREN . param_list RPAREN
    (27) param_list -> . param COMMA param_list
    (28) param_list -> . param
    (29) param_list -> .
    (30) param -> . expression
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    RPAREN          reduce using rule 29 (param_list -> .)
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    param_list                     shift and go to state 86
    param                          shift and go to state 87
    expression                     shift and go to state 88
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 51

    (74) array -> LBRACKET_S expression . RBRACKET_S
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    RBRACKET_S      shift and go to state 89
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 52

    (57) expression_e -> identifier .
    (67) function_call -> identifier . LPAREN param_list RPAREN
    (68) array_call -> identifier . LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    TIMES           reduce using rule 57 (expression_e -> identifier .)
    DIV             reduce using rule 57 (expression_e -> identifier .)
    PLUS            reduce using rule 57 (expression_e -> identifier .)
    MINUS           reduce using rule 57 (expression_e -> identifier .)
    MOD             reduce using rule 57 (expression_e -> identifier .)
    EQUAL           reduce using rule 57 (expression_e -> identifier .)
    NEQUAL          reduce using rule 57 (expression_e -> identifier .)
    LT              reduce using rule 57 (expression_e -> identifier .)
    LTE             reduce using rule 57 (expression_e -> identifier .)
    GT              reduce using rule 57 (expression_e -> identifier .)
    GTE             reduce using rule 57 (expression_e -> identifier .)
    RBRACKET_S      reduce using rule 57 (expression_e -> identifier .)
    AND             reduce using rule 57 (expression_e -> identifier .)
    OR              reduce using rule 57 (expression_e -> identifier .)
    LBRACKET        reduce using rule 57 (expression_e -> identifier .)
    IF              reduce using rule 57 (expression_e -> identifier .)
    WHILE           reduce using rule 57 (expression_e -> identifier .)
    RETURN          reduce using rule 57 (expression_e -> identifier .)
    IDENTIFIER      reduce using rule 57 (expression_e -> identifier .)
    NOT             reduce using rule 57 (expression_e -> identifier .)
    INTEGER         reduce using rule 57 (expression_e -> identifier .)
    FLOAT           reduce using rule 57 (expression_e -> identifier .)
    STRING          reduce using rule 57 (expression_e -> identifier .)
    BOOL            reduce using rule 57 (expression_e -> identifier .)
    ELSE            reduce using rule 57 (expression_e -> identifier .)
    $end            reduce using rule 57 (expression_e -> identifier .)
    RBRACKET        reduce using rule 57 (expression_e -> identifier .)
    SEMICOLON       reduce using rule 57 (expression_e -> identifier .)
    RPAREN          reduce using rule 57 (expression_e -> identifier .)
    COMMA           reduce using rule 57 (expression_e -> identifier .)
    LPAREN          shift and go to state 50
    LBRACKET_S      shift and go to state 90

  ! LPAREN          [ reduce using rule 57 (expression_e -> identifier .) ]
  ! LBRACKET_S      [ reduce using rule 57 (expression_e -> identifier .) ]


state 53

    (35) if_statement -> IF expression . body ELSE body
    (36) if_statement -> IF expression . body
    (41) expression -> expression . and_or expression_m
    (26) body -> . statement
    (44) and_or -> . AND
    (45) and_or -> . OR
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON array_access SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) return_statement -> . RETURN SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (69) identifier -> . IDENTIFIER
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    AND             shift and go to state 43
    OR              shift and go to state 44
    ELSE            reduce using rule 25 (statement -> .)
    $end            reduce using rule 25 (statement -> .)
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    expression                     shift and go to state 18
    body                           shift and go to state 91
    and_or                         shift and go to state 42
    expression_m                   shift and go to state 25
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    identifier                     shift and go to state 20
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 54

    (37) while_statement -> WHILE expression . body
    (41) expression -> expression . and_or expression_m
    (26) body -> . statement
    (44) and_or -> . AND
    (45) and_or -> . OR
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON array_access SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) return_statement -> . RETURN SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (69) identifier -> . IDENTIFIER
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    AND             shift and go to state 43
    OR              shift and go to state 44
    ELSE            reduce using rule 25 (statement -> .)
    $end            reduce using rule 25 (statement -> .)
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    expression                     shift and go to state 18
    body                           shift and go to state 92
    and_or                         shift and go to state 42
    expression_m                   shift and go to state 25
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    identifier                     shift and go to state 20
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 55

    (38) return_statement -> RETURN expression . SEMICOLON
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    SEMICOLON       shift and go to state 93
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 56

    (39) return_statement -> RETURN SEMICOLON .

    IDENTIFIER      reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    $end            reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    LBRACKET        reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    IF              reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    NOT             reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    INTEGER         reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    STRING          reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    BOOL            reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    LBRACKET_S      reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    RBRACKET        reduce using rule 39 (return_statement -> RETURN SEMICOLON .)
    ELSE            reduce using rule 39 (return_statement -> RETURN SEMICOLON .)


state 57

    (43) expression_m -> expression_m sign . expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    expression_e                   shift and go to state 94
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 58

    (46) sign -> TIMES .

    LPAREN          reduce using rule 46 (sign -> TIMES .)
    NOT             reduce using rule 46 (sign -> TIMES .)
    IDENTIFIER      reduce using rule 46 (sign -> TIMES .)
    INTEGER         reduce using rule 46 (sign -> TIMES .)
    FLOAT           reduce using rule 46 (sign -> TIMES .)
    STRING          reduce using rule 46 (sign -> TIMES .)
    BOOL            reduce using rule 46 (sign -> TIMES .)
    LBRACKET_S      reduce using rule 46 (sign -> TIMES .)


state 59

    (47) sign -> DIV .

    LPAREN          reduce using rule 47 (sign -> DIV .)
    NOT             reduce using rule 47 (sign -> DIV .)
    IDENTIFIER      reduce using rule 47 (sign -> DIV .)
    INTEGER         reduce using rule 47 (sign -> DIV .)
    FLOAT           reduce using rule 47 (sign -> DIV .)
    STRING          reduce using rule 47 (sign -> DIV .)
    BOOL            reduce using rule 47 (sign -> DIV .)
    LBRACKET_S      reduce using rule 47 (sign -> DIV .)


state 60

    (48) sign -> PLUS .

    LPAREN          reduce using rule 48 (sign -> PLUS .)
    NOT             reduce using rule 48 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 48 (sign -> PLUS .)
    INTEGER         reduce using rule 48 (sign -> PLUS .)
    FLOAT           reduce using rule 48 (sign -> PLUS .)
    STRING          reduce using rule 48 (sign -> PLUS .)
    BOOL            reduce using rule 48 (sign -> PLUS .)
    LBRACKET_S      reduce using rule 48 (sign -> PLUS .)


state 61

    (49) sign -> MINUS .

    LPAREN          reduce using rule 49 (sign -> MINUS .)
    NOT             reduce using rule 49 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 49 (sign -> MINUS .)
    INTEGER         reduce using rule 49 (sign -> MINUS .)
    FLOAT           reduce using rule 49 (sign -> MINUS .)
    STRING          reduce using rule 49 (sign -> MINUS .)
    BOOL            reduce using rule 49 (sign -> MINUS .)
    LBRACKET_S      reduce using rule 49 (sign -> MINUS .)


state 62

    (50) sign -> MOD .

    LPAREN          reduce using rule 50 (sign -> MOD .)
    NOT             reduce using rule 50 (sign -> MOD .)
    IDENTIFIER      reduce using rule 50 (sign -> MOD .)
    INTEGER         reduce using rule 50 (sign -> MOD .)
    FLOAT           reduce using rule 50 (sign -> MOD .)
    STRING          reduce using rule 50 (sign -> MOD .)
    BOOL            reduce using rule 50 (sign -> MOD .)
    LBRACKET_S      reduce using rule 50 (sign -> MOD .)


state 63

    (51) sign -> EQUAL .

    LPAREN          reduce using rule 51 (sign -> EQUAL .)
    NOT             reduce using rule 51 (sign -> EQUAL .)
    IDENTIFIER      reduce using rule 51 (sign -> EQUAL .)
    INTEGER         reduce using rule 51 (sign -> EQUAL .)
    FLOAT           reduce using rule 51 (sign -> EQUAL .)
    STRING          reduce using rule 51 (sign -> EQUAL .)
    BOOL            reduce using rule 51 (sign -> EQUAL .)
    LBRACKET_S      reduce using rule 51 (sign -> EQUAL .)


state 64

    (52) sign -> NEQUAL .

    LPAREN          reduce using rule 52 (sign -> NEQUAL .)
    NOT             reduce using rule 52 (sign -> NEQUAL .)
    IDENTIFIER      reduce using rule 52 (sign -> NEQUAL .)
    INTEGER         reduce using rule 52 (sign -> NEQUAL .)
    FLOAT           reduce using rule 52 (sign -> NEQUAL .)
    STRING          reduce using rule 52 (sign -> NEQUAL .)
    BOOL            reduce using rule 52 (sign -> NEQUAL .)
    LBRACKET_S      reduce using rule 52 (sign -> NEQUAL .)


state 65

    (53) sign -> LT .

    LPAREN          reduce using rule 53 (sign -> LT .)
    NOT             reduce using rule 53 (sign -> LT .)
    IDENTIFIER      reduce using rule 53 (sign -> LT .)
    INTEGER         reduce using rule 53 (sign -> LT .)
    FLOAT           reduce using rule 53 (sign -> LT .)
    STRING          reduce using rule 53 (sign -> LT .)
    BOOL            reduce using rule 53 (sign -> LT .)
    LBRACKET_S      reduce using rule 53 (sign -> LT .)


state 66

    (54) sign -> LTE .

    LPAREN          reduce using rule 54 (sign -> LTE .)
    NOT             reduce using rule 54 (sign -> LTE .)
    IDENTIFIER      reduce using rule 54 (sign -> LTE .)
    INTEGER         reduce using rule 54 (sign -> LTE .)
    FLOAT           reduce using rule 54 (sign -> LTE .)
    STRING          reduce using rule 54 (sign -> LTE .)
    BOOL            reduce using rule 54 (sign -> LTE .)
    LBRACKET_S      reduce using rule 54 (sign -> LTE .)


state 67

    (55) sign -> GT .

    LPAREN          reduce using rule 55 (sign -> GT .)
    NOT             reduce using rule 55 (sign -> GT .)
    IDENTIFIER      reduce using rule 55 (sign -> GT .)
    INTEGER         reduce using rule 55 (sign -> GT .)
    FLOAT           reduce using rule 55 (sign -> GT .)
    STRING          reduce using rule 55 (sign -> GT .)
    BOOL            reduce using rule 55 (sign -> GT .)
    LBRACKET_S      reduce using rule 55 (sign -> GT .)


state 68

    (56) sign -> GTE .

    LPAREN          reduce using rule 56 (sign -> GTE .)
    NOT             reduce using rule 56 (sign -> GTE .)
    IDENTIFIER      reduce using rule 56 (sign -> GTE .)
    INTEGER         reduce using rule 56 (sign -> GTE .)
    FLOAT           reduce using rule 56 (sign -> GTE .)
    STRING          reduce using rule 56 (sign -> GTE .)
    BOOL            reduce using rule 56 (sign -> GTE .)
    LBRACKET_S      reduce using rule 56 (sign -> GTE .)


state 69

    (63) expression_e -> LPAREN expression . RPAREN
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    RPAREN          shift and go to state 95
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 70

    (64) expression_e -> NOT expression .
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    TIMES           reduce using rule 64 (expression_e -> NOT expression .)
    DIV             reduce using rule 64 (expression_e -> NOT expression .)
    PLUS            reduce using rule 64 (expression_e -> NOT expression .)
    MINUS           reduce using rule 64 (expression_e -> NOT expression .)
    MOD             reduce using rule 64 (expression_e -> NOT expression .)
    EQUAL           reduce using rule 64 (expression_e -> NOT expression .)
    NEQUAL          reduce using rule 64 (expression_e -> NOT expression .)
    LT              reduce using rule 64 (expression_e -> NOT expression .)
    LTE             reduce using rule 64 (expression_e -> NOT expression .)
    GT              reduce using rule 64 (expression_e -> NOT expression .)
    GTE             reduce using rule 64 (expression_e -> NOT expression .)
    SEMICOLON       reduce using rule 64 (expression_e -> NOT expression .)
    RBRACKET_S      reduce using rule 64 (expression_e -> NOT expression .)
    LBRACKET        reduce using rule 64 (expression_e -> NOT expression .)
    IF              reduce using rule 64 (expression_e -> NOT expression .)
    WHILE           reduce using rule 64 (expression_e -> NOT expression .)
    RETURN          reduce using rule 64 (expression_e -> NOT expression .)
    IDENTIFIER      reduce using rule 64 (expression_e -> NOT expression .)
    LPAREN          reduce using rule 64 (expression_e -> NOT expression .)
    NOT             reduce using rule 64 (expression_e -> NOT expression .)
    INTEGER         reduce using rule 64 (expression_e -> NOT expression .)
    FLOAT           reduce using rule 64 (expression_e -> NOT expression .)
    STRING          reduce using rule 64 (expression_e -> NOT expression .)
    BOOL            reduce using rule 64 (expression_e -> NOT expression .)
    LBRACKET_S      reduce using rule 64 (expression_e -> NOT expression .)
    ELSE            reduce using rule 64 (expression_e -> NOT expression .)
    $end            reduce using rule 64 (expression_e -> NOT expression .)
    RBRACKET        reduce using rule 64 (expression_e -> NOT expression .)
    RPAREN          reduce using rule 64 (expression_e -> NOT expression .)
    COMMA           reduce using rule 64 (expression_e -> NOT expression .)
    AND             shift and go to state 43
    OR              shift and go to state 44

  ! AND             [ reduce using rule 64 (expression_e -> NOT expression .) ]
  ! OR              [ reduce using rule 64 (expression_e -> NOT expression .) ]

    and_or                         shift and go to state 42

state 71

    (8) function_declaration -> identifier COLON type . LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON type . SEMICOLON
    (6) variable_declaration -> identifier COLON type . ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier COLON type . LPAREN parameter_list RPAREN

    LPAREN          shift and go to state 96
    SEMICOLON       shift and go to state 97
    ASSIGNMENT      shift and go to state 98


state 72

    (75) type -> TINTEGER .

    LPAREN          reduce using rule 75 (type -> TINTEGER .)
    SEMICOLON       reduce using rule 75 (type -> TINTEGER .)
    ASSIGNMENT      reduce using rule 75 (type -> TINTEGER .)
    RBRACKET_S      reduce using rule 75 (type -> TINTEGER .)
    COMMA           reduce using rule 75 (type -> TINTEGER .)
    RPAREN          reduce using rule 75 (type -> TINTEGER .)


state 73

    (76) type -> TFLOAT .

    LPAREN          reduce using rule 76 (type -> TFLOAT .)
    SEMICOLON       reduce using rule 76 (type -> TFLOAT .)
    ASSIGNMENT      reduce using rule 76 (type -> TFLOAT .)
    RBRACKET_S      reduce using rule 76 (type -> TFLOAT .)
    COMMA           reduce using rule 76 (type -> TFLOAT .)
    RPAREN          reduce using rule 76 (type -> TFLOAT .)


state 74

    (77) type -> TSTRING .

    LPAREN          reduce using rule 77 (type -> TSTRING .)
    SEMICOLON       reduce using rule 77 (type -> TSTRING .)
    ASSIGNMENT      reduce using rule 77 (type -> TSTRING .)
    RBRACKET_S      reduce using rule 77 (type -> TSTRING .)
    COMMA           reduce using rule 77 (type -> TSTRING .)
    RPAREN          reduce using rule 77 (type -> TSTRING .)


state 75

    (78) type -> TBOOL .

    LPAREN          reduce using rule 78 (type -> TBOOL .)
    SEMICOLON       reduce using rule 78 (type -> TBOOL .)
    ASSIGNMENT      reduce using rule 78 (type -> TBOOL .)
    RBRACKET_S      reduce using rule 78 (type -> TBOOL .)
    COMMA           reduce using rule 78 (type -> TBOOL .)
    RPAREN          reduce using rule 78 (type -> TBOOL .)


state 76

    (79) type -> TVOID .

    LPAREN          reduce using rule 79 (type -> TVOID .)
    SEMICOLON       reduce using rule 79 (type -> TVOID .)
    ASSIGNMENT      reduce using rule 79 (type -> TVOID .)
    RBRACKET_S      reduce using rule 79 (type -> TVOID .)
    COMMA           reduce using rule 79 (type -> TVOID .)
    RPAREN          reduce using rule 79 (type -> TVOID .)


state 77

    (80) type -> LBRACKET_S . type RBRACKET_S
    (75) type -> . TINTEGER
    (76) type -> . TFLOAT
    (77) type -> . TSTRING
    (78) type -> . TBOOL
    (79) type -> . TVOID
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 72
    TFLOAT          shift and go to state 73
    TSTRING         shift and go to state 74
    TBOOL           shift and go to state 75
    TVOID           shift and go to state 76
    LBRACKET_S      shift and go to state 77

    type                           shift and go to state 99

state 78

    (41) expression -> expression and_or expression_m .
    (43) expression_m -> expression_m . sign expression_e
    (46) sign -> . TIMES
    (47) sign -> . DIV
    (48) sign -> . PLUS
    (49) sign -> . MINUS
    (50) sign -> . MOD
    (51) sign -> . EQUAL
    (52) sign -> . NEQUAL
    (53) sign -> . LT
    (54) sign -> . LTE
    (55) sign -> . GT
    (56) sign -> . GTE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
    SEMICOLON       reduce using rule 41 (expression -> expression and_or expression_m .)
    AND             reduce using rule 41 (expression -> expression and_or expression_m .)
    OR              reduce using rule 41 (expression -> expression and_or expression_m .)
    RBRACKET_S      reduce using rule 41 (expression -> expression and_or expression_m .)
    LBRACKET        reduce using rule 41 (expression -> expression and_or expression_m .)
    IF              reduce using rule 41 (expression -> expression and_or expression_m .)
    WHILE           reduce using rule 41 (expression -> expression and_or expression_m .)
    RETURN          reduce using rule 41 (expression -> expression and_or expression_m .)
    IDENTIFIER      reduce using rule 41 (expression -> expression and_or expression_m .)
    LPAREN          reduce using rule 41 (expression -> expression and_or expression_m .)
    NOT             reduce using rule 41 (expression -> expression and_or expression_m .)
    INTEGER         reduce using rule 41 (expression -> expression and_or expression_m .)
    FLOAT           reduce using rule 41 (expression -> expression and_or expression_m .)
    STRING          reduce using rule 41 (expression -> expression and_or expression_m .)
    BOOL            reduce using rule 41 (expression -> expression and_or expression_m .)
    LBRACKET_S      reduce using rule 41 (expression -> expression and_or expression_m .)
    ELSE            reduce using rule 41 (expression -> expression and_or expression_m .)
    $end            reduce using rule 41 (expression -> expression and_or expression_m .)
    RBRACKET        reduce using rule 41 (expression -> expression and_or expression_m .)
    RPAREN          reduce using rule 41 (expression -> expression and_or expression_m .)
    COMMA           reduce using rule 41 (expression -> expression and_or expression_m .)
    TIMES           shift and go to state 58
    DIV             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    MOD             shift and go to state 62
    EQUAL           shift and go to state 63
    NEQUAL          shift and go to state 64
    LT              shift and go to state 65
    LTE             shift and go to state 66
    GT              shift and go to state 67
    GTE             shift and go to state 68

  ! TIMES           [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! DIV             [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! PLUS            [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! MOD             [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! EQUAL           [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! NEQUAL          [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! LT              [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! LTE             [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! GT              [ reduce using rule 41 (expression -> expression and_or expression_m .) ]
  ! GTE             [ reduce using rule 41 (expression -> expression and_or expression_m .) ]

    sign                           shift and go to state 57

state 79

    (14) statement_part -> LBRACKET statement_sequence RBRACKET .

    IDENTIFIER      reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    $end            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LBRACKET        reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    IF              reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    WHILE           reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RETURN          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LPAREN          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    NOT             reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    INTEGER         reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    FLOAT           reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    STRING          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    BOOL            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LBRACKET_S      reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RBRACKET        reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    ELSE            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)


state 80

    (15) statement_sequence -> statement statement_sequence .

    RBRACKET        reduce using rule 15 (statement_sequence -> statement statement_sequence .)


state 81

    (31) local_variable_declaration -> identifier COLON type . ASSIGNMENT expression SEMICOLON

    ASSIGNMENT      shift and go to state 100


state 82

    (34) array_def -> identifier COLON array_access . SEMICOLON

    SEMICOLON       shift and go to state 101


state 83

    (80) type -> LBRACKET_S . type RBRACKET_S
    (81) array_access -> LBRACKET_S . type RBRACKET_S
    (75) type -> . TINTEGER
    (76) type -> . TFLOAT
    (77) type -> . TSTRING
    (78) type -> . TBOOL
    (79) type -> . TVOID
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 72
    TFLOAT          shift and go to state 73
    TSTRING         shift and go to state 74
    TBOOL           shift and go to state 75
    TVOID           shift and go to state 76
    LBRACKET_S      shift and go to state 77

    type                           shift and go to state 102

state 84

    (32) assignment_statement -> identifier ASSIGNMENT expression . SEMICOLON
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    SEMICOLON       shift and go to state 103
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 85

    (33) assignment_statement -> identifier LBRACKET_S expression . RBRACKET_S ASSIGNMENT expression SEMICOLON
    (68) array_call -> identifier LBRACKET_S expression . RBRACKET_S
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    RBRACKET_S      shift and go to state 104
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 86

    (67) function_call -> identifier LPAREN param_list . RPAREN

    RPAREN          shift and go to state 105


state 87

    (27) param_list -> param . COMMA param_list
    (28) param_list -> param .

    COMMA           shift and go to state 106
    RPAREN          reduce using rule 28 (param_list -> param .)


state 88

    (30) param -> expression .
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    COMMA           reduce using rule 30 (param -> expression .)
    RPAREN          reduce using rule 30 (param -> expression .)
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 89

    (74) array -> LBRACKET_S expression RBRACKET_S .

    TIMES           reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    RBRACKET_S      reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    LBRACKET        reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    IF              reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    WHILE           reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    RETURN          reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    IDENTIFIER      reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    LPAREN          reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    NOT             reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    INTEGER         reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    FLOAT           reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    STRING          reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    BOOL            reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    LBRACKET_S      reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    ELSE            reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    $end            reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    RBRACKET        reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    RPAREN          reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)
    COMMA           reduce using rule 74 (array -> LBRACKET_S expression RBRACKET_S .)


state 90

    (68) array_call -> identifier LBRACKET_S . expression RBRACKET_S
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 107
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 91

    (35) if_statement -> IF expression body . ELSE body
    (36) if_statement -> IF expression body .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 108
    IDENTIFIER      reduce using rule 36 (if_statement -> IF expression body .)
    $end            reduce using rule 36 (if_statement -> IF expression body .)
    LBRACKET        reduce using rule 36 (if_statement -> IF expression body .)
    IF              reduce using rule 36 (if_statement -> IF expression body .)
    WHILE           reduce using rule 36 (if_statement -> IF expression body .)
    RETURN          reduce using rule 36 (if_statement -> IF expression body .)
    LPAREN          reduce using rule 36 (if_statement -> IF expression body .)
    NOT             reduce using rule 36 (if_statement -> IF expression body .)
    INTEGER         reduce using rule 36 (if_statement -> IF expression body .)
    FLOAT           reduce using rule 36 (if_statement -> IF expression body .)
    STRING          reduce using rule 36 (if_statement -> IF expression body .)
    BOOL            reduce using rule 36 (if_statement -> IF expression body .)
    LBRACKET_S      reduce using rule 36 (if_statement -> IF expression body .)
    RBRACKET        reduce using rule 36 (if_statement -> IF expression body .)

  ! ELSE            [ reduce using rule 36 (if_statement -> IF expression body .) ]


state 92

    (37) while_statement -> WHILE expression body .

    IDENTIFIER      reduce using rule 37 (while_statement -> WHILE expression body .)
    $end            reduce using rule 37 (while_statement -> WHILE expression body .)
    LBRACKET        reduce using rule 37 (while_statement -> WHILE expression body .)
    IF              reduce using rule 37 (while_statement -> WHILE expression body .)
    WHILE           reduce using rule 37 (while_statement -> WHILE expression body .)
    RETURN          reduce using rule 37 (while_statement -> WHILE expression body .)
    LPAREN          reduce using rule 37 (while_statement -> WHILE expression body .)
    NOT             reduce using rule 37 (while_statement -> WHILE expression body .)
    INTEGER         reduce using rule 37 (while_statement -> WHILE expression body .)
    FLOAT           reduce using rule 37 (while_statement -> WHILE expression body .)
    STRING          reduce using rule 37 (while_statement -> WHILE expression body .)
    BOOL            reduce using rule 37 (while_statement -> WHILE expression body .)
    LBRACKET_S      reduce using rule 37 (while_statement -> WHILE expression body .)
    RBRACKET        reduce using rule 37 (while_statement -> WHILE expression body .)
    ELSE            reduce using rule 37 (while_statement -> WHILE expression body .)


state 93

    (38) return_statement -> RETURN expression SEMICOLON .

    IDENTIFIER      reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    LBRACKET        reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    BOOL            reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    LBRACKET_S      reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    RBRACKET        reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 38 (return_statement -> RETURN expression SEMICOLON .)


state 94

    (43) expression_m -> expression_m sign expression_e .

    TIMES           reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    DIV             reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    PLUS            reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    MINUS           reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    MOD             reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    EQUAL           reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    NEQUAL          reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    LT              reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    LTE             reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    GT              reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    GTE             reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    SEMICOLON       reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    AND             reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    OR              reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    RBRACKET_S      reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    LBRACKET        reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    IF              reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    WHILE           reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    RETURN          reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    IDENTIFIER      reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    LPAREN          reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    NOT             reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    INTEGER         reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    FLOAT           reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    STRING          reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    BOOL            reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    LBRACKET_S      reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    ELSE            reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    $end            reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    RBRACKET        reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    RPAREN          reduce using rule 43 (expression_m -> expression_m sign expression_e .)
    COMMA           reduce using rule 43 (expression_m -> expression_m sign expression_e .)


state 95

    (63) expression_e -> LPAREN expression RPAREN .

    TIMES           reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    DIV             reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    MOD             reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    NEQUAL          reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    LT              reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    LTE             reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    GT              reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    GTE             reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    AND             reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    OR              reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    RBRACKET_S      reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    IF              reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    NOT             reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    STRING          reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    BOOL            reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    LBRACKET_S      reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    $end            reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 63 (expression_e -> LPAREN expression RPAREN .)


state 96

    (8) function_declaration -> identifier COLON type LPAREN . parameter_list RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN . parameter_list RPAREN
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter_list -> .
    (13) parameter -> . identifier COLON type
    (69) identifier -> . IDENTIFIER

    RPAREN          reduce using rule 12 (parameter_list -> .)
    IDENTIFIER      shift and go to state 7

    identifier                     shift and go to state 109
    parameter_list                 shift and go to state 110
    parameter                      shift and go to state 111

state 97

    (5) variable_declaration -> identifier COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)
    $end            reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)


state 98

    (6) variable_declaration -> identifier COLON type ASSIGNMENT . expression SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 112
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 99

    (80) type -> LBRACKET_S type . RBRACKET_S

    RBRACKET_S      shift and go to state 113


state 100

    (31) local_variable_declaration -> identifier COLON type ASSIGNMENT . expression SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 114
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 101

    (34) array_def -> identifier COLON array_access SEMICOLON .

    IDENTIFIER      reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    $end            reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    LBRACKET        reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    IF              reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    WHILE           reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    RETURN          reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    LPAREN          reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    NOT             reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    INTEGER         reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    FLOAT           reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    STRING          reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    BOOL            reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    LBRACKET_S      reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    RBRACKET        reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)
    ELSE            reduce using rule 34 (array_def -> identifier COLON array_access SEMICOLON .)


state 102

    (80) type -> LBRACKET_S type . RBRACKET_S
    (81) array_access -> LBRACKET_S type . RBRACKET_S

    RBRACKET_S      shift and go to state 115


state 103

    (32) assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 32 (assignment_statement -> identifier ASSIGNMENT expression SEMICOLON .)


state 104

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S . ASSIGNMENT expression SEMICOLON
    (68) array_call -> identifier LBRACKET_S expression RBRACKET_S .

    ASSIGNMENT      shift and go to state 116
    TIMES           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)


state 105

    (67) function_call -> identifier LPAREN param_list RPAREN .

    TIMES           reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    DIV             reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    PLUS            reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    MINUS           reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    MOD             reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    EQUAL           reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    NEQUAL          reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    LT              reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    LTE             reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    GT              reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    GTE             reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    SEMICOLON       reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    AND             reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    OR              reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    RBRACKET_S      reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    LBRACKET        reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    IF              reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    WHILE           reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    RETURN          reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    IDENTIFIER      reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    LPAREN          reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    NOT             reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    INTEGER         reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    FLOAT           reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    STRING          reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    BOOL            reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    LBRACKET_S      reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    ELSE            reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    $end            reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    RBRACKET        reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    RPAREN          reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)
    COMMA           reduce using rule 67 (function_call -> identifier LPAREN param_list RPAREN .)


state 106

    (27) param_list -> param COMMA . param_list
    (27) param_list -> . param COMMA param_list
    (28) param_list -> . param
    (29) param_list -> .
    (30) param -> . expression
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    RPAREN          reduce using rule 29 (param_list -> .)
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    param                          shift and go to state 87
    param_list                     shift and go to state 117
    expression                     shift and go to state 88
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    identifier                     shift and go to state 52
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 107

    (68) array_call -> identifier LBRACKET_S expression . RBRACKET_S
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    RBRACKET_S      shift and go to state 118
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 108

    (35) if_statement -> IF expression body ELSE . body
    (26) body -> . statement
    (17) statement -> . statement_part
    (18) statement -> . local_variable_declaration
    (19) statement -> . assignment_statement
    (20) statement -> . array_def
    (21) statement -> . if_statement
    (22) statement -> . while_statement
    (23) statement -> . return_statement
    (24) statement -> . expression SEMICOLON
    (25) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (31) local_variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (32) assignment_statement -> . identifier ASSIGNMENT expression SEMICOLON
    (33) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (34) array_def -> . identifier COLON array_access SEMICOLON
    (35) if_statement -> . IF expression body ELSE body
    (36) if_statement -> . IF expression body
    (37) while_statement -> . WHILE expression body
    (38) return_statement -> . RETURN expression SEMICOLON
    (39) return_statement -> . RETURN SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (69) identifier -> . IDENTIFIER
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    ELSE            reduce using rule 25 (statement -> .)
    $end            reduce using rule 25 (statement -> .)
    RBRACKET        reduce using rule 25 (statement -> .)
    LBRACKET        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    RETURN          shift and go to state 24
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

  ! IDENTIFIER      [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 25 (statement -> .) ]
  ! IF              [ reduce using rule 25 (statement -> .) ]
  ! WHILE           [ reduce using rule 25 (statement -> .) ]
  ! RETURN          [ reduce using rule 25 (statement -> .) ]
  ! LPAREN          [ reduce using rule 25 (statement -> .) ]
  ! NOT             [ reduce using rule 25 (statement -> .) ]
  ! INTEGER         [ reduce using rule 25 (statement -> .) ]
  ! FLOAT           [ reduce using rule 25 (statement -> .) ]
  ! STRING          [ reduce using rule 25 (statement -> .) ]
  ! BOOL            [ reduce using rule 25 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 25 (statement -> .) ]

    expression                     shift and go to state 18
    body                           shift and go to state 119
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    local_variable_declaration     shift and go to state 12
    assignment_statement           shift and go to state 13
    array_def                      shift and go to state 14
    if_statement                   shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    identifier                     shift and go to state 20
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 109

    (13) parameter -> identifier . COLON type

    COLON           shift and go to state 120


state 110

    (8) function_declaration -> identifier COLON type LPAREN parameter_list . RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list . RPAREN

    RPAREN          shift and go to state 121


state 111

    (10) parameter_list -> parameter . COMMA parameter_list
    (11) parameter_list -> parameter .

    COMMA           shift and go to state 122
    RPAREN          reduce using rule 11 (parameter_list -> parameter .)


state 112

    (6) variable_declaration -> identifier COLON type ASSIGNMENT expression . SEMICOLON
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    SEMICOLON       shift and go to state 123
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 113

    (80) type -> LBRACKET_S type RBRACKET_S .

    LPAREN          reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    SEMICOLON       reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    ASSIGNMENT      reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    RBRACKET_S      reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    COMMA           reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    RPAREN          reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)


state 114

    (31) local_variable_declaration -> identifier COLON type ASSIGNMENT expression . SEMICOLON
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    SEMICOLON       shift and go to state 124
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 115

    (80) type -> LBRACKET_S type RBRACKET_S .
    (81) array_access -> LBRACKET_S type RBRACKET_S .

    ASSIGNMENT      reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    SEMICOLON       reduce using rule 81 (array_access -> LBRACKET_S type RBRACKET_S .)


state 116

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT . expression SEMICOLON
    (40) expression -> . expression_m
    (41) expression -> . expression and_or expression_m
    (42) expression_m -> . expression_e
    (43) expression_m -> . expression_m sign expression_e
    (57) expression_e -> . identifier
    (58) expression_e -> . integer
    (59) expression_e -> . float
    (60) expression_e -> . string
    (61) expression_e -> . bool
    (62) expression_e -> . array
    (63) expression_e -> . LPAREN expression RPAREN
    (64) expression_e -> . NOT expression
    (65) expression_e -> . function_call
    (66) expression_e -> . array_call
    (69) identifier -> . IDENTIFIER
    (70) integer -> . INTEGER
    (71) float -> . FLOAT
    (72) string -> . STRING
    (73) bool -> . BOOL
    (74) array -> . LBRACKET_S expression RBRACKET_S
    (67) function_call -> . identifier LPAREN param_list RPAREN
    (68) array_call -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 32
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    LBRACKET_S      shift and go to state 21

    identifier                     shift and go to state 52
    expression                     shift and go to state 125
    expression_m                   shift and go to state 25
    expression_e                   shift and go to state 26
    integer                        shift and go to state 27
    float                          shift and go to state 28
    string                         shift and go to state 29
    bool                           shift and go to state 30
    array                          shift and go to state 31
    function_call                  shift and go to state 34
    array_call                     shift and go to state 35

state 117

    (27) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 27 (param_list -> param COMMA param_list .)


state 118

    (68) array_call -> identifier LBRACKET_S expression RBRACKET_S .

    TIMES           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RBRACKET_S      reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LBRACKET        reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    IF              reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    WHILE           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RETURN          reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    IDENTIFIER      reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LPAREN          reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    NOT             reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    INTEGER         reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    FLOAT           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    STRING          reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    BOOL            reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    LBRACKET_S      reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    ELSE            reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    $end            reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RBRACKET        reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    RPAREN          reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)
    COMMA           reduce using rule 68 (array_call -> identifier LBRACKET_S expression RBRACKET_S .)


state 119

    (35) if_statement -> IF expression body ELSE body .

    IDENTIFIER      reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    $end            reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    LBRACKET        reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    IF              reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    WHILE           reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    RETURN          reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    LPAREN          reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    NOT             reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    INTEGER         reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    FLOAT           reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    STRING          reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    BOOL            reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    LBRACKET_S      reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    RBRACKET        reduce using rule 35 (if_statement -> IF expression body ELSE body .)
    ELSE            reduce using rule 35 (if_statement -> IF expression body ELSE body .)


state 120

    (13) parameter -> identifier COLON . type
    (75) type -> . TINTEGER
    (76) type -> . TFLOAT
    (77) type -> . TSTRING
    (78) type -> . TBOOL
    (79) type -> . TVOID
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 72
    TFLOAT          shift and go to state 73
    TSTRING         shift and go to state 74
    TBOOL           shift and go to state 75
    TVOID           shift and go to state 76
    LBRACKET_S      shift and go to state 77

    type                           shift and go to state 126

state 121

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN . SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list RPAREN .

    SEMICOLON       shift and go to state 127
    LBRACKET        reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IF              reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    RETURN          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IDENTIFIER      reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    LPAREN          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    NOT             reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    INTEGER         reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    FLOAT           reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    STRING          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    BOOL            reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    LBRACKET_S      reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    $end            reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)


state 122

    (10) parameter_list -> parameter COMMA . parameter_list
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter_list -> .
    (13) parameter -> . identifier COLON type
    (69) identifier -> . IDENTIFIER

    RPAREN          reduce using rule 12 (parameter_list -> .)
    IDENTIFIER      shift and go to state 7

    parameter                      shift and go to state 111
    parameter_list                 shift and go to state 128
    identifier                     shift and go to state 109

state 123

    (6) variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)


state 124

    (31) local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 31 (local_variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)


state 125

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression . SEMICOLON
    (41) expression -> expression . and_or expression_m
    (44) and_or -> . AND
    (45) and_or -> . OR

    SEMICOLON       shift and go to state 129
    AND             shift and go to state 43
    OR              shift and go to state 44

    and_or                         shift and go to state 42

state 126

    (13) parameter -> identifier COLON type .

    COMMA           reduce using rule 13 (parameter -> identifier COLON type .)
    RPAREN          reduce using rule 13 (parameter -> identifier COLON type .)


state 127

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)
    $end            reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)


state 128

    (10) parameter_list -> parameter COMMA parameter_list .

    RPAREN          reduce using rule 10 (parameter_list -> parameter COMMA parameter_list .)


state 129

    (33) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 33 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 5 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 19 resolved as shift
WARNING: shift/reduce conflict for IF in state 19 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 19 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 19 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 19 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 19 resolved as shift
WARNING: shift/reduce conflict for NOT in state 19 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 19 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 19 resolved as shift
WARNING: shift/reduce conflict for STRING in state 19 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 19 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 19 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 25 resolved as shift
WARNING: shift/reduce conflict for DIV in state 25 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 25 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 25 resolved as shift
WARNING: shift/reduce conflict for MOD in state 25 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 25 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 25 resolved as shift
WARNING: shift/reduce conflict for LT in state 25 resolved as shift
WARNING: shift/reduce conflict for LTE in state 25 resolved as shift
WARNING: shift/reduce conflict for GT in state 25 resolved as shift
WARNING: shift/reduce conflict for GTE in state 25 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 46 resolved as shift
WARNING: shift/reduce conflict for IF in state 46 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 46 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 46 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 46 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 46 resolved as shift
WARNING: shift/reduce conflict for NOT in state 46 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 46 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 46 resolved as shift
WARNING: shift/reduce conflict for STRING in state 46 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 46 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 46 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 52 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 52 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 53 resolved as shift
WARNING: shift/reduce conflict for IF in state 53 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 53 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 53 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 53 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 53 resolved as shift
WARNING: shift/reduce conflict for NOT in state 53 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 53 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 53 resolved as shift
WARNING: shift/reduce conflict for STRING in state 53 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 54 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 54 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 54 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 54 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 54 resolved as shift
WARNING: shift/reduce conflict for NOT in state 54 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 54 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 54 resolved as shift
WARNING: shift/reduce conflict for STRING in state 54 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 54 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 54 resolved as shift
WARNING: shift/reduce conflict for AND in state 70 resolved as shift
WARNING: shift/reduce conflict for OR in state 70 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 78 resolved as shift
WARNING: shift/reduce conflict for DIV in state 78 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MOD in state 78 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for LT in state 78 resolved as shift
WARNING: shift/reduce conflict for LTE in state 78 resolved as shift
WARNING: shift/reduce conflict for GT in state 78 resolved as shift
WARNING: shift/reduce conflict for GTE in state 78 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 91 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 108 resolved as shift
WARNING: shift/reduce conflict for IF in state 108 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 108 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 108 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 108 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT in state 108 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 108 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 108 resolved as shift
WARNING: shift/reduce conflict for STRING in state 108 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 108 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 108 resolved as shift
WARNING: reduce/reduce conflict in state 46 resolved using rule (statement_sequence -> statement)
WARNING: rejected rule (statement -> <empty>) in state 46
