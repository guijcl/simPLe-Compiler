Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    COMMENT
    TVOID
    VOID

Grammar

Rule 0     S' -> definition_sequence
Rule 1     definition_sequence -> definition definition_sequence
Rule 2     definition_sequence -> definition
Rule 3     definition -> function_declaration
Rule 4     definition -> variable_declaration
Rule 5     variable_declaration -> identifier COLON type SEMICOLON
Rule 6     variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON
Rule 7     function_declaration -> function_heading body
Rule 8     function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
Rule 9     function_heading -> identifier COLON type LPAREN parameter_list RPAREN
Rule 10    parameter_list -> parameter COMMA parameter_list
Rule 11    parameter_list -> parameter
Rule 12    parameter_list -> <empty>
Rule 13    parameter -> identifier COLON type
Rule 14    statement_part -> LBRACKET statement_sequence RBRACKET
Rule 15    statement_sequence -> statement statement_sequence
Rule 16    statement_sequence -> statement
Rule 17    statement -> statement_part
Rule 18    statement -> assignment_statement
Rule 19    statement -> array_def
Rule 20    statement -> if_statement
Rule 21    statement -> while_statement
Rule 22    statement -> return_statement
Rule 23    statement -> function_call
Rule 24    statement -> array_call
Rule 25    statement -> expression SEMICOLON
Rule 26    statement -> <empty>
Rule 27    body -> statement
Rule 28    function_call -> identifier LPAREN param_list RPAREN SEMICOLON
Rule 29    array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON
Rule 30    param_list -> param COMMA param_list
Rule 31    param_list -> param
Rule 32    param_list -> <empty>
Rule 33    param -> expression
Rule 34    assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON
Rule 35    assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
Rule 36    array_def -> identifier COLON type SEMICOLON
Rule 37    if_statement -> IF expression body ELSE body
Rule 38    if_statement -> IF expression body
Rule 39    while_statement -> WHILE expression body
Rule 40    return_statement -> RETURN expression SEMICOLON
Rule 41    expression -> expression_m
Rule 42    expression -> expression and_or expression_m
Rule 43    expression_m -> expression_e
Rule 44    expression_m -> expression_m sign expression_e
Rule 45    and_or -> AND
Rule 46    and_or -> OR
Rule 47    sign -> TIMES
Rule 48    sign -> DIV
Rule 49    sign -> PLUS
Rule 50    sign -> MINUS
Rule 51    sign -> MOD
Rule 52    sign -> EQUAL
Rule 53    sign -> NEQUAL
Rule 54    sign -> LT
Rule 55    sign -> LTE
Rule 56    sign -> GT
Rule 57    sign -> GTE
Rule 58    expression_e -> identifier
Rule 59    expression_e -> integer
Rule 60    expression_e -> float
Rule 61    expression_e -> string
Rule 62    expression_e -> bool
Rule 63    expression_e -> array
Rule 64    expression_e -> LPAREN expression RPAREN
Rule 65    expression_e -> NOT expression
Rule 66    expression_e -> function_call_inline
Rule 67    expression_e -> array_call_inline
Rule 68    function_call_inline -> identifier LPAREN param_list RPAREN
Rule 69    array_call_inline -> identifier LBRACKET_S expression RBRACKET_S
Rule 70    identifier -> IDENTIFIER
Rule 71    integer -> INTEGER
Rule 72    float -> FLOAT
Rule 73    string -> STRING
Rule 74    bool -> BOOL
Rule 75    array -> LBRACKET_S expression RBRACKET_S
Rule 76    type -> TINTEGER
Rule 77    type -> TFLOAT
Rule 78    type -> TSTRING
Rule 79    type -> TBOOL
Rule 80    type -> LBRACKET_S type RBRACKET_S

Terminals, with rules where they appear

AND                  : 45
ARRAY                : 
ASSIGNMENT           : 6 34 35
BOOL                 : 74
COLON                : 5 6 8 9 13 34 36
COMMA                : 10 30
COMMENT              : 
DIV                  : 48
ELSE                 : 37
EQUAL                : 52
FLOAT                : 72
GT                   : 56
GTE                  : 57
IDENTIFIER           : 70
IF                   : 37 38
INTEGER              : 71
LBRACKET             : 14
LBRACKET_S           : 29 35 69 75 80
LPAREN               : 8 9 28 64 68
LT                   : 54
LTE                  : 55
MINUS                : 50
MOD                  : 51
NEQUAL               : 53
NOT                  : 65
OR                   : 46
PLUS                 : 49
RBRACKET             : 14
RBRACKET_S           : 29 35 69 75 80
RETURN               : 40
RPAREN               : 8 9 28 64 68
SEMICOLON            : 5 6 8 25 28 29 34 35 36 40
STRING               : 73
TBOOL                : 79
TFLOAT               : 77
TIMES                : 47
TINTEGER             : 76
TSTRING              : 78
TVOID                : 
VOID                 : 
WHILE                : 39
error                : 

Nonterminals, with rules where they appear

and_or               : 42
array                : 63
array_call           : 24
array_call_inline    : 67
array_def            : 19
assignment_statement : 18
body                 : 7 37 37 38 39
bool                 : 62
definition           : 1 2
definition_sequence  : 1 0
expression           : 6 25 29 33 34 35 35 37 38 39 40 42 64 65 69 75
expression_e         : 43 44
expression_m         : 41 42 44
float                : 60
function_call        : 23
function_call_inline : 66
function_declaration : 3
function_heading     : 7
identifier           : 5 6 8 9 13 28 29 34 35 36 58 68 69
if_statement         : 20
integer              : 59
param                : 30 31
param_list           : 28 30 68
parameter            : 10 11
parameter_list       : 8 9 10
return_statement     : 22
sign                 : 44
statement            : 15 16 27
statement_part       : 17
statement_sequence   : 14 15
string               : 61
type                 : 5 6 8 9 13 34 36 80
variable_declaration : 4
while_statement      : 21

Parsing method: LALR

state 0

    (0) S' -> . definition_sequence
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (70) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 7

    definition_sequence            shift and go to state 1
    definition                     shift and go to state 2
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 1

    (0) S' -> definition_sequence .



state 2

    (1) definition_sequence -> definition . definition_sequence
    (2) definition_sequence -> definition .
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (70) identifier -> . IDENTIFIER

    $end            reduce using rule 2 (definition_sequence -> definition .)
    IDENTIFIER      shift and go to state 7

    definition                     shift and go to state 2
    definition_sequence            shift and go to state 8
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 3

    (3) definition -> function_declaration .

    IDENTIFIER      reduce using rule 3 (definition -> function_declaration .)
    $end            reduce using rule 3 (definition -> function_declaration .)


state 4

    (4) definition -> variable_declaration .

    IDENTIFIER      reduce using rule 4 (definition -> variable_declaration .)
    $end            reduce using rule 4 (definition -> variable_declaration .)


state 5

    (7) function_declaration -> function_heading . body
    (27) body -> . statement
    (17) statement -> . statement_part
    (18) statement -> . assignment_statement
    (19) statement -> . array_def
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . return_statement
    (23) statement -> . function_call
    (24) statement -> . array_call
    (25) statement -> . expression SEMICOLON
    (26) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (34) assignment_statement -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (35) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (36) array_def -> . identifier COLON type SEMICOLON
    (37) if_statement -> . IF expression body ELSE body
    (38) if_statement -> . IF expression body
    (39) while_statement -> . WHILE expression body
    (40) return_statement -> . RETURN expression SEMICOLON
    (28) function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (29) array_call -> . identifier LBRACKET_S expression RBRACKET_S SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (70) identifier -> . IDENTIFIER
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    $end            reduce using rule 26 (statement -> .)
    LBRACKET        shift and go to state 20
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    RETURN          shift and go to state 25
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

  ! IDENTIFIER      [ reduce using rule 26 (statement -> .) ]

    body                           shift and go to state 9
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    array_def                      shift and go to state 13
    if_statement                   shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_call                  shift and go to state 17
    array_call                     shift and go to state 18
    expression                     shift and go to state 19
    identifier                     shift and go to state 21
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 6

    (8) function_declaration -> identifier . COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier . COLON type SEMICOLON
    (6) variable_declaration -> identifier . COLON type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier . COLON type LPAREN parameter_list RPAREN

    COLON           shift and go to state 41


state 7

    (70) identifier -> IDENTIFIER .

    COLON           reduce using rule 70 (identifier -> IDENTIFIER .)
    LBRACKET_S      reduce using rule 70 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 70 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 70 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 70 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 70 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 70 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 70 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 70 (identifier -> IDENTIFIER .)
    NEQUAL          reduce using rule 70 (identifier -> IDENTIFIER .)
    LT              reduce using rule 70 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 70 (identifier -> IDENTIFIER .)
    GT              reduce using rule 70 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 70 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 70 (identifier -> IDENTIFIER .)
    AND             reduce using rule 70 (identifier -> IDENTIFIER .)
    OR              reduce using rule 70 (identifier -> IDENTIFIER .)
    RBRACKET_S      reduce using rule 70 (identifier -> IDENTIFIER .)
    LBRACKET        reduce using rule 70 (identifier -> IDENTIFIER .)
    IF              reduce using rule 70 (identifier -> IDENTIFIER .)
    WHILE           reduce using rule 70 (identifier -> IDENTIFIER .)
    RETURN          reduce using rule 70 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 70 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 70 (identifier -> IDENTIFIER .)
    INTEGER         reduce using rule 70 (identifier -> IDENTIFIER .)
    FLOAT           reduce using rule 70 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 70 (identifier -> IDENTIFIER .)
    BOOL            reduce using rule 70 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 70 (identifier -> IDENTIFIER .)
    $end            reduce using rule 70 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 70 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 70 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 70 (identifier -> IDENTIFIER .)


state 8

    (1) definition_sequence -> definition definition_sequence .

    $end            reduce using rule 1 (definition_sequence -> definition definition_sequence .)


state 9

    (7) function_declaration -> function_heading body .

    IDENTIFIER      reduce using rule 7 (function_declaration -> function_heading body .)
    $end            reduce using rule 7 (function_declaration -> function_heading body .)


state 10

    (27) body -> statement .

    IDENTIFIER      reduce using rule 27 (body -> statement .)
    $end            reduce using rule 27 (body -> statement .)
    ELSE            reduce using rule 27 (body -> statement .)
    LBRACKET        reduce using rule 27 (body -> statement .)
    IF              reduce using rule 27 (body -> statement .)
    WHILE           reduce using rule 27 (body -> statement .)
    RETURN          reduce using rule 27 (body -> statement .)
    LPAREN          reduce using rule 27 (body -> statement .)
    NOT             reduce using rule 27 (body -> statement .)
    INTEGER         reduce using rule 27 (body -> statement .)
    FLOAT           reduce using rule 27 (body -> statement .)
    STRING          reduce using rule 27 (body -> statement .)
    BOOL            reduce using rule 27 (body -> statement .)
    LBRACKET_S      reduce using rule 27 (body -> statement .)
    RBRACKET        reduce using rule 27 (body -> statement .)


state 11

    (17) statement -> statement_part .

    IDENTIFIER      reduce using rule 17 (statement -> statement_part .)
    $end            reduce using rule 17 (statement -> statement_part .)
    LBRACKET        reduce using rule 17 (statement -> statement_part .)
    IF              reduce using rule 17 (statement -> statement_part .)
    WHILE           reduce using rule 17 (statement -> statement_part .)
    RETURN          reduce using rule 17 (statement -> statement_part .)
    LPAREN          reduce using rule 17 (statement -> statement_part .)
    NOT             reduce using rule 17 (statement -> statement_part .)
    INTEGER         reduce using rule 17 (statement -> statement_part .)
    FLOAT           reduce using rule 17 (statement -> statement_part .)
    STRING          reduce using rule 17 (statement -> statement_part .)
    BOOL            reduce using rule 17 (statement -> statement_part .)
    LBRACKET_S      reduce using rule 17 (statement -> statement_part .)
    RBRACKET        reduce using rule 17 (statement -> statement_part .)
    ELSE            reduce using rule 17 (statement -> statement_part .)


state 12

    (18) statement -> assignment_statement .

    IDENTIFIER      reduce using rule 18 (statement -> assignment_statement .)
    $end            reduce using rule 18 (statement -> assignment_statement .)
    LBRACKET        reduce using rule 18 (statement -> assignment_statement .)
    IF              reduce using rule 18 (statement -> assignment_statement .)
    WHILE           reduce using rule 18 (statement -> assignment_statement .)
    RETURN          reduce using rule 18 (statement -> assignment_statement .)
    LPAREN          reduce using rule 18 (statement -> assignment_statement .)
    NOT             reduce using rule 18 (statement -> assignment_statement .)
    INTEGER         reduce using rule 18 (statement -> assignment_statement .)
    FLOAT           reduce using rule 18 (statement -> assignment_statement .)
    STRING          reduce using rule 18 (statement -> assignment_statement .)
    BOOL            reduce using rule 18 (statement -> assignment_statement .)
    LBRACKET_S      reduce using rule 18 (statement -> assignment_statement .)
    RBRACKET        reduce using rule 18 (statement -> assignment_statement .)
    ELSE            reduce using rule 18 (statement -> assignment_statement .)


state 13

    (19) statement -> array_def .

    IDENTIFIER      reduce using rule 19 (statement -> array_def .)
    $end            reduce using rule 19 (statement -> array_def .)
    LBRACKET        reduce using rule 19 (statement -> array_def .)
    IF              reduce using rule 19 (statement -> array_def .)
    WHILE           reduce using rule 19 (statement -> array_def .)
    RETURN          reduce using rule 19 (statement -> array_def .)
    LPAREN          reduce using rule 19 (statement -> array_def .)
    NOT             reduce using rule 19 (statement -> array_def .)
    INTEGER         reduce using rule 19 (statement -> array_def .)
    FLOAT           reduce using rule 19 (statement -> array_def .)
    STRING          reduce using rule 19 (statement -> array_def .)
    BOOL            reduce using rule 19 (statement -> array_def .)
    LBRACKET_S      reduce using rule 19 (statement -> array_def .)
    RBRACKET        reduce using rule 19 (statement -> array_def .)
    ELSE            reduce using rule 19 (statement -> array_def .)


state 14

    (20) statement -> if_statement .

    IDENTIFIER      reduce using rule 20 (statement -> if_statement .)
    $end            reduce using rule 20 (statement -> if_statement .)
    LBRACKET        reduce using rule 20 (statement -> if_statement .)
    IF              reduce using rule 20 (statement -> if_statement .)
    WHILE           reduce using rule 20 (statement -> if_statement .)
    RETURN          reduce using rule 20 (statement -> if_statement .)
    LPAREN          reduce using rule 20 (statement -> if_statement .)
    NOT             reduce using rule 20 (statement -> if_statement .)
    INTEGER         reduce using rule 20 (statement -> if_statement .)
    FLOAT           reduce using rule 20 (statement -> if_statement .)
    STRING          reduce using rule 20 (statement -> if_statement .)
    BOOL            reduce using rule 20 (statement -> if_statement .)
    LBRACKET_S      reduce using rule 20 (statement -> if_statement .)
    RBRACKET        reduce using rule 20 (statement -> if_statement .)
    ELSE            reduce using rule 20 (statement -> if_statement .)


state 15

    (21) statement -> while_statement .

    IDENTIFIER      reduce using rule 21 (statement -> while_statement .)
    $end            reduce using rule 21 (statement -> while_statement .)
    LBRACKET        reduce using rule 21 (statement -> while_statement .)
    IF              reduce using rule 21 (statement -> while_statement .)
    WHILE           reduce using rule 21 (statement -> while_statement .)
    RETURN          reduce using rule 21 (statement -> while_statement .)
    LPAREN          reduce using rule 21 (statement -> while_statement .)
    NOT             reduce using rule 21 (statement -> while_statement .)
    INTEGER         reduce using rule 21 (statement -> while_statement .)
    FLOAT           reduce using rule 21 (statement -> while_statement .)
    STRING          reduce using rule 21 (statement -> while_statement .)
    BOOL            reduce using rule 21 (statement -> while_statement .)
    LBRACKET_S      reduce using rule 21 (statement -> while_statement .)
    RBRACKET        reduce using rule 21 (statement -> while_statement .)
    ELSE            reduce using rule 21 (statement -> while_statement .)


state 16

    (22) statement -> return_statement .

    IDENTIFIER      reduce using rule 22 (statement -> return_statement .)
    $end            reduce using rule 22 (statement -> return_statement .)
    LBRACKET        reduce using rule 22 (statement -> return_statement .)
    IF              reduce using rule 22 (statement -> return_statement .)
    WHILE           reduce using rule 22 (statement -> return_statement .)
    RETURN          reduce using rule 22 (statement -> return_statement .)
    LPAREN          reduce using rule 22 (statement -> return_statement .)
    NOT             reduce using rule 22 (statement -> return_statement .)
    INTEGER         reduce using rule 22 (statement -> return_statement .)
    FLOAT           reduce using rule 22 (statement -> return_statement .)
    STRING          reduce using rule 22 (statement -> return_statement .)
    BOOL            reduce using rule 22 (statement -> return_statement .)
    LBRACKET_S      reduce using rule 22 (statement -> return_statement .)
    RBRACKET        reduce using rule 22 (statement -> return_statement .)
    ELSE            reduce using rule 22 (statement -> return_statement .)


state 17

    (23) statement -> function_call .

    IDENTIFIER      reduce using rule 23 (statement -> function_call .)
    $end            reduce using rule 23 (statement -> function_call .)
    LBRACKET        reduce using rule 23 (statement -> function_call .)
    IF              reduce using rule 23 (statement -> function_call .)
    WHILE           reduce using rule 23 (statement -> function_call .)
    RETURN          reduce using rule 23 (statement -> function_call .)
    LPAREN          reduce using rule 23 (statement -> function_call .)
    NOT             reduce using rule 23 (statement -> function_call .)
    INTEGER         reduce using rule 23 (statement -> function_call .)
    FLOAT           reduce using rule 23 (statement -> function_call .)
    STRING          reduce using rule 23 (statement -> function_call .)
    BOOL            reduce using rule 23 (statement -> function_call .)
    LBRACKET_S      reduce using rule 23 (statement -> function_call .)
    RBRACKET        reduce using rule 23 (statement -> function_call .)
    ELSE            reduce using rule 23 (statement -> function_call .)


state 18

    (24) statement -> array_call .

    IDENTIFIER      reduce using rule 24 (statement -> array_call .)
    $end            reduce using rule 24 (statement -> array_call .)
    LBRACKET        reduce using rule 24 (statement -> array_call .)
    IF              reduce using rule 24 (statement -> array_call .)
    WHILE           reduce using rule 24 (statement -> array_call .)
    RETURN          reduce using rule 24 (statement -> array_call .)
    LPAREN          reduce using rule 24 (statement -> array_call .)
    NOT             reduce using rule 24 (statement -> array_call .)
    INTEGER         reduce using rule 24 (statement -> array_call .)
    FLOAT           reduce using rule 24 (statement -> array_call .)
    STRING          reduce using rule 24 (statement -> array_call .)
    BOOL            reduce using rule 24 (statement -> array_call .)
    LBRACKET_S      reduce using rule 24 (statement -> array_call .)
    RBRACKET        reduce using rule 24 (statement -> array_call .)
    ELSE            reduce using rule 24 (statement -> array_call .)


state 19

    (25) statement -> expression . SEMICOLON
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    SEMICOLON       shift and go to state 42
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 20

    (14) statement_part -> LBRACKET . statement_sequence RBRACKET
    (15) statement_sequence -> . statement statement_sequence
    (16) statement_sequence -> . statement
    (17) statement -> . statement_part
    (18) statement -> . assignment_statement
    (19) statement -> . array_def
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . return_statement
    (23) statement -> . function_call
    (24) statement -> . array_call
    (25) statement -> . expression SEMICOLON
    (26) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (34) assignment_statement -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (35) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (36) array_def -> . identifier COLON type SEMICOLON
    (37) if_statement -> . IF expression body ELSE body
    (38) if_statement -> . IF expression body
    (39) while_statement -> . WHILE expression body
    (40) return_statement -> . RETURN expression SEMICOLON
    (28) function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (29) array_call -> . identifier LBRACKET_S expression RBRACKET_S SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (70) identifier -> . IDENTIFIER
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    RBRACKET        reduce using rule 26 (statement -> .)
    LBRACKET        shift and go to state 20
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    RETURN          shift and go to state 25
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

  ! LBRACKET        [ reduce using rule 26 (statement -> .) ]
  ! IF              [ reduce using rule 26 (statement -> .) ]
  ! WHILE           [ reduce using rule 26 (statement -> .) ]
  ! RETURN          [ reduce using rule 26 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 26 (statement -> .) ]
  ! LPAREN          [ reduce using rule 26 (statement -> .) ]
  ! NOT             [ reduce using rule 26 (statement -> .) ]
  ! INTEGER         [ reduce using rule 26 (statement -> .) ]
  ! FLOAT           [ reduce using rule 26 (statement -> .) ]
  ! STRING          [ reduce using rule 26 (statement -> .) ]
  ! BOOL            [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 26 (statement -> .) ]

    statement_sequence             shift and go to state 46
    statement                      shift and go to state 47
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    array_def                      shift and go to state 13
    if_statement                   shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_call                  shift and go to state 17
    array_call                     shift and go to state 18
    expression                     shift and go to state 19
    identifier                     shift and go to state 21
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 21

    (34) assignment_statement -> identifier . COLON type ASSIGNMENT expression SEMICOLON
    (35) assignment_statement -> identifier . LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (36) array_def -> identifier . COLON type SEMICOLON
    (28) function_call -> identifier . LPAREN param_list RPAREN SEMICOLON
    (29) array_call -> identifier . LBRACKET_S expression RBRACKET_S SEMICOLON
    (58) expression_e -> identifier .
    (68) function_call_inline -> identifier . LPAREN param_list RPAREN
    (69) array_call_inline -> identifier . LBRACKET_S expression RBRACKET_S

    COLON           shift and go to state 48
    LBRACKET_S      shift and go to state 49
    LPAREN          shift and go to state 50
    TIMES           reduce using rule 58 (expression_e -> identifier .)
    DIV             reduce using rule 58 (expression_e -> identifier .)
    PLUS            reduce using rule 58 (expression_e -> identifier .)
    MINUS           reduce using rule 58 (expression_e -> identifier .)
    MOD             reduce using rule 58 (expression_e -> identifier .)
    EQUAL           reduce using rule 58 (expression_e -> identifier .)
    NEQUAL          reduce using rule 58 (expression_e -> identifier .)
    LT              reduce using rule 58 (expression_e -> identifier .)
    LTE             reduce using rule 58 (expression_e -> identifier .)
    GT              reduce using rule 58 (expression_e -> identifier .)
    GTE             reduce using rule 58 (expression_e -> identifier .)
    SEMICOLON       reduce using rule 58 (expression_e -> identifier .)
    AND             reduce using rule 58 (expression_e -> identifier .)
    OR              reduce using rule 58 (expression_e -> identifier .)


state 22

    (75) array -> LBRACKET_S . expression RBRACKET_S
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression                     shift and go to state 51
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 23

    (37) if_statement -> IF . expression body ELSE body
    (38) if_statement -> IF . expression body
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression                     shift and go to state 53
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 24

    (39) while_statement -> WHILE . expression body
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression                     shift and go to state 54
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 25

    (40) return_statement -> RETURN . expression SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression                     shift and go to state 55
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 26

    (64) expression_e -> LPAREN . expression RPAREN
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression                     shift and go to state 56
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 27

    (41) expression -> expression_m .
    (44) expression_m -> expression_m . sign expression_e
    (47) sign -> . TIMES
    (48) sign -> . DIV
    (49) sign -> . PLUS
    (50) sign -> . MINUS
    (51) sign -> . MOD
    (52) sign -> . EQUAL
    (53) sign -> . NEQUAL
    (54) sign -> . LT
    (55) sign -> . LTE
    (56) sign -> . GT
    (57) sign -> . GTE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
    SEMICOLON       reduce using rule 41 (expression -> expression_m .)
    AND             reduce using rule 41 (expression -> expression_m .)
    OR              reduce using rule 41 (expression -> expression_m .)
    RBRACKET_S      reduce using rule 41 (expression -> expression_m .)
    LBRACKET        reduce using rule 41 (expression -> expression_m .)
    IF              reduce using rule 41 (expression -> expression_m .)
    WHILE           reduce using rule 41 (expression -> expression_m .)
    RETURN          reduce using rule 41 (expression -> expression_m .)
    IDENTIFIER      reduce using rule 41 (expression -> expression_m .)
    LPAREN          reduce using rule 41 (expression -> expression_m .)
    NOT             reduce using rule 41 (expression -> expression_m .)
    INTEGER         reduce using rule 41 (expression -> expression_m .)
    FLOAT           reduce using rule 41 (expression -> expression_m .)
    STRING          reduce using rule 41 (expression -> expression_m .)
    BOOL            reduce using rule 41 (expression -> expression_m .)
    LBRACKET_S      reduce using rule 41 (expression -> expression_m .)
    ELSE            reduce using rule 41 (expression -> expression_m .)
    $end            reduce using rule 41 (expression -> expression_m .)
    RBRACKET        reduce using rule 41 (expression -> expression_m .)
    RPAREN          reduce using rule 41 (expression -> expression_m .)
    COMMA           reduce using rule 41 (expression -> expression_m .)
    TIMES           shift and go to state 58
    DIV             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    MOD             shift and go to state 62
    EQUAL           shift and go to state 63
    NEQUAL          shift and go to state 64
    LT              shift and go to state 65
    LTE             shift and go to state 66
    GT              shift and go to state 67
    GTE             shift and go to state 68

  ! TIMES           [ reduce using rule 41 (expression -> expression_m .) ]
  ! DIV             [ reduce using rule 41 (expression -> expression_m .) ]
  ! PLUS            [ reduce using rule 41 (expression -> expression_m .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression_m .) ]
  ! MOD             [ reduce using rule 41 (expression -> expression_m .) ]
  ! EQUAL           [ reduce using rule 41 (expression -> expression_m .) ]
  ! NEQUAL          [ reduce using rule 41 (expression -> expression_m .) ]
  ! LT              [ reduce using rule 41 (expression -> expression_m .) ]
  ! LTE             [ reduce using rule 41 (expression -> expression_m .) ]
  ! GT              [ reduce using rule 41 (expression -> expression_m .) ]
  ! GTE             [ reduce using rule 41 (expression -> expression_m .) ]

    sign                           shift and go to state 57

state 28

    (43) expression_m -> expression_e .

    TIMES           reduce using rule 43 (expression_m -> expression_e .)
    DIV             reduce using rule 43 (expression_m -> expression_e .)
    PLUS            reduce using rule 43 (expression_m -> expression_e .)
    MINUS           reduce using rule 43 (expression_m -> expression_e .)
    MOD             reduce using rule 43 (expression_m -> expression_e .)
    EQUAL           reduce using rule 43 (expression_m -> expression_e .)
    NEQUAL          reduce using rule 43 (expression_m -> expression_e .)
    LT              reduce using rule 43 (expression_m -> expression_e .)
    LTE             reduce using rule 43 (expression_m -> expression_e .)
    GT              reduce using rule 43 (expression_m -> expression_e .)
    GTE             reduce using rule 43 (expression_m -> expression_e .)
    SEMICOLON       reduce using rule 43 (expression_m -> expression_e .)
    AND             reduce using rule 43 (expression_m -> expression_e .)
    OR              reduce using rule 43 (expression_m -> expression_e .)
    RBRACKET_S      reduce using rule 43 (expression_m -> expression_e .)
    LBRACKET        reduce using rule 43 (expression_m -> expression_e .)
    IF              reduce using rule 43 (expression_m -> expression_e .)
    WHILE           reduce using rule 43 (expression_m -> expression_e .)
    RETURN          reduce using rule 43 (expression_m -> expression_e .)
    IDENTIFIER      reduce using rule 43 (expression_m -> expression_e .)
    LPAREN          reduce using rule 43 (expression_m -> expression_e .)
    NOT             reduce using rule 43 (expression_m -> expression_e .)
    INTEGER         reduce using rule 43 (expression_m -> expression_e .)
    FLOAT           reduce using rule 43 (expression_m -> expression_e .)
    STRING          reduce using rule 43 (expression_m -> expression_e .)
    BOOL            reduce using rule 43 (expression_m -> expression_e .)
    LBRACKET_S      reduce using rule 43 (expression_m -> expression_e .)
    ELSE            reduce using rule 43 (expression_m -> expression_e .)
    $end            reduce using rule 43 (expression_m -> expression_e .)
    RBRACKET        reduce using rule 43 (expression_m -> expression_e .)
    RPAREN          reduce using rule 43 (expression_m -> expression_e .)
    COMMA           reduce using rule 43 (expression_m -> expression_e .)


state 29

    (59) expression_e -> integer .

    TIMES           reduce using rule 59 (expression_e -> integer .)
    DIV             reduce using rule 59 (expression_e -> integer .)
    PLUS            reduce using rule 59 (expression_e -> integer .)
    MINUS           reduce using rule 59 (expression_e -> integer .)
    MOD             reduce using rule 59 (expression_e -> integer .)
    EQUAL           reduce using rule 59 (expression_e -> integer .)
    NEQUAL          reduce using rule 59 (expression_e -> integer .)
    LT              reduce using rule 59 (expression_e -> integer .)
    LTE             reduce using rule 59 (expression_e -> integer .)
    GT              reduce using rule 59 (expression_e -> integer .)
    GTE             reduce using rule 59 (expression_e -> integer .)
    SEMICOLON       reduce using rule 59 (expression_e -> integer .)
    AND             reduce using rule 59 (expression_e -> integer .)
    OR              reduce using rule 59 (expression_e -> integer .)
    RBRACKET_S      reduce using rule 59 (expression_e -> integer .)
    LBRACKET        reduce using rule 59 (expression_e -> integer .)
    IF              reduce using rule 59 (expression_e -> integer .)
    WHILE           reduce using rule 59 (expression_e -> integer .)
    RETURN          reduce using rule 59 (expression_e -> integer .)
    IDENTIFIER      reduce using rule 59 (expression_e -> integer .)
    LPAREN          reduce using rule 59 (expression_e -> integer .)
    NOT             reduce using rule 59 (expression_e -> integer .)
    INTEGER         reduce using rule 59 (expression_e -> integer .)
    FLOAT           reduce using rule 59 (expression_e -> integer .)
    STRING          reduce using rule 59 (expression_e -> integer .)
    BOOL            reduce using rule 59 (expression_e -> integer .)
    LBRACKET_S      reduce using rule 59 (expression_e -> integer .)
    ELSE            reduce using rule 59 (expression_e -> integer .)
    $end            reduce using rule 59 (expression_e -> integer .)
    RBRACKET        reduce using rule 59 (expression_e -> integer .)
    RPAREN          reduce using rule 59 (expression_e -> integer .)
    COMMA           reduce using rule 59 (expression_e -> integer .)


state 30

    (60) expression_e -> float .

    TIMES           reduce using rule 60 (expression_e -> float .)
    DIV             reduce using rule 60 (expression_e -> float .)
    PLUS            reduce using rule 60 (expression_e -> float .)
    MINUS           reduce using rule 60 (expression_e -> float .)
    MOD             reduce using rule 60 (expression_e -> float .)
    EQUAL           reduce using rule 60 (expression_e -> float .)
    NEQUAL          reduce using rule 60 (expression_e -> float .)
    LT              reduce using rule 60 (expression_e -> float .)
    LTE             reduce using rule 60 (expression_e -> float .)
    GT              reduce using rule 60 (expression_e -> float .)
    GTE             reduce using rule 60 (expression_e -> float .)
    SEMICOLON       reduce using rule 60 (expression_e -> float .)
    AND             reduce using rule 60 (expression_e -> float .)
    OR              reduce using rule 60 (expression_e -> float .)
    RBRACKET_S      reduce using rule 60 (expression_e -> float .)
    LBRACKET        reduce using rule 60 (expression_e -> float .)
    IF              reduce using rule 60 (expression_e -> float .)
    WHILE           reduce using rule 60 (expression_e -> float .)
    RETURN          reduce using rule 60 (expression_e -> float .)
    IDENTIFIER      reduce using rule 60 (expression_e -> float .)
    LPAREN          reduce using rule 60 (expression_e -> float .)
    NOT             reduce using rule 60 (expression_e -> float .)
    INTEGER         reduce using rule 60 (expression_e -> float .)
    FLOAT           reduce using rule 60 (expression_e -> float .)
    STRING          reduce using rule 60 (expression_e -> float .)
    BOOL            reduce using rule 60 (expression_e -> float .)
    LBRACKET_S      reduce using rule 60 (expression_e -> float .)
    ELSE            reduce using rule 60 (expression_e -> float .)
    $end            reduce using rule 60 (expression_e -> float .)
    RBRACKET        reduce using rule 60 (expression_e -> float .)
    RPAREN          reduce using rule 60 (expression_e -> float .)
    COMMA           reduce using rule 60 (expression_e -> float .)


state 31

    (61) expression_e -> string .

    TIMES           reduce using rule 61 (expression_e -> string .)
    DIV             reduce using rule 61 (expression_e -> string .)
    PLUS            reduce using rule 61 (expression_e -> string .)
    MINUS           reduce using rule 61 (expression_e -> string .)
    MOD             reduce using rule 61 (expression_e -> string .)
    EQUAL           reduce using rule 61 (expression_e -> string .)
    NEQUAL          reduce using rule 61 (expression_e -> string .)
    LT              reduce using rule 61 (expression_e -> string .)
    LTE             reduce using rule 61 (expression_e -> string .)
    GT              reduce using rule 61 (expression_e -> string .)
    GTE             reduce using rule 61 (expression_e -> string .)
    SEMICOLON       reduce using rule 61 (expression_e -> string .)
    AND             reduce using rule 61 (expression_e -> string .)
    OR              reduce using rule 61 (expression_e -> string .)
    RBRACKET_S      reduce using rule 61 (expression_e -> string .)
    LBRACKET        reduce using rule 61 (expression_e -> string .)
    IF              reduce using rule 61 (expression_e -> string .)
    WHILE           reduce using rule 61 (expression_e -> string .)
    RETURN          reduce using rule 61 (expression_e -> string .)
    IDENTIFIER      reduce using rule 61 (expression_e -> string .)
    LPAREN          reduce using rule 61 (expression_e -> string .)
    NOT             reduce using rule 61 (expression_e -> string .)
    INTEGER         reduce using rule 61 (expression_e -> string .)
    FLOAT           reduce using rule 61 (expression_e -> string .)
    STRING          reduce using rule 61 (expression_e -> string .)
    BOOL            reduce using rule 61 (expression_e -> string .)
    LBRACKET_S      reduce using rule 61 (expression_e -> string .)
    ELSE            reduce using rule 61 (expression_e -> string .)
    $end            reduce using rule 61 (expression_e -> string .)
    RBRACKET        reduce using rule 61 (expression_e -> string .)
    RPAREN          reduce using rule 61 (expression_e -> string .)
    COMMA           reduce using rule 61 (expression_e -> string .)


state 32

    (62) expression_e -> bool .

    TIMES           reduce using rule 62 (expression_e -> bool .)
    DIV             reduce using rule 62 (expression_e -> bool .)
    PLUS            reduce using rule 62 (expression_e -> bool .)
    MINUS           reduce using rule 62 (expression_e -> bool .)
    MOD             reduce using rule 62 (expression_e -> bool .)
    EQUAL           reduce using rule 62 (expression_e -> bool .)
    NEQUAL          reduce using rule 62 (expression_e -> bool .)
    LT              reduce using rule 62 (expression_e -> bool .)
    LTE             reduce using rule 62 (expression_e -> bool .)
    GT              reduce using rule 62 (expression_e -> bool .)
    GTE             reduce using rule 62 (expression_e -> bool .)
    SEMICOLON       reduce using rule 62 (expression_e -> bool .)
    AND             reduce using rule 62 (expression_e -> bool .)
    OR              reduce using rule 62 (expression_e -> bool .)
    RBRACKET_S      reduce using rule 62 (expression_e -> bool .)
    LBRACKET        reduce using rule 62 (expression_e -> bool .)
    IF              reduce using rule 62 (expression_e -> bool .)
    WHILE           reduce using rule 62 (expression_e -> bool .)
    RETURN          reduce using rule 62 (expression_e -> bool .)
    IDENTIFIER      reduce using rule 62 (expression_e -> bool .)
    LPAREN          reduce using rule 62 (expression_e -> bool .)
    NOT             reduce using rule 62 (expression_e -> bool .)
    INTEGER         reduce using rule 62 (expression_e -> bool .)
    FLOAT           reduce using rule 62 (expression_e -> bool .)
    STRING          reduce using rule 62 (expression_e -> bool .)
    BOOL            reduce using rule 62 (expression_e -> bool .)
    LBRACKET_S      reduce using rule 62 (expression_e -> bool .)
    ELSE            reduce using rule 62 (expression_e -> bool .)
    $end            reduce using rule 62 (expression_e -> bool .)
    RBRACKET        reduce using rule 62 (expression_e -> bool .)
    RPAREN          reduce using rule 62 (expression_e -> bool .)
    COMMA           reduce using rule 62 (expression_e -> bool .)


state 33

    (63) expression_e -> array .

    TIMES           reduce using rule 63 (expression_e -> array .)
    DIV             reduce using rule 63 (expression_e -> array .)
    PLUS            reduce using rule 63 (expression_e -> array .)
    MINUS           reduce using rule 63 (expression_e -> array .)
    MOD             reduce using rule 63 (expression_e -> array .)
    EQUAL           reduce using rule 63 (expression_e -> array .)
    NEQUAL          reduce using rule 63 (expression_e -> array .)
    LT              reduce using rule 63 (expression_e -> array .)
    LTE             reduce using rule 63 (expression_e -> array .)
    GT              reduce using rule 63 (expression_e -> array .)
    GTE             reduce using rule 63 (expression_e -> array .)
    SEMICOLON       reduce using rule 63 (expression_e -> array .)
    AND             reduce using rule 63 (expression_e -> array .)
    OR              reduce using rule 63 (expression_e -> array .)
    RBRACKET_S      reduce using rule 63 (expression_e -> array .)
    LBRACKET        reduce using rule 63 (expression_e -> array .)
    IF              reduce using rule 63 (expression_e -> array .)
    WHILE           reduce using rule 63 (expression_e -> array .)
    RETURN          reduce using rule 63 (expression_e -> array .)
    IDENTIFIER      reduce using rule 63 (expression_e -> array .)
    LPAREN          reduce using rule 63 (expression_e -> array .)
    NOT             reduce using rule 63 (expression_e -> array .)
    INTEGER         reduce using rule 63 (expression_e -> array .)
    FLOAT           reduce using rule 63 (expression_e -> array .)
    STRING          reduce using rule 63 (expression_e -> array .)
    BOOL            reduce using rule 63 (expression_e -> array .)
    LBRACKET_S      reduce using rule 63 (expression_e -> array .)
    ELSE            reduce using rule 63 (expression_e -> array .)
    $end            reduce using rule 63 (expression_e -> array .)
    RBRACKET        reduce using rule 63 (expression_e -> array .)
    RPAREN          reduce using rule 63 (expression_e -> array .)
    COMMA           reduce using rule 63 (expression_e -> array .)


state 34

    (65) expression_e -> NOT . expression
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression                     shift and go to state 69
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 35

    (66) expression_e -> function_call_inline .

    TIMES           reduce using rule 66 (expression_e -> function_call_inline .)
    DIV             reduce using rule 66 (expression_e -> function_call_inline .)
    PLUS            reduce using rule 66 (expression_e -> function_call_inline .)
    MINUS           reduce using rule 66 (expression_e -> function_call_inline .)
    MOD             reduce using rule 66 (expression_e -> function_call_inline .)
    EQUAL           reduce using rule 66 (expression_e -> function_call_inline .)
    NEQUAL          reduce using rule 66 (expression_e -> function_call_inline .)
    LT              reduce using rule 66 (expression_e -> function_call_inline .)
    LTE             reduce using rule 66 (expression_e -> function_call_inline .)
    GT              reduce using rule 66 (expression_e -> function_call_inline .)
    GTE             reduce using rule 66 (expression_e -> function_call_inline .)
    SEMICOLON       reduce using rule 66 (expression_e -> function_call_inline .)
    AND             reduce using rule 66 (expression_e -> function_call_inline .)
    OR              reduce using rule 66 (expression_e -> function_call_inline .)
    RBRACKET_S      reduce using rule 66 (expression_e -> function_call_inline .)
    LBRACKET        reduce using rule 66 (expression_e -> function_call_inline .)
    IF              reduce using rule 66 (expression_e -> function_call_inline .)
    WHILE           reduce using rule 66 (expression_e -> function_call_inline .)
    RETURN          reduce using rule 66 (expression_e -> function_call_inline .)
    IDENTIFIER      reduce using rule 66 (expression_e -> function_call_inline .)
    LPAREN          reduce using rule 66 (expression_e -> function_call_inline .)
    NOT             reduce using rule 66 (expression_e -> function_call_inline .)
    INTEGER         reduce using rule 66 (expression_e -> function_call_inline .)
    FLOAT           reduce using rule 66 (expression_e -> function_call_inline .)
    STRING          reduce using rule 66 (expression_e -> function_call_inline .)
    BOOL            reduce using rule 66 (expression_e -> function_call_inline .)
    LBRACKET_S      reduce using rule 66 (expression_e -> function_call_inline .)
    ELSE            reduce using rule 66 (expression_e -> function_call_inline .)
    $end            reduce using rule 66 (expression_e -> function_call_inline .)
    RBRACKET        reduce using rule 66 (expression_e -> function_call_inline .)
    RPAREN          reduce using rule 66 (expression_e -> function_call_inline .)
    COMMA           reduce using rule 66 (expression_e -> function_call_inline .)


state 36

    (67) expression_e -> array_call_inline .

    TIMES           reduce using rule 67 (expression_e -> array_call_inline .)
    DIV             reduce using rule 67 (expression_e -> array_call_inline .)
    PLUS            reduce using rule 67 (expression_e -> array_call_inline .)
    MINUS           reduce using rule 67 (expression_e -> array_call_inline .)
    MOD             reduce using rule 67 (expression_e -> array_call_inline .)
    EQUAL           reduce using rule 67 (expression_e -> array_call_inline .)
    NEQUAL          reduce using rule 67 (expression_e -> array_call_inline .)
    LT              reduce using rule 67 (expression_e -> array_call_inline .)
    LTE             reduce using rule 67 (expression_e -> array_call_inline .)
    GT              reduce using rule 67 (expression_e -> array_call_inline .)
    GTE             reduce using rule 67 (expression_e -> array_call_inline .)
    SEMICOLON       reduce using rule 67 (expression_e -> array_call_inline .)
    AND             reduce using rule 67 (expression_e -> array_call_inline .)
    OR              reduce using rule 67 (expression_e -> array_call_inline .)
    RBRACKET_S      reduce using rule 67 (expression_e -> array_call_inline .)
    LBRACKET        reduce using rule 67 (expression_e -> array_call_inline .)
    IF              reduce using rule 67 (expression_e -> array_call_inline .)
    WHILE           reduce using rule 67 (expression_e -> array_call_inline .)
    RETURN          reduce using rule 67 (expression_e -> array_call_inline .)
    IDENTIFIER      reduce using rule 67 (expression_e -> array_call_inline .)
    LPAREN          reduce using rule 67 (expression_e -> array_call_inline .)
    NOT             reduce using rule 67 (expression_e -> array_call_inline .)
    INTEGER         reduce using rule 67 (expression_e -> array_call_inline .)
    FLOAT           reduce using rule 67 (expression_e -> array_call_inline .)
    STRING          reduce using rule 67 (expression_e -> array_call_inline .)
    BOOL            reduce using rule 67 (expression_e -> array_call_inline .)
    LBRACKET_S      reduce using rule 67 (expression_e -> array_call_inline .)
    ELSE            reduce using rule 67 (expression_e -> array_call_inline .)
    $end            reduce using rule 67 (expression_e -> array_call_inline .)
    RBRACKET        reduce using rule 67 (expression_e -> array_call_inline .)
    RPAREN          reduce using rule 67 (expression_e -> array_call_inline .)
    COMMA           reduce using rule 67 (expression_e -> array_call_inline .)


state 37

    (71) integer -> INTEGER .

    TIMES           reduce using rule 71 (integer -> INTEGER .)
    DIV             reduce using rule 71 (integer -> INTEGER .)
    PLUS            reduce using rule 71 (integer -> INTEGER .)
    MINUS           reduce using rule 71 (integer -> INTEGER .)
    MOD             reduce using rule 71 (integer -> INTEGER .)
    EQUAL           reduce using rule 71 (integer -> INTEGER .)
    NEQUAL          reduce using rule 71 (integer -> INTEGER .)
    LT              reduce using rule 71 (integer -> INTEGER .)
    LTE             reduce using rule 71 (integer -> INTEGER .)
    GT              reduce using rule 71 (integer -> INTEGER .)
    GTE             reduce using rule 71 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 71 (integer -> INTEGER .)
    AND             reduce using rule 71 (integer -> INTEGER .)
    OR              reduce using rule 71 (integer -> INTEGER .)
    RBRACKET_S      reduce using rule 71 (integer -> INTEGER .)
    LBRACKET        reduce using rule 71 (integer -> INTEGER .)
    IF              reduce using rule 71 (integer -> INTEGER .)
    WHILE           reduce using rule 71 (integer -> INTEGER .)
    RETURN          reduce using rule 71 (integer -> INTEGER .)
    IDENTIFIER      reduce using rule 71 (integer -> INTEGER .)
    LPAREN          reduce using rule 71 (integer -> INTEGER .)
    NOT             reduce using rule 71 (integer -> INTEGER .)
    INTEGER         reduce using rule 71 (integer -> INTEGER .)
    FLOAT           reduce using rule 71 (integer -> INTEGER .)
    STRING          reduce using rule 71 (integer -> INTEGER .)
    BOOL            reduce using rule 71 (integer -> INTEGER .)
    LBRACKET_S      reduce using rule 71 (integer -> INTEGER .)
    ELSE            reduce using rule 71 (integer -> INTEGER .)
    $end            reduce using rule 71 (integer -> INTEGER .)
    RBRACKET        reduce using rule 71 (integer -> INTEGER .)
    RPAREN          reduce using rule 71 (integer -> INTEGER .)
    COMMA           reduce using rule 71 (integer -> INTEGER .)


state 38

    (72) float -> FLOAT .

    TIMES           reduce using rule 72 (float -> FLOAT .)
    DIV             reduce using rule 72 (float -> FLOAT .)
    PLUS            reduce using rule 72 (float -> FLOAT .)
    MINUS           reduce using rule 72 (float -> FLOAT .)
    MOD             reduce using rule 72 (float -> FLOAT .)
    EQUAL           reduce using rule 72 (float -> FLOAT .)
    NEQUAL          reduce using rule 72 (float -> FLOAT .)
    LT              reduce using rule 72 (float -> FLOAT .)
    LTE             reduce using rule 72 (float -> FLOAT .)
    GT              reduce using rule 72 (float -> FLOAT .)
    GTE             reduce using rule 72 (float -> FLOAT .)
    SEMICOLON       reduce using rule 72 (float -> FLOAT .)
    AND             reduce using rule 72 (float -> FLOAT .)
    OR              reduce using rule 72 (float -> FLOAT .)
    RBRACKET_S      reduce using rule 72 (float -> FLOAT .)
    LBRACKET        reduce using rule 72 (float -> FLOAT .)
    IF              reduce using rule 72 (float -> FLOAT .)
    WHILE           reduce using rule 72 (float -> FLOAT .)
    RETURN          reduce using rule 72 (float -> FLOAT .)
    IDENTIFIER      reduce using rule 72 (float -> FLOAT .)
    LPAREN          reduce using rule 72 (float -> FLOAT .)
    NOT             reduce using rule 72 (float -> FLOAT .)
    INTEGER         reduce using rule 72 (float -> FLOAT .)
    FLOAT           reduce using rule 72 (float -> FLOAT .)
    STRING          reduce using rule 72 (float -> FLOAT .)
    BOOL            reduce using rule 72 (float -> FLOAT .)
    LBRACKET_S      reduce using rule 72 (float -> FLOAT .)
    ELSE            reduce using rule 72 (float -> FLOAT .)
    $end            reduce using rule 72 (float -> FLOAT .)
    RBRACKET        reduce using rule 72 (float -> FLOAT .)
    RPAREN          reduce using rule 72 (float -> FLOAT .)
    COMMA           reduce using rule 72 (float -> FLOAT .)


state 39

    (73) string -> STRING .

    TIMES           reduce using rule 73 (string -> STRING .)
    DIV             reduce using rule 73 (string -> STRING .)
    PLUS            reduce using rule 73 (string -> STRING .)
    MINUS           reduce using rule 73 (string -> STRING .)
    MOD             reduce using rule 73 (string -> STRING .)
    EQUAL           reduce using rule 73 (string -> STRING .)
    NEQUAL          reduce using rule 73 (string -> STRING .)
    LT              reduce using rule 73 (string -> STRING .)
    LTE             reduce using rule 73 (string -> STRING .)
    GT              reduce using rule 73 (string -> STRING .)
    GTE             reduce using rule 73 (string -> STRING .)
    SEMICOLON       reduce using rule 73 (string -> STRING .)
    AND             reduce using rule 73 (string -> STRING .)
    OR              reduce using rule 73 (string -> STRING .)
    RBRACKET_S      reduce using rule 73 (string -> STRING .)
    LBRACKET        reduce using rule 73 (string -> STRING .)
    IF              reduce using rule 73 (string -> STRING .)
    WHILE           reduce using rule 73 (string -> STRING .)
    RETURN          reduce using rule 73 (string -> STRING .)
    IDENTIFIER      reduce using rule 73 (string -> STRING .)
    LPAREN          reduce using rule 73 (string -> STRING .)
    NOT             reduce using rule 73 (string -> STRING .)
    INTEGER         reduce using rule 73 (string -> STRING .)
    FLOAT           reduce using rule 73 (string -> STRING .)
    STRING          reduce using rule 73 (string -> STRING .)
    BOOL            reduce using rule 73 (string -> STRING .)
    LBRACKET_S      reduce using rule 73 (string -> STRING .)
    ELSE            reduce using rule 73 (string -> STRING .)
    $end            reduce using rule 73 (string -> STRING .)
    RBRACKET        reduce using rule 73 (string -> STRING .)
    RPAREN          reduce using rule 73 (string -> STRING .)
    COMMA           reduce using rule 73 (string -> STRING .)


state 40

    (74) bool -> BOOL .

    TIMES           reduce using rule 74 (bool -> BOOL .)
    DIV             reduce using rule 74 (bool -> BOOL .)
    PLUS            reduce using rule 74 (bool -> BOOL .)
    MINUS           reduce using rule 74 (bool -> BOOL .)
    MOD             reduce using rule 74 (bool -> BOOL .)
    EQUAL           reduce using rule 74 (bool -> BOOL .)
    NEQUAL          reduce using rule 74 (bool -> BOOL .)
    LT              reduce using rule 74 (bool -> BOOL .)
    LTE             reduce using rule 74 (bool -> BOOL .)
    GT              reduce using rule 74 (bool -> BOOL .)
    GTE             reduce using rule 74 (bool -> BOOL .)
    SEMICOLON       reduce using rule 74 (bool -> BOOL .)
    AND             reduce using rule 74 (bool -> BOOL .)
    OR              reduce using rule 74 (bool -> BOOL .)
    RBRACKET_S      reduce using rule 74 (bool -> BOOL .)
    LBRACKET        reduce using rule 74 (bool -> BOOL .)
    IF              reduce using rule 74 (bool -> BOOL .)
    WHILE           reduce using rule 74 (bool -> BOOL .)
    RETURN          reduce using rule 74 (bool -> BOOL .)
    IDENTIFIER      reduce using rule 74 (bool -> BOOL .)
    LPAREN          reduce using rule 74 (bool -> BOOL .)
    NOT             reduce using rule 74 (bool -> BOOL .)
    INTEGER         reduce using rule 74 (bool -> BOOL .)
    FLOAT           reduce using rule 74 (bool -> BOOL .)
    STRING          reduce using rule 74 (bool -> BOOL .)
    BOOL            reduce using rule 74 (bool -> BOOL .)
    LBRACKET_S      reduce using rule 74 (bool -> BOOL .)
    ELSE            reduce using rule 74 (bool -> BOOL .)
    $end            reduce using rule 74 (bool -> BOOL .)
    RBRACKET        reduce using rule 74 (bool -> BOOL .)
    RPAREN          reduce using rule 74 (bool -> BOOL .)
    COMMA           reduce using rule 74 (bool -> BOOL .)


state 41

    (8) function_declaration -> identifier COLON . type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON . type SEMICOLON
    (6) variable_declaration -> identifier COLON . type ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier COLON . type LPAREN parameter_list RPAREN
    (76) type -> . TINTEGER
    (77) type -> . TFLOAT
    (78) type -> . TSTRING
    (79) type -> . TBOOL
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 70

state 42

    (25) statement -> expression SEMICOLON .

    IDENTIFIER      reduce using rule 25 (statement -> expression SEMICOLON .)
    $end            reduce using rule 25 (statement -> expression SEMICOLON .)
    LBRACKET        reduce using rule 25 (statement -> expression SEMICOLON .)
    IF              reduce using rule 25 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 25 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 25 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 25 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 25 (statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 25 (statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 25 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 25 (statement -> expression SEMICOLON .)
    BOOL            reduce using rule 25 (statement -> expression SEMICOLON .)
    LBRACKET_S      reduce using rule 25 (statement -> expression SEMICOLON .)
    RBRACKET        reduce using rule 25 (statement -> expression SEMICOLON .)
    ELSE            reduce using rule 25 (statement -> expression SEMICOLON .)


state 43

    (42) expression -> expression and_or . expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression_m                   shift and go to state 76
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 44

    (45) and_or -> AND .

    LPAREN          reduce using rule 45 (and_or -> AND .)
    NOT             reduce using rule 45 (and_or -> AND .)
    IDENTIFIER      reduce using rule 45 (and_or -> AND .)
    INTEGER         reduce using rule 45 (and_or -> AND .)
    FLOAT           reduce using rule 45 (and_or -> AND .)
    STRING          reduce using rule 45 (and_or -> AND .)
    BOOL            reduce using rule 45 (and_or -> AND .)
    LBRACKET_S      reduce using rule 45 (and_or -> AND .)


state 45

    (46) and_or -> OR .

    LPAREN          reduce using rule 46 (and_or -> OR .)
    NOT             reduce using rule 46 (and_or -> OR .)
    IDENTIFIER      reduce using rule 46 (and_or -> OR .)
    INTEGER         reduce using rule 46 (and_or -> OR .)
    FLOAT           reduce using rule 46 (and_or -> OR .)
    STRING          reduce using rule 46 (and_or -> OR .)
    BOOL            reduce using rule 46 (and_or -> OR .)
    LBRACKET_S      reduce using rule 46 (and_or -> OR .)


state 46

    (14) statement_part -> LBRACKET statement_sequence . RBRACKET

    RBRACKET        shift and go to state 77


state 47

    (15) statement_sequence -> statement . statement_sequence
    (16) statement_sequence -> statement .
    (15) statement_sequence -> . statement statement_sequence
    (16) statement_sequence -> . statement
    (17) statement -> . statement_part
    (18) statement -> . assignment_statement
    (19) statement -> . array_def
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . return_statement
    (23) statement -> . function_call
    (24) statement -> . array_call
    (25) statement -> . expression SEMICOLON
    (26) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (34) assignment_statement -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (35) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (36) array_def -> . identifier COLON type SEMICOLON
    (37) if_statement -> . IF expression body ELSE body
    (38) if_statement -> . IF expression body
    (39) while_statement -> . WHILE expression body
    (40) return_statement -> . RETURN expression SEMICOLON
    (28) function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (29) array_call -> . identifier LBRACKET_S expression RBRACKET_S SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (70) identifier -> . IDENTIFIER
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

  ! reduce/reduce conflict for RBRACKET resolved using rule 16 (statement_sequence -> statement .)
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    RBRACKET        reduce using rule 16 (statement_sequence -> statement .)
    LBRACKET        shift and go to state 20
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    RETURN          shift and go to state 25
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

  ! LBRACKET        [ reduce using rule 26 (statement -> .) ]
  ! IF              [ reduce using rule 26 (statement -> .) ]
  ! WHILE           [ reduce using rule 26 (statement -> .) ]
  ! RETURN          [ reduce using rule 26 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 26 (statement -> .) ]
  ! LPAREN          [ reduce using rule 26 (statement -> .) ]
  ! NOT             [ reduce using rule 26 (statement -> .) ]
  ! INTEGER         [ reduce using rule 26 (statement -> .) ]
  ! FLOAT           [ reduce using rule 26 (statement -> .) ]
  ! STRING          [ reduce using rule 26 (statement -> .) ]
  ! BOOL            [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 26 (statement -> .) ]
  ! RBRACKET        [ reduce using rule 26 (statement -> .) ]

    statement                      shift and go to state 47
    statement_sequence             shift and go to state 78
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    array_def                      shift and go to state 13
    if_statement                   shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_call                  shift and go to state 17
    array_call                     shift and go to state 18
    expression                     shift and go to state 19
    identifier                     shift and go to state 21
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 48

    (34) assignment_statement -> identifier COLON . type ASSIGNMENT expression SEMICOLON
    (36) array_def -> identifier COLON . type SEMICOLON
    (76) type -> . TINTEGER
    (77) type -> . TFLOAT
    (78) type -> . TSTRING
    (79) type -> . TBOOL
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 79

state 49

    (35) assignment_statement -> identifier LBRACKET_S . expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (29) array_call -> identifier LBRACKET_S . expression RBRACKET_S SEMICOLON
    (69) array_call_inline -> identifier LBRACKET_S . expression RBRACKET_S
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    identifier                     shift and go to state 52
    expression                     shift and go to state 80
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 50

    (28) function_call -> identifier LPAREN . param_list RPAREN SEMICOLON
    (68) function_call_inline -> identifier LPAREN . param_list RPAREN
    (30) param_list -> . param COMMA param_list
    (31) param_list -> . param
    (32) param_list -> .
    (33) param -> . expression
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    RPAREN          reduce using rule 32 (param_list -> .)
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    identifier                     shift and go to state 52
    param_list                     shift and go to state 81
    param                          shift and go to state 82
    expression                     shift and go to state 83
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 51

    (75) array -> LBRACKET_S expression . RBRACKET_S
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    RBRACKET_S      shift and go to state 84
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 52

    (58) expression_e -> identifier .
    (68) function_call_inline -> identifier . LPAREN param_list RPAREN
    (69) array_call_inline -> identifier . LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    TIMES           reduce using rule 58 (expression_e -> identifier .)
    DIV             reduce using rule 58 (expression_e -> identifier .)
    PLUS            reduce using rule 58 (expression_e -> identifier .)
    MINUS           reduce using rule 58 (expression_e -> identifier .)
    MOD             reduce using rule 58 (expression_e -> identifier .)
    EQUAL           reduce using rule 58 (expression_e -> identifier .)
    NEQUAL          reduce using rule 58 (expression_e -> identifier .)
    LT              reduce using rule 58 (expression_e -> identifier .)
    LTE             reduce using rule 58 (expression_e -> identifier .)
    GT              reduce using rule 58 (expression_e -> identifier .)
    GTE             reduce using rule 58 (expression_e -> identifier .)
    RBRACKET_S      reduce using rule 58 (expression_e -> identifier .)
    AND             reduce using rule 58 (expression_e -> identifier .)
    OR              reduce using rule 58 (expression_e -> identifier .)
    LBRACKET        reduce using rule 58 (expression_e -> identifier .)
    IF              reduce using rule 58 (expression_e -> identifier .)
    WHILE           reduce using rule 58 (expression_e -> identifier .)
    RETURN          reduce using rule 58 (expression_e -> identifier .)
    IDENTIFIER      reduce using rule 58 (expression_e -> identifier .)
    NOT             reduce using rule 58 (expression_e -> identifier .)
    INTEGER         reduce using rule 58 (expression_e -> identifier .)
    FLOAT           reduce using rule 58 (expression_e -> identifier .)
    STRING          reduce using rule 58 (expression_e -> identifier .)
    BOOL            reduce using rule 58 (expression_e -> identifier .)
    ELSE            reduce using rule 58 (expression_e -> identifier .)
    $end            reduce using rule 58 (expression_e -> identifier .)
    RBRACKET        reduce using rule 58 (expression_e -> identifier .)
    SEMICOLON       reduce using rule 58 (expression_e -> identifier .)
    RPAREN          reduce using rule 58 (expression_e -> identifier .)
    COMMA           reduce using rule 58 (expression_e -> identifier .)
    LPAREN          shift and go to state 85
    LBRACKET_S      shift and go to state 86

  ! LPAREN          [ reduce using rule 58 (expression_e -> identifier .) ]
  ! LBRACKET_S      [ reduce using rule 58 (expression_e -> identifier .) ]


state 53

    (37) if_statement -> IF expression . body ELSE body
    (38) if_statement -> IF expression . body
    (42) expression -> expression . and_or expression_m
    (27) body -> . statement
    (45) and_or -> . AND
    (46) and_or -> . OR
    (17) statement -> . statement_part
    (18) statement -> . assignment_statement
    (19) statement -> . array_def
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . return_statement
    (23) statement -> . function_call
    (24) statement -> . array_call
    (25) statement -> . expression SEMICOLON
    (26) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (34) assignment_statement -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (35) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (36) array_def -> . identifier COLON type SEMICOLON
    (37) if_statement -> . IF expression body ELSE body
    (38) if_statement -> . IF expression body
    (39) while_statement -> . WHILE expression body
    (40) return_statement -> . RETURN expression SEMICOLON
    (28) function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (29) array_call -> . identifier LBRACKET_S expression RBRACKET_S SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (70) identifier -> . IDENTIFIER
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    AND             shift and go to state 44
    OR              shift and go to state 45
    ELSE            reduce using rule 26 (statement -> .)
    $end            reduce using rule 26 (statement -> .)
    RBRACKET        reduce using rule 26 (statement -> .)
    LBRACKET        shift and go to state 20
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    RETURN          shift and go to state 25
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

  ! IDENTIFIER      [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 26 (statement -> .) ]
  ! IF              [ reduce using rule 26 (statement -> .) ]
  ! WHILE           [ reduce using rule 26 (statement -> .) ]
  ! RETURN          [ reduce using rule 26 (statement -> .) ]
  ! LPAREN          [ reduce using rule 26 (statement -> .) ]
  ! NOT             [ reduce using rule 26 (statement -> .) ]
  ! INTEGER         [ reduce using rule 26 (statement -> .) ]
  ! FLOAT           [ reduce using rule 26 (statement -> .) ]
  ! STRING          [ reduce using rule 26 (statement -> .) ]
  ! BOOL            [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 26 (statement -> .) ]

    expression                     shift and go to state 19
    body                           shift and go to state 87
    and_or                         shift and go to state 43
    expression_m                   shift and go to state 27
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    array_def                      shift and go to state 13
    if_statement                   shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_call                  shift and go to state 17
    array_call                     shift and go to state 18
    identifier                     shift and go to state 21
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 54

    (39) while_statement -> WHILE expression . body
    (42) expression -> expression . and_or expression_m
    (27) body -> . statement
    (45) and_or -> . AND
    (46) and_or -> . OR
    (17) statement -> . statement_part
    (18) statement -> . assignment_statement
    (19) statement -> . array_def
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . return_statement
    (23) statement -> . function_call
    (24) statement -> . array_call
    (25) statement -> . expression SEMICOLON
    (26) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (34) assignment_statement -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (35) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (36) array_def -> . identifier COLON type SEMICOLON
    (37) if_statement -> . IF expression body ELSE body
    (38) if_statement -> . IF expression body
    (39) while_statement -> . WHILE expression body
    (40) return_statement -> . RETURN expression SEMICOLON
    (28) function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (29) array_call -> . identifier LBRACKET_S expression RBRACKET_S SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (70) identifier -> . IDENTIFIER
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    AND             shift and go to state 44
    OR              shift and go to state 45
    ELSE            reduce using rule 26 (statement -> .)
    $end            reduce using rule 26 (statement -> .)
    RBRACKET        reduce using rule 26 (statement -> .)
    LBRACKET        shift and go to state 20
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    RETURN          shift and go to state 25
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

  ! IDENTIFIER      [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 26 (statement -> .) ]
  ! IF              [ reduce using rule 26 (statement -> .) ]
  ! WHILE           [ reduce using rule 26 (statement -> .) ]
  ! RETURN          [ reduce using rule 26 (statement -> .) ]
  ! LPAREN          [ reduce using rule 26 (statement -> .) ]
  ! NOT             [ reduce using rule 26 (statement -> .) ]
  ! INTEGER         [ reduce using rule 26 (statement -> .) ]
  ! FLOAT           [ reduce using rule 26 (statement -> .) ]
  ! STRING          [ reduce using rule 26 (statement -> .) ]
  ! BOOL            [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 26 (statement -> .) ]

    expression                     shift and go to state 19
    body                           shift and go to state 88
    and_or                         shift and go to state 43
    expression_m                   shift and go to state 27
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    array_def                      shift and go to state 13
    if_statement                   shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_call                  shift and go to state 17
    array_call                     shift and go to state 18
    identifier                     shift and go to state 21
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 55

    (40) return_statement -> RETURN expression . SEMICOLON
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    SEMICOLON       shift and go to state 89
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 56

    (64) expression_e -> LPAREN expression . RPAREN
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    RPAREN          shift and go to state 90
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 57

    (44) expression_m -> expression_m sign . expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    expression_e                   shift and go to state 91
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 58

    (47) sign -> TIMES .

    LPAREN          reduce using rule 47 (sign -> TIMES .)
    NOT             reduce using rule 47 (sign -> TIMES .)
    IDENTIFIER      reduce using rule 47 (sign -> TIMES .)
    INTEGER         reduce using rule 47 (sign -> TIMES .)
    FLOAT           reduce using rule 47 (sign -> TIMES .)
    STRING          reduce using rule 47 (sign -> TIMES .)
    BOOL            reduce using rule 47 (sign -> TIMES .)
    LBRACKET_S      reduce using rule 47 (sign -> TIMES .)


state 59

    (48) sign -> DIV .

    LPAREN          reduce using rule 48 (sign -> DIV .)
    NOT             reduce using rule 48 (sign -> DIV .)
    IDENTIFIER      reduce using rule 48 (sign -> DIV .)
    INTEGER         reduce using rule 48 (sign -> DIV .)
    FLOAT           reduce using rule 48 (sign -> DIV .)
    STRING          reduce using rule 48 (sign -> DIV .)
    BOOL            reduce using rule 48 (sign -> DIV .)
    LBRACKET_S      reduce using rule 48 (sign -> DIV .)


state 60

    (49) sign -> PLUS .

    LPAREN          reduce using rule 49 (sign -> PLUS .)
    NOT             reduce using rule 49 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 49 (sign -> PLUS .)
    INTEGER         reduce using rule 49 (sign -> PLUS .)
    FLOAT           reduce using rule 49 (sign -> PLUS .)
    STRING          reduce using rule 49 (sign -> PLUS .)
    BOOL            reduce using rule 49 (sign -> PLUS .)
    LBRACKET_S      reduce using rule 49 (sign -> PLUS .)


state 61

    (50) sign -> MINUS .

    LPAREN          reduce using rule 50 (sign -> MINUS .)
    NOT             reduce using rule 50 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 50 (sign -> MINUS .)
    INTEGER         reduce using rule 50 (sign -> MINUS .)
    FLOAT           reduce using rule 50 (sign -> MINUS .)
    STRING          reduce using rule 50 (sign -> MINUS .)
    BOOL            reduce using rule 50 (sign -> MINUS .)
    LBRACKET_S      reduce using rule 50 (sign -> MINUS .)


state 62

    (51) sign -> MOD .

    LPAREN          reduce using rule 51 (sign -> MOD .)
    NOT             reduce using rule 51 (sign -> MOD .)
    IDENTIFIER      reduce using rule 51 (sign -> MOD .)
    INTEGER         reduce using rule 51 (sign -> MOD .)
    FLOAT           reduce using rule 51 (sign -> MOD .)
    STRING          reduce using rule 51 (sign -> MOD .)
    BOOL            reduce using rule 51 (sign -> MOD .)
    LBRACKET_S      reduce using rule 51 (sign -> MOD .)


state 63

    (52) sign -> EQUAL .

    LPAREN          reduce using rule 52 (sign -> EQUAL .)
    NOT             reduce using rule 52 (sign -> EQUAL .)
    IDENTIFIER      reduce using rule 52 (sign -> EQUAL .)
    INTEGER         reduce using rule 52 (sign -> EQUAL .)
    FLOAT           reduce using rule 52 (sign -> EQUAL .)
    STRING          reduce using rule 52 (sign -> EQUAL .)
    BOOL            reduce using rule 52 (sign -> EQUAL .)
    LBRACKET_S      reduce using rule 52 (sign -> EQUAL .)


state 64

    (53) sign -> NEQUAL .

    LPAREN          reduce using rule 53 (sign -> NEQUAL .)
    NOT             reduce using rule 53 (sign -> NEQUAL .)
    IDENTIFIER      reduce using rule 53 (sign -> NEQUAL .)
    INTEGER         reduce using rule 53 (sign -> NEQUAL .)
    FLOAT           reduce using rule 53 (sign -> NEQUAL .)
    STRING          reduce using rule 53 (sign -> NEQUAL .)
    BOOL            reduce using rule 53 (sign -> NEQUAL .)
    LBRACKET_S      reduce using rule 53 (sign -> NEQUAL .)


state 65

    (54) sign -> LT .

    LPAREN          reduce using rule 54 (sign -> LT .)
    NOT             reduce using rule 54 (sign -> LT .)
    IDENTIFIER      reduce using rule 54 (sign -> LT .)
    INTEGER         reduce using rule 54 (sign -> LT .)
    FLOAT           reduce using rule 54 (sign -> LT .)
    STRING          reduce using rule 54 (sign -> LT .)
    BOOL            reduce using rule 54 (sign -> LT .)
    LBRACKET_S      reduce using rule 54 (sign -> LT .)


state 66

    (55) sign -> LTE .

    LPAREN          reduce using rule 55 (sign -> LTE .)
    NOT             reduce using rule 55 (sign -> LTE .)
    IDENTIFIER      reduce using rule 55 (sign -> LTE .)
    INTEGER         reduce using rule 55 (sign -> LTE .)
    FLOAT           reduce using rule 55 (sign -> LTE .)
    STRING          reduce using rule 55 (sign -> LTE .)
    BOOL            reduce using rule 55 (sign -> LTE .)
    LBRACKET_S      reduce using rule 55 (sign -> LTE .)


state 67

    (56) sign -> GT .

    LPAREN          reduce using rule 56 (sign -> GT .)
    NOT             reduce using rule 56 (sign -> GT .)
    IDENTIFIER      reduce using rule 56 (sign -> GT .)
    INTEGER         reduce using rule 56 (sign -> GT .)
    FLOAT           reduce using rule 56 (sign -> GT .)
    STRING          reduce using rule 56 (sign -> GT .)
    BOOL            reduce using rule 56 (sign -> GT .)
    LBRACKET_S      reduce using rule 56 (sign -> GT .)


state 68

    (57) sign -> GTE .

    LPAREN          reduce using rule 57 (sign -> GTE .)
    NOT             reduce using rule 57 (sign -> GTE .)
    IDENTIFIER      reduce using rule 57 (sign -> GTE .)
    INTEGER         reduce using rule 57 (sign -> GTE .)
    FLOAT           reduce using rule 57 (sign -> GTE .)
    STRING          reduce using rule 57 (sign -> GTE .)
    BOOL            reduce using rule 57 (sign -> GTE .)
    LBRACKET_S      reduce using rule 57 (sign -> GTE .)


state 69

    (65) expression_e -> NOT expression .
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    TIMES           reduce using rule 65 (expression_e -> NOT expression .)
    DIV             reduce using rule 65 (expression_e -> NOT expression .)
    PLUS            reduce using rule 65 (expression_e -> NOT expression .)
    MINUS           reduce using rule 65 (expression_e -> NOT expression .)
    MOD             reduce using rule 65 (expression_e -> NOT expression .)
    EQUAL           reduce using rule 65 (expression_e -> NOT expression .)
    NEQUAL          reduce using rule 65 (expression_e -> NOT expression .)
    LT              reduce using rule 65 (expression_e -> NOT expression .)
    LTE             reduce using rule 65 (expression_e -> NOT expression .)
    GT              reduce using rule 65 (expression_e -> NOT expression .)
    GTE             reduce using rule 65 (expression_e -> NOT expression .)
    SEMICOLON       reduce using rule 65 (expression_e -> NOT expression .)
    RBRACKET_S      reduce using rule 65 (expression_e -> NOT expression .)
    LBRACKET        reduce using rule 65 (expression_e -> NOT expression .)
    IF              reduce using rule 65 (expression_e -> NOT expression .)
    WHILE           reduce using rule 65 (expression_e -> NOT expression .)
    RETURN          reduce using rule 65 (expression_e -> NOT expression .)
    IDENTIFIER      reduce using rule 65 (expression_e -> NOT expression .)
    LPAREN          reduce using rule 65 (expression_e -> NOT expression .)
    NOT             reduce using rule 65 (expression_e -> NOT expression .)
    INTEGER         reduce using rule 65 (expression_e -> NOT expression .)
    FLOAT           reduce using rule 65 (expression_e -> NOT expression .)
    STRING          reduce using rule 65 (expression_e -> NOT expression .)
    BOOL            reduce using rule 65 (expression_e -> NOT expression .)
    LBRACKET_S      reduce using rule 65 (expression_e -> NOT expression .)
    ELSE            reduce using rule 65 (expression_e -> NOT expression .)
    $end            reduce using rule 65 (expression_e -> NOT expression .)
    RBRACKET        reduce using rule 65 (expression_e -> NOT expression .)
    RPAREN          reduce using rule 65 (expression_e -> NOT expression .)
    COMMA           reduce using rule 65 (expression_e -> NOT expression .)
    AND             shift and go to state 44
    OR              shift and go to state 45

  ! AND             [ reduce using rule 65 (expression_e -> NOT expression .) ]
  ! OR              [ reduce using rule 65 (expression_e -> NOT expression .) ]

    and_or                         shift and go to state 43

state 70

    (8) function_declaration -> identifier COLON type . LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON type . SEMICOLON
    (6) variable_declaration -> identifier COLON type . ASSIGNMENT expression SEMICOLON
    (9) function_heading -> identifier COLON type . LPAREN parameter_list RPAREN

    LPAREN          shift and go to state 92
    SEMICOLON       shift and go to state 93
    ASSIGNMENT      shift and go to state 94


state 71

    (76) type -> TINTEGER .

    LPAREN          reduce using rule 76 (type -> TINTEGER .)
    SEMICOLON       reduce using rule 76 (type -> TINTEGER .)
    ASSIGNMENT      reduce using rule 76 (type -> TINTEGER .)
    RBRACKET_S      reduce using rule 76 (type -> TINTEGER .)
    COMMA           reduce using rule 76 (type -> TINTEGER .)
    RPAREN          reduce using rule 76 (type -> TINTEGER .)


state 72

    (77) type -> TFLOAT .

    LPAREN          reduce using rule 77 (type -> TFLOAT .)
    SEMICOLON       reduce using rule 77 (type -> TFLOAT .)
    ASSIGNMENT      reduce using rule 77 (type -> TFLOAT .)
    RBRACKET_S      reduce using rule 77 (type -> TFLOAT .)
    COMMA           reduce using rule 77 (type -> TFLOAT .)
    RPAREN          reduce using rule 77 (type -> TFLOAT .)


state 73

    (78) type -> TSTRING .

    LPAREN          reduce using rule 78 (type -> TSTRING .)
    SEMICOLON       reduce using rule 78 (type -> TSTRING .)
    ASSIGNMENT      reduce using rule 78 (type -> TSTRING .)
    RBRACKET_S      reduce using rule 78 (type -> TSTRING .)
    COMMA           reduce using rule 78 (type -> TSTRING .)
    RPAREN          reduce using rule 78 (type -> TSTRING .)


state 74

    (79) type -> TBOOL .

    LPAREN          reduce using rule 79 (type -> TBOOL .)
    SEMICOLON       reduce using rule 79 (type -> TBOOL .)
    ASSIGNMENT      reduce using rule 79 (type -> TBOOL .)
    RBRACKET_S      reduce using rule 79 (type -> TBOOL .)
    COMMA           reduce using rule 79 (type -> TBOOL .)
    RPAREN          reduce using rule 79 (type -> TBOOL .)


state 75

    (80) type -> LBRACKET_S . type RBRACKET_S
    (76) type -> . TINTEGER
    (77) type -> . TFLOAT
    (78) type -> . TSTRING
    (79) type -> . TBOOL
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 95

state 76

    (42) expression -> expression and_or expression_m .
    (44) expression_m -> expression_m . sign expression_e
    (47) sign -> . TIMES
    (48) sign -> . DIV
    (49) sign -> . PLUS
    (50) sign -> . MINUS
    (51) sign -> . MOD
    (52) sign -> . EQUAL
    (53) sign -> . NEQUAL
    (54) sign -> . LT
    (55) sign -> . LTE
    (56) sign -> . GT
    (57) sign -> . GTE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
    SEMICOLON       reduce using rule 42 (expression -> expression and_or expression_m .)
    AND             reduce using rule 42 (expression -> expression and_or expression_m .)
    OR              reduce using rule 42 (expression -> expression and_or expression_m .)
    RBRACKET_S      reduce using rule 42 (expression -> expression and_or expression_m .)
    LBRACKET        reduce using rule 42 (expression -> expression and_or expression_m .)
    IF              reduce using rule 42 (expression -> expression and_or expression_m .)
    WHILE           reduce using rule 42 (expression -> expression and_or expression_m .)
    RETURN          reduce using rule 42 (expression -> expression and_or expression_m .)
    IDENTIFIER      reduce using rule 42 (expression -> expression and_or expression_m .)
    LPAREN          reduce using rule 42 (expression -> expression and_or expression_m .)
    NOT             reduce using rule 42 (expression -> expression and_or expression_m .)
    INTEGER         reduce using rule 42 (expression -> expression and_or expression_m .)
    FLOAT           reduce using rule 42 (expression -> expression and_or expression_m .)
    STRING          reduce using rule 42 (expression -> expression and_or expression_m .)
    BOOL            reduce using rule 42 (expression -> expression and_or expression_m .)
    LBRACKET_S      reduce using rule 42 (expression -> expression and_or expression_m .)
    ELSE            reduce using rule 42 (expression -> expression and_or expression_m .)
    $end            reduce using rule 42 (expression -> expression and_or expression_m .)
    RBRACKET        reduce using rule 42 (expression -> expression and_or expression_m .)
    RPAREN          reduce using rule 42 (expression -> expression and_or expression_m .)
    COMMA           reduce using rule 42 (expression -> expression and_or expression_m .)
    TIMES           shift and go to state 58
    DIV             shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    MOD             shift and go to state 62
    EQUAL           shift and go to state 63
    NEQUAL          shift and go to state 64
    LT              shift and go to state 65
    LTE             shift and go to state 66
    GT              shift and go to state 67
    GTE             shift and go to state 68

  ! TIMES           [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! DIV             [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! PLUS            [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! MINUS           [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! MOD             [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! EQUAL           [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! NEQUAL          [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! LT              [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! LTE             [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! GT              [ reduce using rule 42 (expression -> expression and_or expression_m .) ]
  ! GTE             [ reduce using rule 42 (expression -> expression and_or expression_m .) ]

    sign                           shift and go to state 57

state 77

    (14) statement_part -> LBRACKET statement_sequence RBRACKET .

    IDENTIFIER      reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    $end            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LBRACKET        reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    IF              reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    WHILE           reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RETURN          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LPAREN          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    NOT             reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    INTEGER         reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    FLOAT           reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    STRING          reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    BOOL            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LBRACKET_S      reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RBRACKET        reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    ELSE            reduce using rule 14 (statement_part -> LBRACKET statement_sequence RBRACKET .)


state 78

    (15) statement_sequence -> statement statement_sequence .

    RBRACKET        reduce using rule 15 (statement_sequence -> statement statement_sequence .)


state 79

    (34) assignment_statement -> identifier COLON type . ASSIGNMENT expression SEMICOLON
    (36) array_def -> identifier COLON type . SEMICOLON

    ASSIGNMENT      shift and go to state 96
    SEMICOLON       shift and go to state 97


state 80

    (35) assignment_statement -> identifier LBRACKET_S expression . RBRACKET_S ASSIGNMENT expression SEMICOLON
    (29) array_call -> identifier LBRACKET_S expression . RBRACKET_S SEMICOLON
    (69) array_call_inline -> identifier LBRACKET_S expression . RBRACKET_S
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    RBRACKET_S      shift and go to state 98
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 81

    (28) function_call -> identifier LPAREN param_list . RPAREN SEMICOLON
    (68) function_call_inline -> identifier LPAREN param_list . RPAREN

    RPAREN          shift and go to state 99


state 82

    (30) param_list -> param . COMMA param_list
    (31) param_list -> param .

    COMMA           shift and go to state 100
    RPAREN          reduce using rule 31 (param_list -> param .)


state 83

    (33) param -> expression .
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    COMMA           reduce using rule 33 (param -> expression .)
    RPAREN          reduce using rule 33 (param -> expression .)
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 84

    (75) array -> LBRACKET_S expression RBRACKET_S .

    TIMES           reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    RBRACKET_S      reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    LBRACKET        reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    IF              reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    WHILE           reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    RETURN          reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    IDENTIFIER      reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    LPAREN          reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    NOT             reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    INTEGER         reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    FLOAT           reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    STRING          reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    BOOL            reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    LBRACKET_S      reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    ELSE            reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    $end            reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    RBRACKET        reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    RPAREN          reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)
    COMMA           reduce using rule 75 (array -> LBRACKET_S expression RBRACKET_S .)


state 85

    (68) function_call_inline -> identifier LPAREN . param_list RPAREN
    (30) param_list -> . param COMMA param_list
    (31) param_list -> . param
    (32) param_list -> .
    (33) param -> . expression
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    RPAREN          reduce using rule 32 (param_list -> .)
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    identifier                     shift and go to state 52
    param_list                     shift and go to state 101
    param                          shift and go to state 82
    expression                     shift and go to state 83
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 86

    (69) array_call_inline -> identifier LBRACKET_S . expression RBRACKET_S
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    identifier                     shift and go to state 52
    expression                     shift and go to state 102
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 87

    (37) if_statement -> IF expression body . ELSE body
    (38) if_statement -> IF expression body .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 103
    IDENTIFIER      reduce using rule 38 (if_statement -> IF expression body .)
    $end            reduce using rule 38 (if_statement -> IF expression body .)
    LBRACKET        reduce using rule 38 (if_statement -> IF expression body .)
    IF              reduce using rule 38 (if_statement -> IF expression body .)
    WHILE           reduce using rule 38 (if_statement -> IF expression body .)
    RETURN          reduce using rule 38 (if_statement -> IF expression body .)
    LPAREN          reduce using rule 38 (if_statement -> IF expression body .)
    NOT             reduce using rule 38 (if_statement -> IF expression body .)
    INTEGER         reduce using rule 38 (if_statement -> IF expression body .)
    FLOAT           reduce using rule 38 (if_statement -> IF expression body .)
    STRING          reduce using rule 38 (if_statement -> IF expression body .)
    BOOL            reduce using rule 38 (if_statement -> IF expression body .)
    LBRACKET_S      reduce using rule 38 (if_statement -> IF expression body .)
    RBRACKET        reduce using rule 38 (if_statement -> IF expression body .)

  ! ELSE            [ reduce using rule 38 (if_statement -> IF expression body .) ]


state 88

    (39) while_statement -> WHILE expression body .

    IDENTIFIER      reduce using rule 39 (while_statement -> WHILE expression body .)
    $end            reduce using rule 39 (while_statement -> WHILE expression body .)
    LBRACKET        reduce using rule 39 (while_statement -> WHILE expression body .)
    IF              reduce using rule 39 (while_statement -> WHILE expression body .)
    WHILE           reduce using rule 39 (while_statement -> WHILE expression body .)
    RETURN          reduce using rule 39 (while_statement -> WHILE expression body .)
    LPAREN          reduce using rule 39 (while_statement -> WHILE expression body .)
    NOT             reduce using rule 39 (while_statement -> WHILE expression body .)
    INTEGER         reduce using rule 39 (while_statement -> WHILE expression body .)
    FLOAT           reduce using rule 39 (while_statement -> WHILE expression body .)
    STRING          reduce using rule 39 (while_statement -> WHILE expression body .)
    BOOL            reduce using rule 39 (while_statement -> WHILE expression body .)
    LBRACKET_S      reduce using rule 39 (while_statement -> WHILE expression body .)
    RBRACKET        reduce using rule 39 (while_statement -> WHILE expression body .)
    ELSE            reduce using rule 39 (while_statement -> WHILE expression body .)


state 89

    (40) return_statement -> RETURN expression SEMICOLON .

    IDENTIFIER      reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    LBRACKET        reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    BOOL            reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    LBRACKET_S      reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    RBRACKET        reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 40 (return_statement -> RETURN expression SEMICOLON .)


state 90

    (64) expression_e -> LPAREN expression RPAREN .

    TIMES           reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    DIV             reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    MOD             reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    NEQUAL          reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    LT              reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    LTE             reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    GT              reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    GTE             reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    AND             reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    OR              reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    RBRACKET_S      reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    IF              reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    NOT             reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    STRING          reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    BOOL            reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    LBRACKET_S      reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    $end            reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 64 (expression_e -> LPAREN expression RPAREN .)


state 91

    (44) expression_m -> expression_m sign expression_e .

    TIMES           reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    DIV             reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    PLUS            reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    MINUS           reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    MOD             reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    EQUAL           reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    NEQUAL          reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    LT              reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    LTE             reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    GT              reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    GTE             reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    SEMICOLON       reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    AND             reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    OR              reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    RBRACKET_S      reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    LBRACKET        reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    IF              reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    WHILE           reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    RETURN          reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    IDENTIFIER      reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    LPAREN          reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    NOT             reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    INTEGER         reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    FLOAT           reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    STRING          reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    BOOL            reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    LBRACKET_S      reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    ELSE            reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    $end            reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    RBRACKET        reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    RPAREN          reduce using rule 44 (expression_m -> expression_m sign expression_e .)
    COMMA           reduce using rule 44 (expression_m -> expression_m sign expression_e .)


state 92

    (8) function_declaration -> identifier COLON type LPAREN . parameter_list RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN . parameter_list RPAREN
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter_list -> .
    (13) parameter -> . identifier COLON type
    (70) identifier -> . IDENTIFIER

    RPAREN          reduce using rule 12 (parameter_list -> .)
    IDENTIFIER      shift and go to state 7

    identifier                     shift and go to state 104
    parameter_list                 shift and go to state 105
    parameter                      shift and go to state 106

state 93

    (5) variable_declaration -> identifier COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)
    $end            reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)


state 94

    (6) variable_declaration -> identifier COLON type ASSIGNMENT . expression SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    identifier                     shift and go to state 52
    expression                     shift and go to state 107
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 95

    (80) type -> LBRACKET_S type . RBRACKET_S

    RBRACKET_S      shift and go to state 108


state 96

    (34) assignment_statement -> identifier COLON type ASSIGNMENT . expression SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    identifier                     shift and go to state 52
    expression                     shift and go to state 109
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 97

    (36) array_def -> identifier COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    $end            reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    LBRACKET        reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    IF              reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    WHILE           reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    RETURN          reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    LPAREN          reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    NOT             reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    INTEGER         reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    FLOAT           reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    STRING          reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    BOOL            reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    LBRACKET_S      reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    RBRACKET        reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)
    ELSE            reduce using rule 36 (array_def -> identifier COLON type SEMICOLON .)


state 98

    (35) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S . ASSIGNMENT expression SEMICOLON
    (29) array_call -> identifier LBRACKET_S expression RBRACKET_S . SEMICOLON
    (69) array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    ASSIGNMENT      shift and go to state 110
    SEMICOLON       shift and go to state 111
    TIMES           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)

  ! SEMICOLON       [ reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .) ]


state 99

    (28) function_call -> identifier LPAREN param_list RPAREN . SEMICOLON
    (68) function_call_inline -> identifier LPAREN param_list RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 112
    TIMES           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    DIV             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    PLUS            reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    MINUS           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    MOD             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    EQUAL           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    NEQUAL          reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LT              reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LTE             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    GT              reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    GTE             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    AND             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    OR              reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)

  ! SEMICOLON       [ reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .) ]


state 100

    (30) param_list -> param COMMA . param_list
    (30) param_list -> . param COMMA param_list
    (31) param_list -> . param
    (32) param_list -> .
    (33) param -> . expression
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    RPAREN          reduce using rule 32 (param_list -> .)
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    param                          shift and go to state 82
    param_list                     shift and go to state 113
    expression                     shift and go to state 83
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    identifier                     shift and go to state 52
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 101

    (68) function_call_inline -> identifier LPAREN param_list . RPAREN

    RPAREN          shift and go to state 114


state 102

    (69) array_call_inline -> identifier LBRACKET_S expression . RBRACKET_S
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    RBRACKET_S      shift and go to state 115
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 103

    (37) if_statement -> IF expression body ELSE . body
    (27) body -> . statement
    (17) statement -> . statement_part
    (18) statement -> . assignment_statement
    (19) statement -> . array_def
    (20) statement -> . if_statement
    (21) statement -> . while_statement
    (22) statement -> . return_statement
    (23) statement -> . function_call
    (24) statement -> . array_call
    (25) statement -> . expression SEMICOLON
    (26) statement -> .
    (14) statement_part -> . LBRACKET statement_sequence RBRACKET
    (34) assignment_statement -> . identifier COLON type ASSIGNMENT expression SEMICOLON
    (35) assignment_statement -> . identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON
    (36) array_def -> . identifier COLON type SEMICOLON
    (37) if_statement -> . IF expression body ELSE body
    (38) if_statement -> . IF expression body
    (39) while_statement -> . WHILE expression body
    (40) return_statement -> . RETURN expression SEMICOLON
    (28) function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (29) array_call -> . identifier LBRACKET_S expression RBRACKET_S SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (70) identifier -> . IDENTIFIER
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LBRACKET_S resolved as shift
    ELSE            reduce using rule 26 (statement -> .)
    $end            reduce using rule 26 (statement -> .)
    RBRACKET        reduce using rule 26 (statement -> .)
    LBRACKET        shift and go to state 20
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    RETURN          shift and go to state 25
    IDENTIFIER      shift and go to state 7
    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

  ! IDENTIFIER      [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 26 (statement -> .) ]
  ! IF              [ reduce using rule 26 (statement -> .) ]
  ! WHILE           [ reduce using rule 26 (statement -> .) ]
  ! RETURN          [ reduce using rule 26 (statement -> .) ]
  ! LPAREN          [ reduce using rule 26 (statement -> .) ]
  ! NOT             [ reduce using rule 26 (statement -> .) ]
  ! INTEGER         [ reduce using rule 26 (statement -> .) ]
  ! FLOAT           [ reduce using rule 26 (statement -> .) ]
  ! STRING          [ reduce using rule 26 (statement -> .) ]
  ! BOOL            [ reduce using rule 26 (statement -> .) ]
  ! LBRACKET_S      [ reduce using rule 26 (statement -> .) ]

    expression                     shift and go to state 19
    body                           shift and go to state 116
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    array_def                      shift and go to state 13
    if_statement                   shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_call                  shift and go to state 17
    array_call                     shift and go to state 18
    identifier                     shift and go to state 21
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 104

    (13) parameter -> identifier . COLON type

    COLON           shift and go to state 117


state 105

    (8) function_declaration -> identifier COLON type LPAREN parameter_list . RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list . RPAREN

    RPAREN          shift and go to state 118


state 106

    (10) parameter_list -> parameter . COMMA parameter_list
    (11) parameter_list -> parameter .

    COMMA           shift and go to state 119
    RPAREN          reduce using rule 11 (parameter_list -> parameter .)


state 107

    (6) variable_declaration -> identifier COLON type ASSIGNMENT expression . SEMICOLON
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    SEMICOLON       shift and go to state 120
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 108

    (80) type -> LBRACKET_S type RBRACKET_S .

    LPAREN          reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    SEMICOLON       reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    ASSIGNMENT      reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    RBRACKET_S      reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    COMMA           reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)
    RPAREN          reduce using rule 80 (type -> LBRACKET_S type RBRACKET_S .)


state 109

    (34) assignment_statement -> identifier COLON type ASSIGNMENT expression . SEMICOLON
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    SEMICOLON       shift and go to state 121
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 110

    (35) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT . expression SEMICOLON
    (41) expression -> . expression_m
    (42) expression -> . expression and_or expression_m
    (43) expression_m -> . expression_e
    (44) expression_m -> . expression_m sign expression_e
    (58) expression_e -> . identifier
    (59) expression_e -> . integer
    (60) expression_e -> . float
    (61) expression_e -> . string
    (62) expression_e -> . bool
    (63) expression_e -> . array
    (64) expression_e -> . LPAREN expression RPAREN
    (65) expression_e -> . NOT expression
    (66) expression_e -> . function_call_inline
    (67) expression_e -> . array_call_inline
    (70) identifier -> . IDENTIFIER
    (71) integer -> . INTEGER
    (72) float -> . FLOAT
    (73) string -> . STRING
    (74) bool -> . BOOL
    (75) array -> . LBRACKET_S expression RBRACKET_S
    (68) function_call_inline -> . identifier LPAREN param_list RPAREN
    (69) array_call_inline -> . identifier LBRACKET_S expression RBRACKET_S

    LPAREN          shift and go to state 26
    NOT             shift and go to state 34
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39
    BOOL            shift and go to state 40
    LBRACKET_S      shift and go to state 22

    identifier                     shift and go to state 52
    expression                     shift and go to state 122
    expression_m                   shift and go to state 27
    expression_e                   shift and go to state 28
    integer                        shift and go to state 29
    float                          shift and go to state 30
    string                         shift and go to state 31
    bool                           shift and go to state 32
    array                          shift and go to state 33
    function_call_inline           shift and go to state 35
    array_call_inline              shift and go to state 36

state 111

    (29) array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .

    IDENTIFIER      reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    $end            reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    LBRACKET        reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    IF              reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    WHILE           reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    RETURN          reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    LPAREN          reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    NOT             reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    INTEGER         reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    FLOAT           reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    STRING          reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    BOOL            reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    LBRACKET_S      reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    RBRACKET        reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)
    ELSE            reduce using rule 29 (array_call -> identifier LBRACKET_S expression RBRACKET_S SEMICOLON .)


state 112

    (28) function_call -> identifier LPAREN param_list RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    $end            reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    IF              reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    LPAREN          reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    NOT             reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    INTEGER         reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    STRING          reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    BOOL            reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    LBRACKET_S      reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    ELSE            reduce using rule 28 (function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)


state 113

    (30) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 30 (param_list -> param COMMA param_list .)


state 114

    (68) function_call_inline -> identifier LPAREN param_list RPAREN .

    TIMES           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    DIV             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    PLUS            reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    MINUS           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    MOD             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    EQUAL           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    NEQUAL          reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LT              reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LTE             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    GT              reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    GTE             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    RBRACKET_S      reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    AND             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    OR              reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LBRACKET        reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    IF              reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    WHILE           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    RETURN          reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    IDENTIFIER      reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LPAREN          reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    NOT             reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    INTEGER         reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    FLOAT           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    STRING          reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    BOOL            reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    LBRACKET_S      reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    ELSE            reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    $end            reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    RBRACKET        reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    SEMICOLON       reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    RPAREN          reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)
    COMMA           reduce using rule 68 (function_call_inline -> identifier LPAREN param_list RPAREN .)


state 115

    (69) array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .

    TIMES           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    DIV             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    PLUS            reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    MINUS           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    MOD             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    EQUAL           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    NEQUAL          reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    LT              reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    LTE             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    GT              reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    GTE             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    RBRACKET_S      reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    AND             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    OR              reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    LBRACKET        reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    IF              reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    WHILE           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    RETURN          reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    IDENTIFIER      reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    LPAREN          reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    NOT             reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    INTEGER         reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    FLOAT           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    STRING          reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    BOOL            reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    LBRACKET_S      reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    ELSE            reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    $end            reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    RBRACKET        reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    SEMICOLON       reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    RPAREN          reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)
    COMMA           reduce using rule 69 (array_call_inline -> identifier LBRACKET_S expression RBRACKET_S .)


state 116

    (37) if_statement -> IF expression body ELSE body .

    IDENTIFIER      reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    $end            reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    LBRACKET        reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    IF              reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    WHILE           reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    RETURN          reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    LPAREN          reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    NOT             reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    INTEGER         reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    FLOAT           reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    STRING          reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    BOOL            reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    LBRACKET_S      reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    RBRACKET        reduce using rule 37 (if_statement -> IF expression body ELSE body .)
    ELSE            reduce using rule 37 (if_statement -> IF expression body ELSE body .)


state 117

    (13) parameter -> identifier COLON . type
    (76) type -> . TINTEGER
    (77) type -> . TFLOAT
    (78) type -> . TSTRING
    (79) type -> . TBOOL
    (80) type -> . LBRACKET_S type RBRACKET_S

    TINTEGER        shift and go to state 71
    TFLOAT          shift and go to state 72
    TSTRING         shift and go to state 73
    TBOOL           shift and go to state 74
    LBRACKET_S      shift and go to state 75

    type                           shift and go to state 123

state 118

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN . SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list RPAREN .

    SEMICOLON       shift and go to state 124
    LBRACKET        reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IF              reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    RETURN          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IDENTIFIER      reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    LPAREN          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    NOT             reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    INTEGER         reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    FLOAT           reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    STRING          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    BOOL            reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    LBRACKET_S      reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    $end            reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)


state 119

    (10) parameter_list -> parameter COMMA . parameter_list
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter_list -> .
    (13) parameter -> . identifier COLON type
    (70) identifier -> . IDENTIFIER

    RPAREN          reduce using rule 12 (parameter_list -> .)
    IDENTIFIER      shift and go to state 7

    parameter                      shift and go to state 106
    parameter_list                 shift and go to state 125
    identifier                     shift and go to state 104

state 120

    (6) variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT expression SEMICOLON .)


state 121

    (34) assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 34 (assignment_statement -> identifier COLON type ASSIGNMENT expression SEMICOLON .)


state 122

    (35) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression . SEMICOLON
    (42) expression -> expression . and_or expression_m
    (45) and_or -> . AND
    (46) and_or -> . OR

    SEMICOLON       shift and go to state 126
    AND             shift and go to state 44
    OR              shift and go to state 45

    and_or                         shift and go to state 43

state 123

    (13) parameter -> identifier COLON type .

    COMMA           reduce using rule 13 (parameter -> identifier COLON type .)
    RPAREN          reduce using rule 13 (parameter -> identifier COLON type .)


state 124

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)
    $end            reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)


state 125

    (10) parameter_list -> parameter COMMA parameter_list .

    RPAREN          reduce using rule 10 (parameter_list -> parameter COMMA parameter_list .)


state 126

    (35) assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .

    IDENTIFIER      reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LBRACKET        reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    RETURN          reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LPAREN          reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    NOT             reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    INTEGER         reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    FLOAT           reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    LBRACKET_S      reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)
    ELSE            reduce using rule 35 (assignment_statement -> identifier LBRACKET_S expression RBRACKET_S ASSIGNMENT expression SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 5 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 20 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 20 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 20 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 20 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 20 resolved as shift
WARNING: shift/reduce conflict for NOT in state 20 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 20 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 20 resolved as shift
WARNING: shift/reduce conflict for STRING in state 20 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 20 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 20 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 27 resolved as shift
WARNING: shift/reduce conflict for DIV in state 27 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 27 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 27 resolved as shift
WARNING: shift/reduce conflict for MOD in state 27 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 27 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 27 resolved as shift
WARNING: shift/reduce conflict for LT in state 27 resolved as shift
WARNING: shift/reduce conflict for LTE in state 27 resolved as shift
WARNING: shift/reduce conflict for GT in state 27 resolved as shift
WARNING: shift/reduce conflict for GTE in state 27 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 47 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 47 resolved as shift
WARNING: shift/reduce conflict for NOT in state 47 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 47 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 47 resolved as shift
WARNING: shift/reduce conflict for STRING in state 47 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 47 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 47 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 52 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 52 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 53 resolved as shift
WARNING: shift/reduce conflict for IF in state 53 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 53 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 53 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 53 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 53 resolved as shift
WARNING: shift/reduce conflict for NOT in state 53 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 53 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 53 resolved as shift
WARNING: shift/reduce conflict for STRING in state 53 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 54 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 54 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 54 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 54 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 54 resolved as shift
WARNING: shift/reduce conflict for NOT in state 54 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 54 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 54 resolved as shift
WARNING: shift/reduce conflict for STRING in state 54 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 54 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 54 resolved as shift
WARNING: shift/reduce conflict for AND in state 69 resolved as shift
WARNING: shift/reduce conflict for OR in state 69 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 76 resolved as shift
WARNING: shift/reduce conflict for DIV in state 76 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MOD in state 76 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for LT in state 76 resolved as shift
WARNING: shift/reduce conflict for LTE in state 76 resolved as shift
WARNING: shift/reduce conflict for GT in state 76 resolved as shift
WARNING: shift/reduce conflict for GTE in state 76 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 87 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 98 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 99 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 103 resolved as shift
WARNING: shift/reduce conflict for IF in state 103 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 103 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 103 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 103 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 103 resolved as shift
WARNING: shift/reduce conflict for NOT in state 103 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 103 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 103 resolved as shift
WARNING: shift/reduce conflict for STRING in state 103 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 103 resolved as shift
WARNING: shift/reduce conflict for LBRACKET_S in state 103 resolved as shift
WARNING: reduce/reduce conflict in state 47 resolved using rule (statement_sequence -> statement)
WARNING: rejected rule (statement -> <empty>) in state 47
