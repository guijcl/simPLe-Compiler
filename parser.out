Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    COMMENTBEGIN
    COMMENTEND
    TVOID
    VOID

Grammar

Rule 0     S' -> definition_sequence
Rule 1     definition_sequence -> definition definition_sequence
Rule 2     definition_sequence -> definition
Rule 3     definition -> function_declaration
Rule 4     definition -> variable_declaration
Rule 5     variable_declaration -> identifier COLON type SEMICOLON
Rule 6     variable_declaration -> identifier COLON type ASSIGNMENT element SEMICOLON
Rule 7     function_declaration -> function_heading body
Rule 8     function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
Rule 9     function_heading -> identifier COLON type LPAREN parameter_list RPAREN
Rule 10    parameter_list -> parameter COMMA parameter_list
Rule 11    parameter_list -> parameter
Rule 12    parameter -> identifier COLON type
Rule 13    statement_part -> LBRACKET statement_sequence RBRACKET
Rule 14    statement_sequence -> statement statement_sequence
Rule 15    statement_sequence -> statement
Rule 16    statement -> statement_part
Rule 17    statement -> assignment_statement
Rule 18    statement -> if_statement
Rule 19    statement -> while_statement
Rule 20    statement -> return_statement
Rule 21    statement -> procedure_or_function_call
Rule 22    statement -> array
Rule 23    statement -> <empty>
Rule 24    body -> statement
Rule 25    procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON
Rule 26    procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON
Rule 27    param_list -> param_list COMMA param
Rule 28    param_list -> param
Rule 29    param -> expression
Rule 30    assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON
Rule 31    if_statement -> IF expression body ELSE body
Rule 32    if_statement -> IF expression body
Rule 33    while_statement -> WHILE expression body
Rule 34    return_statement -> RETURN element SEMICOLON
Rule 35    expression -> expression_m
Rule 36    expression -> expression and_or expression_m
Rule 37    expression_m -> expression_s
Rule 38    expression_m -> expression_m sign expression_s
Rule 39    expression_s -> element
Rule 40    expression_s -> expression_s psign element
Rule 41    and_or -> AND
Rule 42    and_or -> OR
Rule 43    psign -> TIMES
Rule 44    psign -> DIV
Rule 45    sign -> PLUS
Rule 46    sign -> MINUS
Rule 47    sign -> MOD
Rule 48    sign -> EQUAL
Rule 49    sign -> NEQUAL
Rule 50    sign -> LT
Rule 51    sign -> LTE
Rule 52    sign -> GT
Rule 53    sign -> GTE
Rule 54    element -> identifier
Rule 55    element -> integer
Rule 56    element -> float
Rule 57    element -> string
Rule 58    element -> bool
Rule 59    element -> LPAREN expression RPAREN
Rule 60    element -> NOT element
Rule 61    identifier -> IDENTIFIER
Rule 62    integer -> INTEGER
Rule 63    float -> FLOAT
Rule 64    string -> STRING
Rule 65    bool -> BOOL
Rule 66    array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON
Rule 67    type -> TINTEGER
Rule 68    type -> TFLOAT
Rule 69    type -> TSTRING
Rule 70    type -> TBOOL
Rule 71    type -> TARRAY

Terminals, with rules where they appear

AND                  : 41
ARRAY                : 
ASSIGNMENT           : 6 30
BOOL                 : 65
COLON                : 5 6 8 9 12 30
COMMA                : 10 27
COMMENTBEGIN         : 
COMMENTEND           : 
DIV                  : 44
ELSE                 : 31
EQUAL                : 48
FLOAT                : 63
GT                   : 52
GTE                  : 53
IDENTIFIER           : 61
IF                   : 31 32
INTEGER              : 62
LBRACKET             : 13
LBRACKET_S           : 66
LPAREN               : 8 9 25 26 59
LT                   : 50
LTE                  : 51
MINUS                : 46
MOD                  : 47
NEQUAL               : 49
NOT                  : 60
OR                   : 42
PLUS                 : 45
RBRACKET             : 13
RBRACKET_S           : 66
RETURN               : 34
RPAREN               : 8 9 25 26 59
SEMICOLON            : 5 6 8 25 26 30 34 66
STRING               : 64
TARRAY               : 71
TBOOL                : 70
TFLOAT               : 68
TIMES                : 43
TINTEGER             : 67
TSTRING              : 69
TVOID                : 
VOID                 : 
WHILE                : 33
error                : 

Nonterminals, with rules where they appear

and_or               : 36
array                : 22
assignment_statement : 17
body                 : 7 31 31 32 33
bool                 : 58
definition           : 1 2
definition_sequence  : 1 0
element              : 6 30 34 39 40 60
expression           : 29 31 32 33 36 59
expression_m         : 35 36 38
expression_s         : 37 38 40
float                : 56
function_declaration : 3
function_heading     : 7
identifier           : 5 6 8 9 12 25 26 30 54 66
if_statement         : 18
integer              : 55 66
param                : 27 28
param_list           : 25 27
parameter            : 10 11
parameter_list       : 8 9 10
procedure_or_function_call : 21
psign                : 40
return_statement     : 20
sign                 : 38
statement            : 14 15 24
statement_part       : 16
statement_sequence   : 13 14
string               : 57
type                 : 5 6 8 9 12 30
variable_declaration : 4
while_statement      : 19

Parsing method: LALR

state 0

    (0) S' -> . definition_sequence
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (61) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 7

    definition_sequence            shift and go to state 1
    definition                     shift and go to state 2
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 1

    (0) S' -> definition_sequence .



state 2

    (1) definition_sequence -> definition . definition_sequence
    (2) definition_sequence -> definition .
    (1) definition_sequence -> . definition definition_sequence
    (2) definition_sequence -> . definition
    (3) definition -> . function_declaration
    (4) definition -> . variable_declaration
    (7) function_declaration -> . function_heading body
    (8) function_declaration -> . identifier COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> . identifier COLON type SEMICOLON
    (6) variable_declaration -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (9) function_heading -> . identifier COLON type LPAREN parameter_list RPAREN
    (61) identifier -> . IDENTIFIER

    $end            reduce using rule 2 (definition_sequence -> definition .)
    IDENTIFIER      shift and go to state 7

    definition                     shift and go to state 2
    definition_sequence            shift and go to state 8
    function_declaration           shift and go to state 3
    variable_declaration           shift and go to state 4
    function_heading               shift and go to state 5
    identifier                     shift and go to state 6

state 3

    (3) definition -> function_declaration .

    IDENTIFIER      reduce using rule 3 (definition -> function_declaration .)
    $end            reduce using rule 3 (definition -> function_declaration .)


state 4

    (4) definition -> variable_declaration .

    IDENTIFIER      reduce using rule 4 (definition -> variable_declaration .)
    $end            reduce using rule 4 (definition -> variable_declaration .)


state 5

    (7) function_declaration -> function_heading . body
    (24) body -> . statement
    (16) statement -> . statement_part
    (17) statement -> . assignment_statement
    (18) statement -> . if_statement
    (19) statement -> . while_statement
    (20) statement -> . return_statement
    (21) statement -> . procedure_or_function_call
    (22) statement -> . array
    (23) statement -> .
    (13) statement_part -> . LBRACKET statement_sequence RBRACKET
    (30) assignment_statement -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (31) if_statement -> . IF expression body ELSE body
    (32) if_statement -> . IF expression body
    (33) while_statement -> . WHILE expression body
    (34) return_statement -> . RETURN element SEMICOLON
    (25) procedure_or_function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> . identifier LPAREN RPAREN SEMICOLON
    (66) array -> . identifier LBRACKET_S integer RBRACKET_S SEMICOLON
    (61) identifier -> . IDENTIFIER

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    $end            reduce using rule 23 (statement -> .)
    LBRACKET        shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 22
    IDENTIFIER      shift and go to state 7

  ! IDENTIFIER      [ reduce using rule 23 (statement -> .) ]

    body                           shift and go to state 9
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    procedure_or_function_call     shift and go to state 16
    array                          shift and go to state 17
    identifier                     shift and go to state 19

state 6

    (8) function_declaration -> identifier . COLON type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier . COLON type SEMICOLON
    (6) variable_declaration -> identifier . COLON type ASSIGNMENT element SEMICOLON
    (9) function_heading -> identifier . COLON type LPAREN parameter_list RPAREN

    COLON           shift and go to state 23


state 7

    (61) identifier -> IDENTIFIER .

    COLON           reduce using rule 61 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET_S      reduce using rule 61 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 61 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 61 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 61 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 61 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 61 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 61 (identifier -> IDENTIFIER .)
    NEQUAL          reduce using rule 61 (identifier -> IDENTIFIER .)
    LT              reduce using rule 61 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 61 (identifier -> IDENTIFIER .)
    GT              reduce using rule 61 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 61 (identifier -> IDENTIFIER .)
    AND             reduce using rule 61 (identifier -> IDENTIFIER .)
    OR              reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        reduce using rule 61 (identifier -> IDENTIFIER .)
    IF              reduce using rule 61 (identifier -> IDENTIFIER .)
    WHILE           reduce using rule 61 (identifier -> IDENTIFIER .)
    RETURN          reduce using rule 61 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 61 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 61 (identifier -> IDENTIFIER .)
    $end            reduce using rule 61 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 61 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 61 (identifier -> IDENTIFIER .)


state 8

    (1) definition_sequence -> definition definition_sequence .

    $end            reduce using rule 1 (definition_sequence -> definition definition_sequence .)


state 9

    (7) function_declaration -> function_heading body .

    IDENTIFIER      reduce using rule 7 (function_declaration -> function_heading body .)
    $end            reduce using rule 7 (function_declaration -> function_heading body .)


state 10

    (24) body -> statement .

    IDENTIFIER      reduce using rule 24 (body -> statement .)
    $end            reduce using rule 24 (body -> statement .)
    ELSE            reduce using rule 24 (body -> statement .)
    LBRACKET        reduce using rule 24 (body -> statement .)
    IF              reduce using rule 24 (body -> statement .)
    WHILE           reduce using rule 24 (body -> statement .)
    RETURN          reduce using rule 24 (body -> statement .)
    RBRACKET        reduce using rule 24 (body -> statement .)


state 11

    (16) statement -> statement_part .

    IDENTIFIER      reduce using rule 16 (statement -> statement_part .)
    $end            reduce using rule 16 (statement -> statement_part .)
    LBRACKET        reduce using rule 16 (statement -> statement_part .)
    IF              reduce using rule 16 (statement -> statement_part .)
    WHILE           reduce using rule 16 (statement -> statement_part .)
    RETURN          reduce using rule 16 (statement -> statement_part .)
    RBRACKET        reduce using rule 16 (statement -> statement_part .)
    ELSE            reduce using rule 16 (statement -> statement_part .)


state 12

    (17) statement -> assignment_statement .

    IDENTIFIER      reduce using rule 17 (statement -> assignment_statement .)
    $end            reduce using rule 17 (statement -> assignment_statement .)
    LBRACKET        reduce using rule 17 (statement -> assignment_statement .)
    IF              reduce using rule 17 (statement -> assignment_statement .)
    WHILE           reduce using rule 17 (statement -> assignment_statement .)
    RETURN          reduce using rule 17 (statement -> assignment_statement .)
    RBRACKET        reduce using rule 17 (statement -> assignment_statement .)
    ELSE            reduce using rule 17 (statement -> assignment_statement .)


state 13

    (18) statement -> if_statement .

    IDENTIFIER      reduce using rule 18 (statement -> if_statement .)
    $end            reduce using rule 18 (statement -> if_statement .)
    LBRACKET        reduce using rule 18 (statement -> if_statement .)
    IF              reduce using rule 18 (statement -> if_statement .)
    WHILE           reduce using rule 18 (statement -> if_statement .)
    RETURN          reduce using rule 18 (statement -> if_statement .)
    RBRACKET        reduce using rule 18 (statement -> if_statement .)
    ELSE            reduce using rule 18 (statement -> if_statement .)


state 14

    (19) statement -> while_statement .

    IDENTIFIER      reduce using rule 19 (statement -> while_statement .)
    $end            reduce using rule 19 (statement -> while_statement .)
    LBRACKET        reduce using rule 19 (statement -> while_statement .)
    IF              reduce using rule 19 (statement -> while_statement .)
    WHILE           reduce using rule 19 (statement -> while_statement .)
    RETURN          reduce using rule 19 (statement -> while_statement .)
    RBRACKET        reduce using rule 19 (statement -> while_statement .)
    ELSE            reduce using rule 19 (statement -> while_statement .)


state 15

    (20) statement -> return_statement .

    IDENTIFIER      reduce using rule 20 (statement -> return_statement .)
    $end            reduce using rule 20 (statement -> return_statement .)
    LBRACKET        reduce using rule 20 (statement -> return_statement .)
    IF              reduce using rule 20 (statement -> return_statement .)
    WHILE           reduce using rule 20 (statement -> return_statement .)
    RETURN          reduce using rule 20 (statement -> return_statement .)
    RBRACKET        reduce using rule 20 (statement -> return_statement .)
    ELSE            reduce using rule 20 (statement -> return_statement .)


state 16

    (21) statement -> procedure_or_function_call .

    IDENTIFIER      reduce using rule 21 (statement -> procedure_or_function_call .)
    $end            reduce using rule 21 (statement -> procedure_or_function_call .)
    LBRACKET        reduce using rule 21 (statement -> procedure_or_function_call .)
    IF              reduce using rule 21 (statement -> procedure_or_function_call .)
    WHILE           reduce using rule 21 (statement -> procedure_or_function_call .)
    RETURN          reduce using rule 21 (statement -> procedure_or_function_call .)
    RBRACKET        reduce using rule 21 (statement -> procedure_or_function_call .)
    ELSE            reduce using rule 21 (statement -> procedure_or_function_call .)


state 17

    (22) statement -> array .

    IDENTIFIER      reduce using rule 22 (statement -> array .)
    $end            reduce using rule 22 (statement -> array .)
    LBRACKET        reduce using rule 22 (statement -> array .)
    IF              reduce using rule 22 (statement -> array .)
    WHILE           reduce using rule 22 (statement -> array .)
    RETURN          reduce using rule 22 (statement -> array .)
    RBRACKET        reduce using rule 22 (statement -> array .)
    ELSE            reduce using rule 22 (statement -> array .)


state 18

    (13) statement_part -> LBRACKET . statement_sequence RBRACKET
    (14) statement_sequence -> . statement statement_sequence
    (15) statement_sequence -> . statement
    (16) statement -> . statement_part
    (17) statement -> . assignment_statement
    (18) statement -> . if_statement
    (19) statement -> . while_statement
    (20) statement -> . return_statement
    (21) statement -> . procedure_or_function_call
    (22) statement -> . array
    (23) statement -> .
    (13) statement_part -> . LBRACKET statement_sequence RBRACKET
    (30) assignment_statement -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (31) if_statement -> . IF expression body ELSE body
    (32) if_statement -> . IF expression body
    (33) while_statement -> . WHILE expression body
    (34) return_statement -> . RETURN element SEMICOLON
    (25) procedure_or_function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> . identifier LPAREN RPAREN SEMICOLON
    (66) array -> . identifier LBRACKET_S integer RBRACKET_S SEMICOLON
    (61) identifier -> . IDENTIFIER

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    RBRACKET        reduce using rule 23 (statement -> .)
    LBRACKET        shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 22
    IDENTIFIER      shift and go to state 7

  ! LBRACKET        [ reduce using rule 23 (statement -> .) ]
  ! IF              [ reduce using rule 23 (statement -> .) ]
  ! WHILE           [ reduce using rule 23 (statement -> .) ]
  ! RETURN          [ reduce using rule 23 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 23 (statement -> .) ]

    statement_sequence             shift and go to state 24
    statement                      shift and go to state 25
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    procedure_or_function_call     shift and go to state 16
    array                          shift and go to state 17
    identifier                     shift and go to state 19

state 19

    (30) assignment_statement -> identifier . COLON type ASSIGNMENT element SEMICOLON
    (25) procedure_or_function_call -> identifier . LPAREN param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> identifier . LPAREN RPAREN SEMICOLON
    (66) array -> identifier . LBRACKET_S integer RBRACKET_S SEMICOLON

    COLON           shift and go to state 26
    LPAREN          shift and go to state 27
    LBRACKET_S      shift and go to state 28


state 20

    (31) if_statement -> IF . expression body ELSE body
    (32) if_statement -> IF . expression body
    (35) expression -> . expression_m
    (36) expression -> . expression and_or expression_m
    (37) expression_m -> . expression_s
    (38) expression_m -> . expression_m sign expression_s
    (39) expression_s -> . element
    (40) expression_s -> . expression_s psign element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    expression                     shift and go to state 29
    expression_m                   shift and go to state 30
    expression_s                   shift and go to state 31
    element                        shift and go to state 32
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 21

    (33) while_statement -> WHILE . expression body
    (35) expression -> . expression_m
    (36) expression -> . expression and_or expression_m
    (37) expression_m -> . expression_s
    (38) expression_m -> . expression_m sign expression_s
    (39) expression_s -> . element
    (40) expression_s -> . expression_s psign element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    expression                     shift and go to state 44
    expression_m                   shift and go to state 30
    expression_s                   shift and go to state 31
    element                        shift and go to state 32
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 22

    (34) return_statement -> RETURN . element SEMICOLON
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    element                        shift and go to state 45
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 23

    (8) function_declaration -> identifier COLON . type LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON . type SEMICOLON
    (6) variable_declaration -> identifier COLON . type ASSIGNMENT element SEMICOLON
    (9) function_heading -> identifier COLON . type LPAREN parameter_list RPAREN
    (67) type -> . TINTEGER
    (68) type -> . TFLOAT
    (69) type -> . TSTRING
    (70) type -> . TBOOL
    (71) type -> . TARRAY

    TINTEGER        shift and go to state 47
    TFLOAT          shift and go to state 48
    TSTRING         shift and go to state 49
    TBOOL           shift and go to state 50
    TARRAY          shift and go to state 51

    type                           shift and go to state 46

state 24

    (13) statement_part -> LBRACKET statement_sequence . RBRACKET

    RBRACKET        shift and go to state 52


state 25

    (14) statement_sequence -> statement . statement_sequence
    (15) statement_sequence -> statement .
    (14) statement_sequence -> . statement statement_sequence
    (15) statement_sequence -> . statement
    (16) statement -> . statement_part
    (17) statement -> . assignment_statement
    (18) statement -> . if_statement
    (19) statement -> . while_statement
    (20) statement -> . return_statement
    (21) statement -> . procedure_or_function_call
    (22) statement -> . array
    (23) statement -> .
    (13) statement_part -> . LBRACKET statement_sequence RBRACKET
    (30) assignment_statement -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (31) if_statement -> . IF expression body ELSE body
    (32) if_statement -> . IF expression body
    (33) while_statement -> . WHILE expression body
    (34) return_statement -> . RETURN element SEMICOLON
    (25) procedure_or_function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> . identifier LPAREN RPAREN SEMICOLON
    (66) array -> . identifier LBRACKET_S integer RBRACKET_S SEMICOLON
    (61) identifier -> . IDENTIFIER

  ! reduce/reduce conflict for RBRACKET resolved using rule 15 (statement_sequence -> statement .)
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    RBRACKET        reduce using rule 15 (statement_sequence -> statement .)
    LBRACKET        shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 22
    IDENTIFIER      shift and go to state 7

  ! LBRACKET        [ reduce using rule 23 (statement -> .) ]
  ! IF              [ reduce using rule 23 (statement -> .) ]
  ! WHILE           [ reduce using rule 23 (statement -> .) ]
  ! RETURN          [ reduce using rule 23 (statement -> .) ]
  ! IDENTIFIER      [ reduce using rule 23 (statement -> .) ]
  ! RBRACKET        [ reduce using rule 23 (statement -> .) ]

    statement                      shift and go to state 25
    statement_sequence             shift and go to state 53
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    procedure_or_function_call     shift and go to state 16
    array                          shift and go to state 17
    identifier                     shift and go to state 19

state 26

    (30) assignment_statement -> identifier COLON . type ASSIGNMENT element SEMICOLON
    (67) type -> . TINTEGER
    (68) type -> . TFLOAT
    (69) type -> . TSTRING
    (70) type -> . TBOOL
    (71) type -> . TARRAY

    TINTEGER        shift and go to state 47
    TFLOAT          shift and go to state 48
    TSTRING         shift and go to state 49
    TBOOL           shift and go to state 50
    TARRAY          shift and go to state 51

    type                           shift and go to state 54

state 27

    (25) procedure_or_function_call -> identifier LPAREN . param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> identifier LPAREN . RPAREN SEMICOLON
    (27) param_list -> . param_list COMMA param
    (28) param_list -> . param
    (29) param -> . expression
    (35) expression -> . expression_m
    (36) expression -> . expression and_or expression_m
    (37) expression_m -> . expression_s
    (38) expression_m -> . expression_m sign expression_s
    (39) expression_s -> . element
    (40) expression_s -> . expression_s psign element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    RPAREN          shift and go to state 56
    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    identifier                     shift and go to state 33
    param_list                     shift and go to state 55
    param                          shift and go to state 57
    expression                     shift and go to state 58
    expression_m                   shift and go to state 30
    expression_s                   shift and go to state 31
    element                        shift and go to state 32
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 28

    (66) array -> identifier LBRACKET_S . integer RBRACKET_S SEMICOLON
    (62) integer -> . INTEGER

    INTEGER         shift and go to state 40

    integer                        shift and go to state 59

state 29

    (31) if_statement -> IF expression . body ELSE body
    (32) if_statement -> IF expression . body
    (36) expression -> expression . and_or expression_m
    (24) body -> . statement
    (41) and_or -> . AND
    (42) and_or -> . OR
    (16) statement -> . statement_part
    (17) statement -> . assignment_statement
    (18) statement -> . if_statement
    (19) statement -> . while_statement
    (20) statement -> . return_statement
    (21) statement -> . procedure_or_function_call
    (22) statement -> . array
    (23) statement -> .
    (13) statement_part -> . LBRACKET statement_sequence RBRACKET
    (30) assignment_statement -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (31) if_statement -> . IF expression body ELSE body
    (32) if_statement -> . IF expression body
    (33) while_statement -> . WHILE expression body
    (34) return_statement -> . RETURN element SEMICOLON
    (25) procedure_or_function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> . identifier LPAREN RPAREN SEMICOLON
    (66) array -> . identifier LBRACKET_S integer RBRACKET_S SEMICOLON
    (61) identifier -> . IDENTIFIER

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    AND             shift and go to state 62
    OR              shift and go to state 63
    ELSE            reduce using rule 23 (statement -> .)
    $end            reduce using rule 23 (statement -> .)
    RBRACKET        reduce using rule 23 (statement -> .)
    LBRACKET        shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 22
    IDENTIFIER      shift and go to state 7

  ! IDENTIFIER      [ reduce using rule 23 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 23 (statement -> .) ]
  ! IF              [ reduce using rule 23 (statement -> .) ]
  ! WHILE           [ reduce using rule 23 (statement -> .) ]
  ! RETURN          [ reduce using rule 23 (statement -> .) ]

    body                           shift and go to state 60
    and_or                         shift and go to state 61
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    procedure_or_function_call     shift and go to state 16
    array                          shift and go to state 17
    identifier                     shift and go to state 19

state 30

    (35) expression -> expression_m .
    (38) expression_m -> expression_m . sign expression_s
    (45) sign -> . PLUS
    (46) sign -> . MINUS
    (47) sign -> . MOD
    (48) sign -> . EQUAL
    (49) sign -> . NEQUAL
    (50) sign -> . LT
    (51) sign -> . LTE
    (52) sign -> . GT
    (53) sign -> . GTE

    AND             reduce using rule 35 (expression -> expression_m .)
    OR              reduce using rule 35 (expression -> expression_m .)
    LBRACKET        reduce using rule 35 (expression -> expression_m .)
    IF              reduce using rule 35 (expression -> expression_m .)
    WHILE           reduce using rule 35 (expression -> expression_m .)
    RETURN          reduce using rule 35 (expression -> expression_m .)
    IDENTIFIER      reduce using rule 35 (expression -> expression_m .)
    ELSE            reduce using rule 35 (expression -> expression_m .)
    $end            reduce using rule 35 (expression -> expression_m .)
    RBRACKET        reduce using rule 35 (expression -> expression_m .)
    RPAREN          reduce using rule 35 (expression -> expression_m .)
    COMMA           reduce using rule 35 (expression -> expression_m .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    MOD             shift and go to state 67
    EQUAL           shift and go to state 68
    NEQUAL          shift and go to state 69
    LT              shift and go to state 70
    LTE             shift and go to state 71
    GT              shift and go to state 72
    GTE             shift and go to state 73

    sign                           shift and go to state 64

state 31

    (37) expression_m -> expression_s .
    (40) expression_s -> expression_s . psign element
    (43) psign -> . TIMES
    (44) psign -> . DIV

    PLUS            reduce using rule 37 (expression_m -> expression_s .)
    MINUS           reduce using rule 37 (expression_m -> expression_s .)
    MOD             reduce using rule 37 (expression_m -> expression_s .)
    EQUAL           reduce using rule 37 (expression_m -> expression_s .)
    NEQUAL          reduce using rule 37 (expression_m -> expression_s .)
    LT              reduce using rule 37 (expression_m -> expression_s .)
    LTE             reduce using rule 37 (expression_m -> expression_s .)
    GT              reduce using rule 37 (expression_m -> expression_s .)
    GTE             reduce using rule 37 (expression_m -> expression_s .)
    AND             reduce using rule 37 (expression_m -> expression_s .)
    OR              reduce using rule 37 (expression_m -> expression_s .)
    LBRACKET        reduce using rule 37 (expression_m -> expression_s .)
    IF              reduce using rule 37 (expression_m -> expression_s .)
    WHILE           reduce using rule 37 (expression_m -> expression_s .)
    RETURN          reduce using rule 37 (expression_m -> expression_s .)
    IDENTIFIER      reduce using rule 37 (expression_m -> expression_s .)
    ELSE            reduce using rule 37 (expression_m -> expression_s .)
    $end            reduce using rule 37 (expression_m -> expression_s .)
    RBRACKET        reduce using rule 37 (expression_m -> expression_s .)
    RPAREN          reduce using rule 37 (expression_m -> expression_s .)
    COMMA           reduce using rule 37 (expression_m -> expression_s .)
    TIMES           shift and go to state 75
    DIV             shift and go to state 76

    psign                          shift and go to state 74

state 32

    (39) expression_s -> element .

    TIMES           reduce using rule 39 (expression_s -> element .)
    DIV             reduce using rule 39 (expression_s -> element .)
    PLUS            reduce using rule 39 (expression_s -> element .)
    MINUS           reduce using rule 39 (expression_s -> element .)
    MOD             reduce using rule 39 (expression_s -> element .)
    EQUAL           reduce using rule 39 (expression_s -> element .)
    NEQUAL          reduce using rule 39 (expression_s -> element .)
    LT              reduce using rule 39 (expression_s -> element .)
    LTE             reduce using rule 39 (expression_s -> element .)
    GT              reduce using rule 39 (expression_s -> element .)
    GTE             reduce using rule 39 (expression_s -> element .)
    AND             reduce using rule 39 (expression_s -> element .)
    OR              reduce using rule 39 (expression_s -> element .)
    LBRACKET        reduce using rule 39 (expression_s -> element .)
    IF              reduce using rule 39 (expression_s -> element .)
    WHILE           reduce using rule 39 (expression_s -> element .)
    RETURN          reduce using rule 39 (expression_s -> element .)
    IDENTIFIER      reduce using rule 39 (expression_s -> element .)
    ELSE            reduce using rule 39 (expression_s -> element .)
    $end            reduce using rule 39 (expression_s -> element .)
    RBRACKET        reduce using rule 39 (expression_s -> element .)
    RPAREN          reduce using rule 39 (expression_s -> element .)
    COMMA           reduce using rule 39 (expression_s -> element .)


state 33

    (54) element -> identifier .

    TIMES           reduce using rule 54 (element -> identifier .)
    DIV             reduce using rule 54 (element -> identifier .)
    PLUS            reduce using rule 54 (element -> identifier .)
    MINUS           reduce using rule 54 (element -> identifier .)
    MOD             reduce using rule 54 (element -> identifier .)
    EQUAL           reduce using rule 54 (element -> identifier .)
    NEQUAL          reduce using rule 54 (element -> identifier .)
    LT              reduce using rule 54 (element -> identifier .)
    LTE             reduce using rule 54 (element -> identifier .)
    GT              reduce using rule 54 (element -> identifier .)
    GTE             reduce using rule 54 (element -> identifier .)
    AND             reduce using rule 54 (element -> identifier .)
    OR              reduce using rule 54 (element -> identifier .)
    LBRACKET        reduce using rule 54 (element -> identifier .)
    IF              reduce using rule 54 (element -> identifier .)
    WHILE           reduce using rule 54 (element -> identifier .)
    RETURN          reduce using rule 54 (element -> identifier .)
    IDENTIFIER      reduce using rule 54 (element -> identifier .)
    ELSE            reduce using rule 54 (element -> identifier .)
    $end            reduce using rule 54 (element -> identifier .)
    RBRACKET        reduce using rule 54 (element -> identifier .)
    SEMICOLON       reduce using rule 54 (element -> identifier .)
    RPAREN          reduce using rule 54 (element -> identifier .)
    COMMA           reduce using rule 54 (element -> identifier .)


state 34

    (55) element -> integer .

    TIMES           reduce using rule 55 (element -> integer .)
    DIV             reduce using rule 55 (element -> integer .)
    PLUS            reduce using rule 55 (element -> integer .)
    MINUS           reduce using rule 55 (element -> integer .)
    MOD             reduce using rule 55 (element -> integer .)
    EQUAL           reduce using rule 55 (element -> integer .)
    NEQUAL          reduce using rule 55 (element -> integer .)
    LT              reduce using rule 55 (element -> integer .)
    LTE             reduce using rule 55 (element -> integer .)
    GT              reduce using rule 55 (element -> integer .)
    GTE             reduce using rule 55 (element -> integer .)
    AND             reduce using rule 55 (element -> integer .)
    OR              reduce using rule 55 (element -> integer .)
    LBRACKET        reduce using rule 55 (element -> integer .)
    IF              reduce using rule 55 (element -> integer .)
    WHILE           reduce using rule 55 (element -> integer .)
    RETURN          reduce using rule 55 (element -> integer .)
    IDENTIFIER      reduce using rule 55 (element -> integer .)
    ELSE            reduce using rule 55 (element -> integer .)
    $end            reduce using rule 55 (element -> integer .)
    RBRACKET        reduce using rule 55 (element -> integer .)
    SEMICOLON       reduce using rule 55 (element -> integer .)
    RPAREN          reduce using rule 55 (element -> integer .)
    COMMA           reduce using rule 55 (element -> integer .)


state 35

    (56) element -> float .

    TIMES           reduce using rule 56 (element -> float .)
    DIV             reduce using rule 56 (element -> float .)
    PLUS            reduce using rule 56 (element -> float .)
    MINUS           reduce using rule 56 (element -> float .)
    MOD             reduce using rule 56 (element -> float .)
    EQUAL           reduce using rule 56 (element -> float .)
    NEQUAL          reduce using rule 56 (element -> float .)
    LT              reduce using rule 56 (element -> float .)
    LTE             reduce using rule 56 (element -> float .)
    GT              reduce using rule 56 (element -> float .)
    GTE             reduce using rule 56 (element -> float .)
    AND             reduce using rule 56 (element -> float .)
    OR              reduce using rule 56 (element -> float .)
    LBRACKET        reduce using rule 56 (element -> float .)
    IF              reduce using rule 56 (element -> float .)
    WHILE           reduce using rule 56 (element -> float .)
    RETURN          reduce using rule 56 (element -> float .)
    IDENTIFIER      reduce using rule 56 (element -> float .)
    ELSE            reduce using rule 56 (element -> float .)
    $end            reduce using rule 56 (element -> float .)
    RBRACKET        reduce using rule 56 (element -> float .)
    SEMICOLON       reduce using rule 56 (element -> float .)
    RPAREN          reduce using rule 56 (element -> float .)
    COMMA           reduce using rule 56 (element -> float .)


state 36

    (57) element -> string .

    TIMES           reduce using rule 57 (element -> string .)
    DIV             reduce using rule 57 (element -> string .)
    PLUS            reduce using rule 57 (element -> string .)
    MINUS           reduce using rule 57 (element -> string .)
    MOD             reduce using rule 57 (element -> string .)
    EQUAL           reduce using rule 57 (element -> string .)
    NEQUAL          reduce using rule 57 (element -> string .)
    LT              reduce using rule 57 (element -> string .)
    LTE             reduce using rule 57 (element -> string .)
    GT              reduce using rule 57 (element -> string .)
    GTE             reduce using rule 57 (element -> string .)
    AND             reduce using rule 57 (element -> string .)
    OR              reduce using rule 57 (element -> string .)
    LBRACKET        reduce using rule 57 (element -> string .)
    IF              reduce using rule 57 (element -> string .)
    WHILE           reduce using rule 57 (element -> string .)
    RETURN          reduce using rule 57 (element -> string .)
    IDENTIFIER      reduce using rule 57 (element -> string .)
    ELSE            reduce using rule 57 (element -> string .)
    $end            reduce using rule 57 (element -> string .)
    RBRACKET        reduce using rule 57 (element -> string .)
    SEMICOLON       reduce using rule 57 (element -> string .)
    RPAREN          reduce using rule 57 (element -> string .)
    COMMA           reduce using rule 57 (element -> string .)


state 37

    (58) element -> bool .

    TIMES           reduce using rule 58 (element -> bool .)
    DIV             reduce using rule 58 (element -> bool .)
    PLUS            reduce using rule 58 (element -> bool .)
    MINUS           reduce using rule 58 (element -> bool .)
    MOD             reduce using rule 58 (element -> bool .)
    EQUAL           reduce using rule 58 (element -> bool .)
    NEQUAL          reduce using rule 58 (element -> bool .)
    LT              reduce using rule 58 (element -> bool .)
    LTE             reduce using rule 58 (element -> bool .)
    GT              reduce using rule 58 (element -> bool .)
    GTE             reduce using rule 58 (element -> bool .)
    AND             reduce using rule 58 (element -> bool .)
    OR              reduce using rule 58 (element -> bool .)
    LBRACKET        reduce using rule 58 (element -> bool .)
    IF              reduce using rule 58 (element -> bool .)
    WHILE           reduce using rule 58 (element -> bool .)
    RETURN          reduce using rule 58 (element -> bool .)
    IDENTIFIER      reduce using rule 58 (element -> bool .)
    ELSE            reduce using rule 58 (element -> bool .)
    $end            reduce using rule 58 (element -> bool .)
    RBRACKET        reduce using rule 58 (element -> bool .)
    SEMICOLON       reduce using rule 58 (element -> bool .)
    RPAREN          reduce using rule 58 (element -> bool .)
    COMMA           reduce using rule 58 (element -> bool .)


state 38

    (59) element -> LPAREN . expression RPAREN
    (35) expression -> . expression_m
    (36) expression -> . expression and_or expression_m
    (37) expression_m -> . expression_s
    (38) expression_m -> . expression_m sign expression_s
    (39) expression_s -> . element
    (40) expression_s -> . expression_s psign element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    expression                     shift and go to state 77
    expression_m                   shift and go to state 30
    expression_s                   shift and go to state 31
    element                        shift and go to state 32
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 39

    (60) element -> NOT . element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    element                        shift and go to state 78
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 40

    (62) integer -> INTEGER .

    TIMES           reduce using rule 62 (integer -> INTEGER .)
    DIV             reduce using rule 62 (integer -> INTEGER .)
    PLUS            reduce using rule 62 (integer -> INTEGER .)
    MINUS           reduce using rule 62 (integer -> INTEGER .)
    MOD             reduce using rule 62 (integer -> INTEGER .)
    EQUAL           reduce using rule 62 (integer -> INTEGER .)
    NEQUAL          reduce using rule 62 (integer -> INTEGER .)
    LT              reduce using rule 62 (integer -> INTEGER .)
    LTE             reduce using rule 62 (integer -> INTEGER .)
    GT              reduce using rule 62 (integer -> INTEGER .)
    GTE             reduce using rule 62 (integer -> INTEGER .)
    AND             reduce using rule 62 (integer -> INTEGER .)
    OR              reduce using rule 62 (integer -> INTEGER .)
    LBRACKET        reduce using rule 62 (integer -> INTEGER .)
    IF              reduce using rule 62 (integer -> INTEGER .)
    WHILE           reduce using rule 62 (integer -> INTEGER .)
    RETURN          reduce using rule 62 (integer -> INTEGER .)
    IDENTIFIER      reduce using rule 62 (integer -> INTEGER .)
    ELSE            reduce using rule 62 (integer -> INTEGER .)
    $end            reduce using rule 62 (integer -> INTEGER .)
    RBRACKET        reduce using rule 62 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 62 (integer -> INTEGER .)
    RPAREN          reduce using rule 62 (integer -> INTEGER .)
    COMMA           reduce using rule 62 (integer -> INTEGER .)
    RBRACKET_S      reduce using rule 62 (integer -> INTEGER .)


state 41

    (63) float -> FLOAT .

    TIMES           reduce using rule 63 (float -> FLOAT .)
    DIV             reduce using rule 63 (float -> FLOAT .)
    PLUS            reduce using rule 63 (float -> FLOAT .)
    MINUS           reduce using rule 63 (float -> FLOAT .)
    MOD             reduce using rule 63 (float -> FLOAT .)
    EQUAL           reduce using rule 63 (float -> FLOAT .)
    NEQUAL          reduce using rule 63 (float -> FLOAT .)
    LT              reduce using rule 63 (float -> FLOAT .)
    LTE             reduce using rule 63 (float -> FLOAT .)
    GT              reduce using rule 63 (float -> FLOAT .)
    GTE             reduce using rule 63 (float -> FLOAT .)
    AND             reduce using rule 63 (float -> FLOAT .)
    OR              reduce using rule 63 (float -> FLOAT .)
    LBRACKET        reduce using rule 63 (float -> FLOAT .)
    IF              reduce using rule 63 (float -> FLOAT .)
    WHILE           reduce using rule 63 (float -> FLOAT .)
    RETURN          reduce using rule 63 (float -> FLOAT .)
    IDENTIFIER      reduce using rule 63 (float -> FLOAT .)
    ELSE            reduce using rule 63 (float -> FLOAT .)
    $end            reduce using rule 63 (float -> FLOAT .)
    RBRACKET        reduce using rule 63 (float -> FLOAT .)
    SEMICOLON       reduce using rule 63 (float -> FLOAT .)
    RPAREN          reduce using rule 63 (float -> FLOAT .)
    COMMA           reduce using rule 63 (float -> FLOAT .)


state 42

    (64) string -> STRING .

    TIMES           reduce using rule 64 (string -> STRING .)
    DIV             reduce using rule 64 (string -> STRING .)
    PLUS            reduce using rule 64 (string -> STRING .)
    MINUS           reduce using rule 64 (string -> STRING .)
    MOD             reduce using rule 64 (string -> STRING .)
    EQUAL           reduce using rule 64 (string -> STRING .)
    NEQUAL          reduce using rule 64 (string -> STRING .)
    LT              reduce using rule 64 (string -> STRING .)
    LTE             reduce using rule 64 (string -> STRING .)
    GT              reduce using rule 64 (string -> STRING .)
    GTE             reduce using rule 64 (string -> STRING .)
    AND             reduce using rule 64 (string -> STRING .)
    OR              reduce using rule 64 (string -> STRING .)
    LBRACKET        reduce using rule 64 (string -> STRING .)
    IF              reduce using rule 64 (string -> STRING .)
    WHILE           reduce using rule 64 (string -> STRING .)
    RETURN          reduce using rule 64 (string -> STRING .)
    IDENTIFIER      reduce using rule 64 (string -> STRING .)
    ELSE            reduce using rule 64 (string -> STRING .)
    $end            reduce using rule 64 (string -> STRING .)
    RBRACKET        reduce using rule 64 (string -> STRING .)
    SEMICOLON       reduce using rule 64 (string -> STRING .)
    RPAREN          reduce using rule 64 (string -> STRING .)
    COMMA           reduce using rule 64 (string -> STRING .)


state 43

    (65) bool -> BOOL .

    TIMES           reduce using rule 65 (bool -> BOOL .)
    DIV             reduce using rule 65 (bool -> BOOL .)
    PLUS            reduce using rule 65 (bool -> BOOL .)
    MINUS           reduce using rule 65 (bool -> BOOL .)
    MOD             reduce using rule 65 (bool -> BOOL .)
    EQUAL           reduce using rule 65 (bool -> BOOL .)
    NEQUAL          reduce using rule 65 (bool -> BOOL .)
    LT              reduce using rule 65 (bool -> BOOL .)
    LTE             reduce using rule 65 (bool -> BOOL .)
    GT              reduce using rule 65 (bool -> BOOL .)
    GTE             reduce using rule 65 (bool -> BOOL .)
    AND             reduce using rule 65 (bool -> BOOL .)
    OR              reduce using rule 65 (bool -> BOOL .)
    LBRACKET        reduce using rule 65 (bool -> BOOL .)
    IF              reduce using rule 65 (bool -> BOOL .)
    WHILE           reduce using rule 65 (bool -> BOOL .)
    RETURN          reduce using rule 65 (bool -> BOOL .)
    IDENTIFIER      reduce using rule 65 (bool -> BOOL .)
    ELSE            reduce using rule 65 (bool -> BOOL .)
    $end            reduce using rule 65 (bool -> BOOL .)
    RBRACKET        reduce using rule 65 (bool -> BOOL .)
    SEMICOLON       reduce using rule 65 (bool -> BOOL .)
    RPAREN          reduce using rule 65 (bool -> BOOL .)
    COMMA           reduce using rule 65 (bool -> BOOL .)


state 44

    (33) while_statement -> WHILE expression . body
    (36) expression -> expression . and_or expression_m
    (24) body -> . statement
    (41) and_or -> . AND
    (42) and_or -> . OR
    (16) statement -> . statement_part
    (17) statement -> . assignment_statement
    (18) statement -> . if_statement
    (19) statement -> . while_statement
    (20) statement -> . return_statement
    (21) statement -> . procedure_or_function_call
    (22) statement -> . array
    (23) statement -> .
    (13) statement_part -> . LBRACKET statement_sequence RBRACKET
    (30) assignment_statement -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (31) if_statement -> . IF expression body ELSE body
    (32) if_statement -> . IF expression body
    (33) while_statement -> . WHILE expression body
    (34) return_statement -> . RETURN element SEMICOLON
    (25) procedure_or_function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> . identifier LPAREN RPAREN SEMICOLON
    (66) array -> . identifier LBRACKET_S integer RBRACKET_S SEMICOLON
    (61) identifier -> . IDENTIFIER

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    AND             shift and go to state 62
    OR              shift and go to state 63
    ELSE            reduce using rule 23 (statement -> .)
    $end            reduce using rule 23 (statement -> .)
    RBRACKET        reduce using rule 23 (statement -> .)
    LBRACKET        shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 22
    IDENTIFIER      shift and go to state 7

  ! IDENTIFIER      [ reduce using rule 23 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 23 (statement -> .) ]
  ! IF              [ reduce using rule 23 (statement -> .) ]
  ! WHILE           [ reduce using rule 23 (statement -> .) ]
  ! RETURN          [ reduce using rule 23 (statement -> .) ]

    body                           shift and go to state 79
    and_or                         shift and go to state 61
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    procedure_or_function_call     shift and go to state 16
    array                          shift and go to state 17
    identifier                     shift and go to state 19

state 45

    (34) return_statement -> RETURN element . SEMICOLON

    SEMICOLON       shift and go to state 80


state 46

    (8) function_declaration -> identifier COLON type . LPAREN parameter_list RPAREN SEMICOLON
    (5) variable_declaration -> identifier COLON type . SEMICOLON
    (6) variable_declaration -> identifier COLON type . ASSIGNMENT element SEMICOLON
    (9) function_heading -> identifier COLON type . LPAREN parameter_list RPAREN

    LPAREN          shift and go to state 81
    SEMICOLON       shift and go to state 82
    ASSIGNMENT      shift and go to state 83


state 47

    (67) type -> TINTEGER .

    LPAREN          reduce using rule 67 (type -> TINTEGER .)
    SEMICOLON       reduce using rule 67 (type -> TINTEGER .)
    ASSIGNMENT      reduce using rule 67 (type -> TINTEGER .)
    COMMA           reduce using rule 67 (type -> TINTEGER .)
    RPAREN          reduce using rule 67 (type -> TINTEGER .)


state 48

    (68) type -> TFLOAT .

    LPAREN          reduce using rule 68 (type -> TFLOAT .)
    SEMICOLON       reduce using rule 68 (type -> TFLOAT .)
    ASSIGNMENT      reduce using rule 68 (type -> TFLOAT .)
    COMMA           reduce using rule 68 (type -> TFLOAT .)
    RPAREN          reduce using rule 68 (type -> TFLOAT .)


state 49

    (69) type -> TSTRING .

    LPAREN          reduce using rule 69 (type -> TSTRING .)
    SEMICOLON       reduce using rule 69 (type -> TSTRING .)
    ASSIGNMENT      reduce using rule 69 (type -> TSTRING .)
    COMMA           reduce using rule 69 (type -> TSTRING .)
    RPAREN          reduce using rule 69 (type -> TSTRING .)


state 50

    (70) type -> TBOOL .

    LPAREN          reduce using rule 70 (type -> TBOOL .)
    SEMICOLON       reduce using rule 70 (type -> TBOOL .)
    ASSIGNMENT      reduce using rule 70 (type -> TBOOL .)
    COMMA           reduce using rule 70 (type -> TBOOL .)
    RPAREN          reduce using rule 70 (type -> TBOOL .)


state 51

    (71) type -> TARRAY .

    LPAREN          reduce using rule 71 (type -> TARRAY .)
    SEMICOLON       reduce using rule 71 (type -> TARRAY .)
    ASSIGNMENT      reduce using rule 71 (type -> TARRAY .)
    COMMA           reduce using rule 71 (type -> TARRAY .)
    RPAREN          reduce using rule 71 (type -> TARRAY .)


state 52

    (13) statement_part -> LBRACKET statement_sequence RBRACKET .

    IDENTIFIER      reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    $end            reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    LBRACKET        reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    IF              reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    WHILE           reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RETURN          reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    RBRACKET        reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)
    ELSE            reduce using rule 13 (statement_part -> LBRACKET statement_sequence RBRACKET .)


state 53

    (14) statement_sequence -> statement statement_sequence .

    RBRACKET        reduce using rule 14 (statement_sequence -> statement statement_sequence .)


state 54

    (30) assignment_statement -> identifier COLON type . ASSIGNMENT element SEMICOLON

    ASSIGNMENT      shift and go to state 84


state 55

    (25) procedure_or_function_call -> identifier LPAREN param_list . RPAREN SEMICOLON
    (27) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 85
    COMMA           shift and go to state 86


state 56

    (26) procedure_or_function_call -> identifier LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 87


state 57

    (28) param_list -> param .

    RPAREN          reduce using rule 28 (param_list -> param .)
    COMMA           reduce using rule 28 (param_list -> param .)


state 58

    (29) param -> expression .
    (36) expression -> expression . and_or expression_m
    (41) and_or -> . AND
    (42) and_or -> . OR

    RPAREN          reduce using rule 29 (param -> expression .)
    COMMA           reduce using rule 29 (param -> expression .)
    AND             shift and go to state 62
    OR              shift and go to state 63

    and_or                         shift and go to state 61

state 59

    (66) array -> identifier LBRACKET_S integer . RBRACKET_S SEMICOLON

    RBRACKET_S      shift and go to state 88


state 60

    (31) if_statement -> IF expression body . ELSE body
    (32) if_statement -> IF expression body .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 89
    IDENTIFIER      reduce using rule 32 (if_statement -> IF expression body .)
    $end            reduce using rule 32 (if_statement -> IF expression body .)
    LBRACKET        reduce using rule 32 (if_statement -> IF expression body .)
    IF              reduce using rule 32 (if_statement -> IF expression body .)
    WHILE           reduce using rule 32 (if_statement -> IF expression body .)
    RETURN          reduce using rule 32 (if_statement -> IF expression body .)
    RBRACKET        reduce using rule 32 (if_statement -> IF expression body .)

  ! ELSE            [ reduce using rule 32 (if_statement -> IF expression body .) ]


state 61

    (36) expression -> expression and_or . expression_m
    (37) expression_m -> . expression_s
    (38) expression_m -> . expression_m sign expression_s
    (39) expression_s -> . element
    (40) expression_s -> . expression_s psign element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    expression_m                   shift and go to state 90
    expression_s                   shift and go to state 31
    element                        shift and go to state 32
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 62

    (41) and_or -> AND .

    LPAREN          reduce using rule 41 (and_or -> AND .)
    NOT             reduce using rule 41 (and_or -> AND .)
    IDENTIFIER      reduce using rule 41 (and_or -> AND .)
    INTEGER         reduce using rule 41 (and_or -> AND .)
    FLOAT           reduce using rule 41 (and_or -> AND .)
    STRING          reduce using rule 41 (and_or -> AND .)
    BOOL            reduce using rule 41 (and_or -> AND .)


state 63

    (42) and_or -> OR .

    LPAREN          reduce using rule 42 (and_or -> OR .)
    NOT             reduce using rule 42 (and_or -> OR .)
    IDENTIFIER      reduce using rule 42 (and_or -> OR .)
    INTEGER         reduce using rule 42 (and_or -> OR .)
    FLOAT           reduce using rule 42 (and_or -> OR .)
    STRING          reduce using rule 42 (and_or -> OR .)
    BOOL            reduce using rule 42 (and_or -> OR .)


state 64

    (38) expression_m -> expression_m sign . expression_s
    (39) expression_s -> . element
    (40) expression_s -> . expression_s psign element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    expression_s                   shift and go to state 91
    element                        shift and go to state 32
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 65

    (45) sign -> PLUS .

    LPAREN          reduce using rule 45 (sign -> PLUS .)
    NOT             reduce using rule 45 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 45 (sign -> PLUS .)
    INTEGER         reduce using rule 45 (sign -> PLUS .)
    FLOAT           reduce using rule 45 (sign -> PLUS .)
    STRING          reduce using rule 45 (sign -> PLUS .)
    BOOL            reduce using rule 45 (sign -> PLUS .)


state 66

    (46) sign -> MINUS .

    LPAREN          reduce using rule 46 (sign -> MINUS .)
    NOT             reduce using rule 46 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 46 (sign -> MINUS .)
    INTEGER         reduce using rule 46 (sign -> MINUS .)
    FLOAT           reduce using rule 46 (sign -> MINUS .)
    STRING          reduce using rule 46 (sign -> MINUS .)
    BOOL            reduce using rule 46 (sign -> MINUS .)


state 67

    (47) sign -> MOD .

    LPAREN          reduce using rule 47 (sign -> MOD .)
    NOT             reduce using rule 47 (sign -> MOD .)
    IDENTIFIER      reduce using rule 47 (sign -> MOD .)
    INTEGER         reduce using rule 47 (sign -> MOD .)
    FLOAT           reduce using rule 47 (sign -> MOD .)
    STRING          reduce using rule 47 (sign -> MOD .)
    BOOL            reduce using rule 47 (sign -> MOD .)


state 68

    (48) sign -> EQUAL .

    LPAREN          reduce using rule 48 (sign -> EQUAL .)
    NOT             reduce using rule 48 (sign -> EQUAL .)
    IDENTIFIER      reduce using rule 48 (sign -> EQUAL .)
    INTEGER         reduce using rule 48 (sign -> EQUAL .)
    FLOAT           reduce using rule 48 (sign -> EQUAL .)
    STRING          reduce using rule 48 (sign -> EQUAL .)
    BOOL            reduce using rule 48 (sign -> EQUAL .)


state 69

    (49) sign -> NEQUAL .

    LPAREN          reduce using rule 49 (sign -> NEQUAL .)
    NOT             reduce using rule 49 (sign -> NEQUAL .)
    IDENTIFIER      reduce using rule 49 (sign -> NEQUAL .)
    INTEGER         reduce using rule 49 (sign -> NEQUAL .)
    FLOAT           reduce using rule 49 (sign -> NEQUAL .)
    STRING          reduce using rule 49 (sign -> NEQUAL .)
    BOOL            reduce using rule 49 (sign -> NEQUAL .)


state 70

    (50) sign -> LT .

    LPAREN          reduce using rule 50 (sign -> LT .)
    NOT             reduce using rule 50 (sign -> LT .)
    IDENTIFIER      reduce using rule 50 (sign -> LT .)
    INTEGER         reduce using rule 50 (sign -> LT .)
    FLOAT           reduce using rule 50 (sign -> LT .)
    STRING          reduce using rule 50 (sign -> LT .)
    BOOL            reduce using rule 50 (sign -> LT .)


state 71

    (51) sign -> LTE .

    LPAREN          reduce using rule 51 (sign -> LTE .)
    NOT             reduce using rule 51 (sign -> LTE .)
    IDENTIFIER      reduce using rule 51 (sign -> LTE .)
    INTEGER         reduce using rule 51 (sign -> LTE .)
    FLOAT           reduce using rule 51 (sign -> LTE .)
    STRING          reduce using rule 51 (sign -> LTE .)
    BOOL            reduce using rule 51 (sign -> LTE .)


state 72

    (52) sign -> GT .

    LPAREN          reduce using rule 52 (sign -> GT .)
    NOT             reduce using rule 52 (sign -> GT .)
    IDENTIFIER      reduce using rule 52 (sign -> GT .)
    INTEGER         reduce using rule 52 (sign -> GT .)
    FLOAT           reduce using rule 52 (sign -> GT .)
    STRING          reduce using rule 52 (sign -> GT .)
    BOOL            reduce using rule 52 (sign -> GT .)


state 73

    (53) sign -> GTE .

    LPAREN          reduce using rule 53 (sign -> GTE .)
    NOT             reduce using rule 53 (sign -> GTE .)
    IDENTIFIER      reduce using rule 53 (sign -> GTE .)
    INTEGER         reduce using rule 53 (sign -> GTE .)
    FLOAT           reduce using rule 53 (sign -> GTE .)
    STRING          reduce using rule 53 (sign -> GTE .)
    BOOL            reduce using rule 53 (sign -> GTE .)


state 74

    (40) expression_s -> expression_s psign . element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    element                        shift and go to state 92
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 75

    (43) psign -> TIMES .

    LPAREN          reduce using rule 43 (psign -> TIMES .)
    NOT             reduce using rule 43 (psign -> TIMES .)
    IDENTIFIER      reduce using rule 43 (psign -> TIMES .)
    INTEGER         reduce using rule 43 (psign -> TIMES .)
    FLOAT           reduce using rule 43 (psign -> TIMES .)
    STRING          reduce using rule 43 (psign -> TIMES .)
    BOOL            reduce using rule 43 (psign -> TIMES .)


state 76

    (44) psign -> DIV .

    LPAREN          reduce using rule 44 (psign -> DIV .)
    NOT             reduce using rule 44 (psign -> DIV .)
    IDENTIFIER      reduce using rule 44 (psign -> DIV .)
    INTEGER         reduce using rule 44 (psign -> DIV .)
    FLOAT           reduce using rule 44 (psign -> DIV .)
    STRING          reduce using rule 44 (psign -> DIV .)
    BOOL            reduce using rule 44 (psign -> DIV .)


state 77

    (59) element -> LPAREN expression . RPAREN
    (36) expression -> expression . and_or expression_m
    (41) and_or -> . AND
    (42) and_or -> . OR

    RPAREN          shift and go to state 93
    AND             shift and go to state 62
    OR              shift and go to state 63

    and_or                         shift and go to state 61

state 78

    (60) element -> NOT element .

    TIMES           reduce using rule 60 (element -> NOT element .)
    DIV             reduce using rule 60 (element -> NOT element .)
    PLUS            reduce using rule 60 (element -> NOT element .)
    MINUS           reduce using rule 60 (element -> NOT element .)
    MOD             reduce using rule 60 (element -> NOT element .)
    EQUAL           reduce using rule 60 (element -> NOT element .)
    NEQUAL          reduce using rule 60 (element -> NOT element .)
    LT              reduce using rule 60 (element -> NOT element .)
    LTE             reduce using rule 60 (element -> NOT element .)
    GT              reduce using rule 60 (element -> NOT element .)
    GTE             reduce using rule 60 (element -> NOT element .)
    AND             reduce using rule 60 (element -> NOT element .)
    OR              reduce using rule 60 (element -> NOT element .)
    LBRACKET        reduce using rule 60 (element -> NOT element .)
    IF              reduce using rule 60 (element -> NOT element .)
    WHILE           reduce using rule 60 (element -> NOT element .)
    RETURN          reduce using rule 60 (element -> NOT element .)
    IDENTIFIER      reduce using rule 60 (element -> NOT element .)
    ELSE            reduce using rule 60 (element -> NOT element .)
    $end            reduce using rule 60 (element -> NOT element .)
    RBRACKET        reduce using rule 60 (element -> NOT element .)
    SEMICOLON       reduce using rule 60 (element -> NOT element .)
    RPAREN          reduce using rule 60 (element -> NOT element .)
    COMMA           reduce using rule 60 (element -> NOT element .)


state 79

    (33) while_statement -> WHILE expression body .

    IDENTIFIER      reduce using rule 33 (while_statement -> WHILE expression body .)
    $end            reduce using rule 33 (while_statement -> WHILE expression body .)
    LBRACKET        reduce using rule 33 (while_statement -> WHILE expression body .)
    IF              reduce using rule 33 (while_statement -> WHILE expression body .)
    WHILE           reduce using rule 33 (while_statement -> WHILE expression body .)
    RETURN          reduce using rule 33 (while_statement -> WHILE expression body .)
    RBRACKET        reduce using rule 33 (while_statement -> WHILE expression body .)
    ELSE            reduce using rule 33 (while_statement -> WHILE expression body .)


state 80

    (34) return_statement -> RETURN element SEMICOLON .

    IDENTIFIER      reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)
    $end            reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)
    LBRACKET        reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)
    IF              reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)
    WHILE           reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)
    RETURN          reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)
    RBRACKET        reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)
    ELSE            reduce using rule 34 (return_statement -> RETURN element SEMICOLON .)


state 81

    (8) function_declaration -> identifier COLON type LPAREN . parameter_list RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN . parameter_list RPAREN
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter -> . identifier COLON type
    (61) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 7

    identifier                     shift and go to state 94
    parameter_list                 shift and go to state 95
    parameter                      shift and go to state 96

state 82

    (5) variable_declaration -> identifier COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)
    $end            reduce using rule 5 (variable_declaration -> identifier COLON type SEMICOLON .)


state 83

    (6) variable_declaration -> identifier COLON type ASSIGNMENT . element SEMICOLON
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    identifier                     shift and go to state 33
    element                        shift and go to state 97
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 84

    (30) assignment_statement -> identifier COLON type ASSIGNMENT . element SEMICOLON
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    identifier                     shift and go to state 33
    element                        shift and go to state 98
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 85

    (25) procedure_or_function_call -> identifier LPAREN param_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 99


state 86

    (27) param_list -> param_list COMMA . param
    (29) param -> . expression
    (35) expression -> . expression_m
    (36) expression -> . expression and_or expression_m
    (37) expression_m -> . expression_s
    (38) expression_m -> . expression_m sign expression_s
    (39) expression_s -> . element
    (40) expression_s -> . expression_s psign element
    (54) element -> . identifier
    (55) element -> . integer
    (56) element -> . float
    (57) element -> . string
    (58) element -> . bool
    (59) element -> . LPAREN expression RPAREN
    (60) element -> . NOT element
    (61) identifier -> . IDENTIFIER
    (62) integer -> . INTEGER
    (63) float -> . FLOAT
    (64) string -> . STRING
    (65) bool -> . BOOL

    LPAREN          shift and go to state 38
    NOT             shift and go to state 39
    IDENTIFIER      shift and go to state 7
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 42
    BOOL            shift and go to state 43

    param                          shift and go to state 100
    expression                     shift and go to state 58
    expression_m                   shift and go to state 30
    expression_s                   shift and go to state 31
    element                        shift and go to state 32
    identifier                     shift and go to state 33
    integer                        shift and go to state 34
    float                          shift and go to state 35
    string                         shift and go to state 36
    bool                           shift and go to state 37

state 87

    (26) procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 26 (procedure_or_function_call -> identifier LPAREN RPAREN SEMICOLON .)


state 88

    (66) array -> identifier LBRACKET_S integer RBRACKET_S . SEMICOLON

    SEMICOLON       shift and go to state 101


state 89

    (31) if_statement -> IF expression body ELSE . body
    (24) body -> . statement
    (16) statement -> . statement_part
    (17) statement -> . assignment_statement
    (18) statement -> . if_statement
    (19) statement -> . while_statement
    (20) statement -> . return_statement
    (21) statement -> . procedure_or_function_call
    (22) statement -> . array
    (23) statement -> .
    (13) statement_part -> . LBRACKET statement_sequence RBRACKET
    (30) assignment_statement -> . identifier COLON type ASSIGNMENT element SEMICOLON
    (31) if_statement -> . IF expression body ELSE body
    (32) if_statement -> . IF expression body
    (33) while_statement -> . WHILE expression body
    (34) return_statement -> . RETURN element SEMICOLON
    (25) procedure_or_function_call -> . identifier LPAREN param_list RPAREN SEMICOLON
    (26) procedure_or_function_call -> . identifier LPAREN RPAREN SEMICOLON
    (66) array -> . identifier LBRACKET_S integer RBRACKET_S SEMICOLON
    (61) identifier -> . IDENTIFIER

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    ELSE            reduce using rule 23 (statement -> .)
    $end            reduce using rule 23 (statement -> .)
    RBRACKET        reduce using rule 23 (statement -> .)
    LBRACKET        shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 22
    IDENTIFIER      shift and go to state 7

  ! IDENTIFIER      [ reduce using rule 23 (statement -> .) ]
  ! LBRACKET        [ reduce using rule 23 (statement -> .) ]
  ! IF              [ reduce using rule 23 (statement -> .) ]
  ! WHILE           [ reduce using rule 23 (statement -> .) ]
  ! RETURN          [ reduce using rule 23 (statement -> .) ]

    body                           shift and go to state 102
    statement                      shift and go to state 10
    statement_part                 shift and go to state 11
    assignment_statement           shift and go to state 12
    if_statement                   shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    procedure_or_function_call     shift and go to state 16
    array                          shift and go to state 17
    identifier                     shift and go to state 19

state 90

    (36) expression -> expression and_or expression_m .
    (38) expression_m -> expression_m . sign expression_s
    (45) sign -> . PLUS
    (46) sign -> . MINUS
    (47) sign -> . MOD
    (48) sign -> . EQUAL
    (49) sign -> . NEQUAL
    (50) sign -> . LT
    (51) sign -> . LTE
    (52) sign -> . GT
    (53) sign -> . GTE

    AND             reduce using rule 36 (expression -> expression and_or expression_m .)
    OR              reduce using rule 36 (expression -> expression and_or expression_m .)
    LBRACKET        reduce using rule 36 (expression -> expression and_or expression_m .)
    IF              reduce using rule 36 (expression -> expression and_or expression_m .)
    WHILE           reduce using rule 36 (expression -> expression and_or expression_m .)
    RETURN          reduce using rule 36 (expression -> expression and_or expression_m .)
    IDENTIFIER      reduce using rule 36 (expression -> expression and_or expression_m .)
    ELSE            reduce using rule 36 (expression -> expression and_or expression_m .)
    $end            reduce using rule 36 (expression -> expression and_or expression_m .)
    RBRACKET        reduce using rule 36 (expression -> expression and_or expression_m .)
    RPAREN          reduce using rule 36 (expression -> expression and_or expression_m .)
    COMMA           reduce using rule 36 (expression -> expression and_or expression_m .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    MOD             shift and go to state 67
    EQUAL           shift and go to state 68
    NEQUAL          shift and go to state 69
    LT              shift and go to state 70
    LTE             shift and go to state 71
    GT              shift and go to state 72
    GTE             shift and go to state 73

    sign                           shift and go to state 64

state 91

    (38) expression_m -> expression_m sign expression_s .
    (40) expression_s -> expression_s . psign element
    (43) psign -> . TIMES
    (44) psign -> . DIV

    PLUS            reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    MINUS           reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    MOD             reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    EQUAL           reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    NEQUAL          reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    LT              reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    LTE             reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    GT              reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    GTE             reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    AND             reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    OR              reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    LBRACKET        reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    IF              reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    WHILE           reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    RETURN          reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    IDENTIFIER      reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    ELSE            reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    $end            reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    RBRACKET        reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    RPAREN          reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    COMMA           reduce using rule 38 (expression_m -> expression_m sign expression_s .)
    TIMES           shift and go to state 75
    DIV             shift and go to state 76

    psign                          shift and go to state 74

state 92

    (40) expression_s -> expression_s psign element .

    TIMES           reduce using rule 40 (expression_s -> expression_s psign element .)
    DIV             reduce using rule 40 (expression_s -> expression_s psign element .)
    PLUS            reduce using rule 40 (expression_s -> expression_s psign element .)
    MINUS           reduce using rule 40 (expression_s -> expression_s psign element .)
    MOD             reduce using rule 40 (expression_s -> expression_s psign element .)
    EQUAL           reduce using rule 40 (expression_s -> expression_s psign element .)
    NEQUAL          reduce using rule 40 (expression_s -> expression_s psign element .)
    LT              reduce using rule 40 (expression_s -> expression_s psign element .)
    LTE             reduce using rule 40 (expression_s -> expression_s psign element .)
    GT              reduce using rule 40 (expression_s -> expression_s psign element .)
    GTE             reduce using rule 40 (expression_s -> expression_s psign element .)
    AND             reduce using rule 40 (expression_s -> expression_s psign element .)
    OR              reduce using rule 40 (expression_s -> expression_s psign element .)
    LBRACKET        reduce using rule 40 (expression_s -> expression_s psign element .)
    IF              reduce using rule 40 (expression_s -> expression_s psign element .)
    WHILE           reduce using rule 40 (expression_s -> expression_s psign element .)
    RETURN          reduce using rule 40 (expression_s -> expression_s psign element .)
    IDENTIFIER      reduce using rule 40 (expression_s -> expression_s psign element .)
    ELSE            reduce using rule 40 (expression_s -> expression_s psign element .)
    $end            reduce using rule 40 (expression_s -> expression_s psign element .)
    RBRACKET        reduce using rule 40 (expression_s -> expression_s psign element .)
    RPAREN          reduce using rule 40 (expression_s -> expression_s psign element .)
    COMMA           reduce using rule 40 (expression_s -> expression_s psign element .)


state 93

    (59) element -> LPAREN expression RPAREN .

    TIMES           reduce using rule 59 (element -> LPAREN expression RPAREN .)
    DIV             reduce using rule 59 (element -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 59 (element -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 59 (element -> LPAREN expression RPAREN .)
    MOD             reduce using rule 59 (element -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 59 (element -> LPAREN expression RPAREN .)
    NEQUAL          reduce using rule 59 (element -> LPAREN expression RPAREN .)
    LT              reduce using rule 59 (element -> LPAREN expression RPAREN .)
    LTE             reduce using rule 59 (element -> LPAREN expression RPAREN .)
    GT              reduce using rule 59 (element -> LPAREN expression RPAREN .)
    GTE             reduce using rule 59 (element -> LPAREN expression RPAREN .)
    AND             reduce using rule 59 (element -> LPAREN expression RPAREN .)
    OR              reduce using rule 59 (element -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 59 (element -> LPAREN expression RPAREN .)
    IF              reduce using rule 59 (element -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 59 (element -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 59 (element -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 59 (element -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 59 (element -> LPAREN expression RPAREN .)
    $end            reduce using rule 59 (element -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 59 (element -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 59 (element -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 59 (element -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 59 (element -> LPAREN expression RPAREN .)


state 94

    (12) parameter -> identifier . COLON type

    COLON           shift and go to state 103


state 95

    (8) function_declaration -> identifier COLON type LPAREN parameter_list . RPAREN SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list . RPAREN

    RPAREN          shift and go to state 104


state 96

    (10) parameter_list -> parameter . COMMA parameter_list
    (11) parameter_list -> parameter .

    COMMA           shift and go to state 105
    RPAREN          reduce using rule 11 (parameter_list -> parameter .)


state 97

    (6) variable_declaration -> identifier COLON type ASSIGNMENT element . SEMICOLON

    SEMICOLON       shift and go to state 106


state 98

    (30) assignment_statement -> identifier COLON type ASSIGNMENT element . SEMICOLON

    SEMICOLON       shift and go to state 107


state 99

    (25) procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    $end            reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    IF              reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)
    ELSE            reduce using rule 25 (procedure_or_function_call -> identifier LPAREN param_list RPAREN SEMICOLON .)


state 100

    (27) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 27 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 27 (param_list -> param_list COMMA param .)


state 101

    (66) array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .

    IDENTIFIER      reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)
    $end            reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)
    LBRACKET        reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)
    IF              reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)
    WHILE           reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)
    RETURN          reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)
    RBRACKET        reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)
    ELSE            reduce using rule 66 (array -> identifier LBRACKET_S integer RBRACKET_S SEMICOLON .)


state 102

    (31) if_statement -> IF expression body ELSE body .

    IDENTIFIER      reduce using rule 31 (if_statement -> IF expression body ELSE body .)
    $end            reduce using rule 31 (if_statement -> IF expression body ELSE body .)
    LBRACKET        reduce using rule 31 (if_statement -> IF expression body ELSE body .)
    IF              reduce using rule 31 (if_statement -> IF expression body ELSE body .)
    WHILE           reduce using rule 31 (if_statement -> IF expression body ELSE body .)
    RETURN          reduce using rule 31 (if_statement -> IF expression body ELSE body .)
    RBRACKET        reduce using rule 31 (if_statement -> IF expression body ELSE body .)
    ELSE            reduce using rule 31 (if_statement -> IF expression body ELSE body .)


state 103

    (12) parameter -> identifier COLON . type
    (67) type -> . TINTEGER
    (68) type -> . TFLOAT
    (69) type -> . TSTRING
    (70) type -> . TBOOL
    (71) type -> . TARRAY

    TINTEGER        shift and go to state 47
    TFLOAT          shift and go to state 48
    TSTRING         shift and go to state 49
    TBOOL           shift and go to state 50
    TARRAY          shift and go to state 51

    type                           shift and go to state 108

state 104

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN . SEMICOLON
    (9) function_heading -> identifier COLON type LPAREN parameter_list RPAREN .

    SEMICOLON       shift and go to state 109
    LBRACKET        reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IF              reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    WHILE           reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    RETURN          reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    IDENTIFIER      reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)
    $end            reduce using rule 9 (function_heading -> identifier COLON type LPAREN parameter_list RPAREN .)


state 105

    (10) parameter_list -> parameter COMMA . parameter_list
    (10) parameter_list -> . parameter COMMA parameter_list
    (11) parameter_list -> . parameter
    (12) parameter -> . identifier COLON type
    (61) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 7

    parameter                      shift and go to state 96
    parameter_list                 shift and go to state 110
    identifier                     shift and go to state 94

state 106

    (6) variable_declaration -> identifier COLON type ASSIGNMENT element SEMICOLON .

    IDENTIFIER      reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    $end            reduce using rule 6 (variable_declaration -> identifier COLON type ASSIGNMENT element SEMICOLON .)


state 107

    (30) assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .

    IDENTIFIER      reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    $end            reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    LBRACKET        reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    IF              reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    WHILE           reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    RETURN          reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    RBRACKET        reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)
    ELSE            reduce using rule 30 (assignment_statement -> identifier COLON type ASSIGNMENT element SEMICOLON .)


state 108

    (12) parameter -> identifier COLON type .

    COMMA           reduce using rule 12 (parameter -> identifier COLON type .)
    RPAREN          reduce using rule 12 (parameter -> identifier COLON type .)


state 109

    (8) function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)
    $end            reduce using rule 8 (function_declaration -> identifier COLON type LPAREN parameter_list RPAREN SEMICOLON .)


state 110

    (10) parameter_list -> parameter COMMA parameter_list .

    RPAREN          reduce using rule 10 (parameter_list -> parameter COMMA parameter_list .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 5 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 18 resolved as shift
WARNING: shift/reduce conflict for IF in state 18 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 18 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 18 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 18 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 25 resolved as shift
WARNING: shift/reduce conflict for IF in state 25 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 25 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 25 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 25 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 29 resolved as shift
WARNING: shift/reduce conflict for IF in state 29 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 29 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 29 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 29 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 44 resolved as shift
WARNING: shift/reduce conflict for IF in state 44 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 44 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 44 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 44 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 60 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 89 resolved as shift
WARNING: shift/reduce conflict for IF in state 89 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 89 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 89 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 89 resolved as shift
WARNING: reduce/reduce conflict in state 25 resolved using rule (statement_sequence -> statement)
WARNING: rejected rule (statement -> <empty>) in state 25
